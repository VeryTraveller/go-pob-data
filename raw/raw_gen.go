package raw

// Code generated by github.com/tinylib/msgp DO NOT EDIT.

import (
	"github.com/tinylib/msgp/msgp"
)

// DecodeMsg implements msgp.Decodable
func (z *ActiveSkill) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AIFile":
			z.AIFile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AIFile")
				return
			}
		case "ActiveSkillTargetTypes":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ActiveSkillTargetTypes")
				return
			}
			if cap(z.ActiveSkillTargetTypes) >= int(zb0002) {
				z.ActiveSkillTargetTypes = (z.ActiveSkillTargetTypes)[:zb0002]
			} else {
				z.ActiveSkillTargetTypes = make([]int, zb0002)
			}
			for za0001 := range z.ActiveSkillTargetTypes {
				z.ActiveSkillTargetTypes[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ActiveSkillTargetTypes", za0001)
					return
				}
			}
		case "ActiveSkillTypes":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ActiveSkillTypes")
				return
			}
			if cap(z.ActiveSkillTypes) >= int(zb0003) {
				z.ActiveSkillTypes = (z.ActiveSkillTypes)[:zb0003]
			} else {
				z.ActiveSkillTypes = make([]int, zb0003)
			}
			for za0002 := range z.ActiveSkillTypes {
				z.ActiveSkillTypes[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ActiveSkillTypes", za0002)
					return
				}
			}
		case "AlternateSkillTargetingBehavioursKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AlternateSkillTargetingBehavioursKey")
					return
				}
				z.AlternateSkillTargetingBehavioursKey = nil
			} else {
				if z.AlternateSkillTargetingBehavioursKey == nil {
					z.AlternateSkillTargetingBehavioursKey = new(int)
				}
				*z.AlternateSkillTargetingBehavioursKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AlternateSkillTargetingBehavioursKey")
					return
				}
			}
		case "Description":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "DisplayedName":
			z.DisplayedName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayedName")
				return
			}
		case "IconDDSFile":
			z.IconDDSFile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "IconDDSFile")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "InputStatKeys":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "InputStatKeys")
				return
			}
			if cap(z.InputStatKeys) >= int(zb0004) {
				z.InputStatKeys = (z.InputStatKeys)[:zb0004]
			} else {
				z.InputStatKeys = make([]int, zb0004)
			}
			for za0003 := range z.InputStatKeys {
				z.InputStatKeys[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "InputStatKeys", za0003)
					return
				}
			}
		case "IsManuallyCasted":
			z.IsManuallyCasted, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsManuallyCasted")
				return
			}
		case "MinionActiveSkillTypes":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MinionActiveSkillTypes")
				return
			}
			if cap(z.MinionActiveSkillTypes) >= int(zb0005) {
				z.MinionActiveSkillTypes = (z.MinionActiveSkillTypes)[:zb0005]
			} else {
				z.MinionActiveSkillTypes = make([]int, zb0005)
			}
			for za0004 := range z.MinionActiveSkillTypes {
				z.MinionActiveSkillTypes[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MinionActiveSkillTypes", za0004)
					return
				}
			}
		case "OutputStatKeys":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "OutputStatKeys")
				return
			}
			if cap(z.OutputStatKeys) >= int(zb0006) {
				z.OutputStatKeys = (z.OutputStatKeys)[:zb0006]
			} else {
				z.OutputStatKeys = make([]int, zb0006)
			}
			for za0005 := range z.OutputStatKeys {
				z.OutputStatKeys[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OutputStatKeys", za0005)
					return
				}
			}
		case "SkillTotemID":
			z.SkillTotemID, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SkillTotemID")
				return
			}
		case "WeaponRestrictionItemClassesKeys":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WeaponRestrictionItemClassesKeys")
				return
			}
			if cap(z.WeaponRestrictionItemClassesKeys) >= int(zb0007) {
				z.WeaponRestrictionItemClassesKeys = (z.WeaponRestrictionItemClassesKeys)[:zb0007]
			} else {
				z.WeaponRestrictionItemClassesKeys = make([]int, zb0007)
			}
			for za0006 := range z.WeaponRestrictionItemClassesKeys {
				z.WeaponRestrictionItemClassesKeys[za0006], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "WeaponRestrictionItemClassesKeys", za0006)
					return
				}
			}
		case "WebsiteDescription":
			z.WebsiteDescription, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WebsiteDescription")
				return
			}
		case "WebsiteImage":
			z.WebsiteImage, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "WebsiteImage")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ActiveSkill) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 17
	// write "AIFile"
	err = en.Append(0xde, 0x0, 0x11, 0xa6, 0x41, 0x49, 0x46, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.AIFile)
	if err != nil {
		err = msgp.WrapError(err, "AIFile")
		return
	}
	// write "ActiveSkillTargetTypes"
	err = en.Append(0xb6, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ActiveSkillTargetTypes)))
	if err != nil {
		err = msgp.WrapError(err, "ActiveSkillTargetTypes")
		return
	}
	for za0001 := range z.ActiveSkillTargetTypes {
		err = en.WriteInt(z.ActiveSkillTargetTypes[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ActiveSkillTargetTypes", za0001)
			return
		}
	}
	// write "ActiveSkillTypes"
	err = en.Append(0xb0, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ActiveSkillTypes)))
	if err != nil {
		err = msgp.WrapError(err, "ActiveSkillTypes")
		return
	}
	for za0002 := range z.ActiveSkillTypes {
		err = en.WriteInt(z.ActiveSkillTypes[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ActiveSkillTypes", za0002)
			return
		}
	}
	// write "AlternateSkillTargetingBehavioursKey"
	err = en.Append(0xd9, 0x24, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x42, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x75, 0x72, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.AlternateSkillTargetingBehavioursKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.AlternateSkillTargetingBehavioursKey)
		if err != nil {
			err = msgp.WrapError(err, "AlternateSkillTargetingBehavioursKey")
			return
		}
	}
	// write "Description"
	err = en.Append(0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "DisplayedName"
	err = en.Append(0xad, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.DisplayedName)
	if err != nil {
		err = msgp.WrapError(err, "DisplayedName")
		return
	}
	// write "IconDDSFile"
	err = en.Append(0xab, 0x49, 0x63, 0x6f, 0x6e, 0x44, 0x44, 0x53, 0x46, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.IconDDSFile)
	if err != nil {
		err = msgp.WrapError(err, "IconDDSFile")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "InputStatKeys"
	err = en.Append(0xad, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.InputStatKeys)))
	if err != nil {
		err = msgp.WrapError(err, "InputStatKeys")
		return
	}
	for za0003 := range z.InputStatKeys {
		err = en.WriteInt(z.InputStatKeys[za0003])
		if err != nil {
			err = msgp.WrapError(err, "InputStatKeys", za0003)
			return
		}
	}
	// write "IsManuallyCasted"
	err = en.Append(0xb0, 0x49, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x6c, 0x79, 0x43, 0x61, 0x73, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsManuallyCasted)
	if err != nil {
		err = msgp.WrapError(err, "IsManuallyCasted")
		return
	}
	// write "MinionActiveSkillTypes"
	err = en.Append(0xb6, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MinionActiveSkillTypes)))
	if err != nil {
		err = msgp.WrapError(err, "MinionActiveSkillTypes")
		return
	}
	for za0004 := range z.MinionActiveSkillTypes {
		err = en.WriteInt(z.MinionActiveSkillTypes[za0004])
		if err != nil {
			err = msgp.WrapError(err, "MinionActiveSkillTypes", za0004)
			return
		}
	}
	// write "OutputStatKeys"
	err = en.Append(0xae, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.OutputStatKeys)))
	if err != nil {
		err = msgp.WrapError(err, "OutputStatKeys")
		return
	}
	for za0005 := range z.OutputStatKeys {
		err = en.WriteInt(z.OutputStatKeys[za0005])
		if err != nil {
			err = msgp.WrapError(err, "OutputStatKeys", za0005)
			return
		}
	}
	// write "SkillTotemID"
	err = en.Append(0xac, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x74, 0x65, 0x6d, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SkillTotemID)
	if err != nil {
		err = msgp.WrapError(err, "SkillTotemID")
		return
	}
	// write "WeaponRestrictionItemClassesKeys"
	err = en.Append(0xd9, 0x20, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WeaponRestrictionItemClassesKeys)))
	if err != nil {
		err = msgp.WrapError(err, "WeaponRestrictionItemClassesKeys")
		return
	}
	for za0006 := range z.WeaponRestrictionItemClassesKeys {
		err = en.WriteInt(z.WeaponRestrictionItemClassesKeys[za0006])
		if err != nil {
			err = msgp.WrapError(err, "WeaponRestrictionItemClassesKeys", za0006)
			return
		}
	}
	// write "WebsiteDescription"
	err = en.Append(0xb2, 0x57, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.WebsiteDescription)
	if err != nil {
		err = msgp.WrapError(err, "WebsiteDescription")
		return
	}
	// write "WebsiteImage"
	err = en.Append(0xac, 0x57, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x49, 0x6d, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.WebsiteImage)
	if err != nil {
		err = msgp.WrapError(err, "WebsiteImage")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ActiveSkill) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 17
	// string "AIFile"
	o = append(o, 0xde, 0x0, 0x11, 0xa6, 0x41, 0x49, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.AIFile)
	// string "ActiveSkillTargetTypes"
	o = append(o, 0xb6, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ActiveSkillTargetTypes)))
	for za0001 := range z.ActiveSkillTargetTypes {
		o = msgp.AppendInt(o, z.ActiveSkillTargetTypes[za0001])
	}
	// string "ActiveSkillTypes"
	o = append(o, 0xb0, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ActiveSkillTypes)))
	for za0002 := range z.ActiveSkillTypes {
		o = msgp.AppendInt(o, z.ActiveSkillTypes[za0002])
	}
	// string "AlternateSkillTargetingBehavioursKey"
	o = append(o, 0xd9, 0x24, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x61, 0x72, 0x67, 0x65, 0x74, 0x69, 0x6e, 0x67, 0x42, 0x65, 0x68, 0x61, 0x76, 0x69, 0x6f, 0x75, 0x72, 0x73, 0x4b, 0x65, 0x79)
	if z.AlternateSkillTargetingBehavioursKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.AlternateSkillTargetingBehavioursKey)
	}
	// string "Description"
	o = append(o, 0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "DisplayedName"
	o = append(o, 0xad, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x65, 0x64, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.DisplayedName)
	// string "IconDDSFile"
	o = append(o, 0xab, 0x49, 0x63, 0x6f, 0x6e, 0x44, 0x44, 0x53, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.IconDDSFile)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "InputStatKeys"
	o = append(o, 0xad, 0x49, 0x6e, 0x70, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.InputStatKeys)))
	for za0003 := range z.InputStatKeys {
		o = msgp.AppendInt(o, z.InputStatKeys[za0003])
	}
	// string "IsManuallyCasted"
	o = append(o, 0xb0, 0x49, 0x73, 0x4d, 0x61, 0x6e, 0x75, 0x61, 0x6c, 0x6c, 0x79, 0x43, 0x61, 0x73, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.IsManuallyCasted)
	// string "MinionActiveSkillTypes"
	o = append(o, 0xb6, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MinionActiveSkillTypes)))
	for za0004 := range z.MinionActiveSkillTypes {
		o = msgp.AppendInt(o, z.MinionActiveSkillTypes[za0004])
	}
	// string "OutputStatKeys"
	o = append(o, 0xae, 0x4f, 0x75, 0x74, 0x70, 0x75, 0x74, 0x53, 0x74, 0x61, 0x74, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.OutputStatKeys)))
	for za0005 := range z.OutputStatKeys {
		o = msgp.AppendInt(o, z.OutputStatKeys[za0005])
	}
	// string "SkillTotemID"
	o = append(o, 0xac, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x74, 0x65, 0x6d, 0x49, 0x44)
	o = msgp.AppendInt(o, z.SkillTotemID)
	// string "WeaponRestrictionItemClassesKeys"
	o = append(o, 0xd9, 0x20, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WeaponRestrictionItemClassesKeys)))
	for za0006 := range z.WeaponRestrictionItemClassesKeys {
		o = msgp.AppendInt(o, z.WeaponRestrictionItemClassesKeys[za0006])
	}
	// string "WebsiteDescription"
	o = append(o, 0xb2, 0x57, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.WebsiteDescription)
	// string "WebsiteImage"
	o = append(o, 0xac, 0x57, 0x65, 0x62, 0x73, 0x69, 0x74, 0x65, 0x49, 0x6d, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.WebsiteImage)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ActiveSkill) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AIFile":
			z.AIFile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AIFile")
				return
			}
		case "ActiveSkillTargetTypes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActiveSkillTargetTypes")
				return
			}
			if cap(z.ActiveSkillTargetTypes) >= int(zb0002) {
				z.ActiveSkillTargetTypes = (z.ActiveSkillTargetTypes)[:zb0002]
			} else {
				z.ActiveSkillTargetTypes = make([]int, zb0002)
			}
			for za0001 := range z.ActiveSkillTargetTypes {
				z.ActiveSkillTargetTypes[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActiveSkillTargetTypes", za0001)
					return
				}
			}
		case "ActiveSkillTypes":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ActiveSkillTypes")
				return
			}
			if cap(z.ActiveSkillTypes) >= int(zb0003) {
				z.ActiveSkillTypes = (z.ActiveSkillTypes)[:zb0003]
			} else {
				z.ActiveSkillTypes = make([]int, zb0003)
			}
			for za0002 := range z.ActiveSkillTypes {
				z.ActiveSkillTypes[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActiveSkillTypes", za0002)
					return
				}
			}
		case "AlternateSkillTargetingBehavioursKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AlternateSkillTargetingBehavioursKey = nil
			} else {
				if z.AlternateSkillTargetingBehavioursKey == nil {
					z.AlternateSkillTargetingBehavioursKey = new(int)
				}
				*z.AlternateSkillTargetingBehavioursKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AlternateSkillTargetingBehavioursKey")
					return
				}
			}
		case "Description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "DisplayedName":
			z.DisplayedName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayedName")
				return
			}
		case "IconDDSFile":
			z.IconDDSFile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IconDDSFile")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "InputStatKeys":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InputStatKeys")
				return
			}
			if cap(z.InputStatKeys) >= int(zb0004) {
				z.InputStatKeys = (z.InputStatKeys)[:zb0004]
			} else {
				z.InputStatKeys = make([]int, zb0004)
			}
			for za0003 := range z.InputStatKeys {
				z.InputStatKeys[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "InputStatKeys", za0003)
					return
				}
			}
		case "IsManuallyCasted":
			z.IsManuallyCasted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsManuallyCasted")
				return
			}
		case "MinionActiveSkillTypes":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinionActiveSkillTypes")
				return
			}
			if cap(z.MinionActiveSkillTypes) >= int(zb0005) {
				z.MinionActiveSkillTypes = (z.MinionActiveSkillTypes)[:zb0005]
			} else {
				z.MinionActiveSkillTypes = make([]int, zb0005)
			}
			for za0004 := range z.MinionActiveSkillTypes {
				z.MinionActiveSkillTypes[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MinionActiveSkillTypes", za0004)
					return
				}
			}
		case "OutputStatKeys":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OutputStatKeys")
				return
			}
			if cap(z.OutputStatKeys) >= int(zb0006) {
				z.OutputStatKeys = (z.OutputStatKeys)[:zb0006]
			} else {
				z.OutputStatKeys = make([]int, zb0006)
			}
			for za0005 := range z.OutputStatKeys {
				z.OutputStatKeys[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OutputStatKeys", za0005)
					return
				}
			}
		case "SkillTotemID":
			z.SkillTotemID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SkillTotemID")
				return
			}
		case "WeaponRestrictionItemClassesKeys":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeaponRestrictionItemClassesKeys")
				return
			}
			if cap(z.WeaponRestrictionItemClassesKeys) >= int(zb0007) {
				z.WeaponRestrictionItemClassesKeys = (z.WeaponRestrictionItemClassesKeys)[:zb0007]
			} else {
				z.WeaponRestrictionItemClassesKeys = make([]int, zb0007)
			}
			for za0006 := range z.WeaponRestrictionItemClassesKeys {
				z.WeaponRestrictionItemClassesKeys[za0006], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WeaponRestrictionItemClassesKeys", za0006)
					return
				}
			}
		case "WebsiteDescription":
			z.WebsiteDescription, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WebsiteDescription")
				return
			}
		case "WebsiteImage":
			z.WebsiteImage, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WebsiteImage")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ActiveSkill) Msgsize() (s int) {
	s = 3 + 7 + msgp.StringPrefixSize + len(z.AIFile) + 23 + msgp.ArrayHeaderSize + (len(z.ActiveSkillTargetTypes) * (msgp.IntSize)) + 17 + msgp.ArrayHeaderSize + (len(z.ActiveSkillTypes) * (msgp.IntSize)) + 38
	if z.AlternateSkillTargetingBehavioursKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 12 + msgp.StringPrefixSize + len(z.Description) + 14 + msgp.StringPrefixSize + len(z.DisplayedName) + 12 + msgp.StringPrefixSize + len(z.IconDDSFile) + 3 + msgp.StringPrefixSize + len(z.ID) + 14 + msgp.ArrayHeaderSize + (len(z.InputStatKeys) * (msgp.IntSize)) + 17 + msgp.BoolSize + 23 + msgp.ArrayHeaderSize + (len(z.MinionActiveSkillTypes) * (msgp.IntSize)) + 15 + msgp.ArrayHeaderSize + (len(z.OutputStatKeys) * (msgp.IntSize)) + 13 + msgp.IntSize + 34 + msgp.ArrayHeaderSize + (len(z.WeaponRestrictionItemClassesKeys) * (msgp.IntSize)) + 19 + msgp.StringPrefixSize + len(z.WebsiteDescription) + 13 + msgp.StringPrefixSize + len(z.WebsiteImage) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ActiveSkillType) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "FlagStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "FlagStat")
					return
				}
				z.FlagStat = nil
			} else {
				if z.FlagStat == nil {
					z.FlagStat = new(int)
				}
				*z.FlagStat, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "FlagStat")
					return
				}
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ActiveSkillType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "FlagStat"
	err = en.Append(0x83, 0xa8, 0x46, 0x6c, 0x61, 0x67, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	if z.FlagStat == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.FlagStat)
		if err != nil {
			err = msgp.WrapError(err, "FlagStat")
			return
		}
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ActiveSkillType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "FlagStat"
	o = append(o, 0x83, 0xa8, 0x46, 0x6c, 0x61, 0x67, 0x53, 0x74, 0x61, 0x74)
	if z.FlagStat == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.FlagStat)
	}
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ActiveSkillType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "FlagStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.FlagStat = nil
			} else {
				if z.FlagStat == nil {
					z.FlagStat = new(int)
				}
				*z.FlagStat, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FlagStat")
					return
				}
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ActiveSkillType) Msgsize() (s int) {
	s = 1 + 9
	if z.FlagStat == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 3 + msgp.StringPrefixSize + len(z.ID) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AlternatePassiveAddition) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AlternateTreeVersionsKey":
			z.AlternateTreeVersionsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AlternateTreeVersionsKey")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "PassiveType":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PassiveType")
				return
			}
			if cap(z.PassiveType) >= int(zb0002) {
				z.PassiveType = (z.PassiveType)[:zb0002]
			} else {
				z.PassiveType = make([]int, zb0002)
			}
			for za0001 := range z.PassiveType {
				z.PassiveType[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PassiveType", za0001)
					return
				}
			}
		case "SpawnWeight":
			z.SpawnWeight, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeight")
				return
			}
		case "Stat1Max":
			z.Stat1Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Max")
				return
			}
		case "Stat1Min":
			z.Stat1Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Min")
				return
			}
		case "StatsKeys":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "StatsKeys")
				return
			}
			if cap(z.StatsKeys) >= int(zb0003) {
				z.StatsKeys = (z.StatsKeys)[:zb0003]
			} else {
				z.StatsKeys = make([]int, zb0003)
			}
			for za0002 := range z.StatsKeys {
				z.StatsKeys[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKeys", za0002)
					return
				}
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AlternatePassiveAddition) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "AlternateTreeVersionsKey"
	err = en.Append(0x88, 0xb8, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x54, 0x72, 0x65, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AlternateTreeVersionsKey)
	if err != nil {
		err = msgp.WrapError(err, "AlternateTreeVersionsKey")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "PassiveType"
	err = en.Append(0xab, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PassiveType)))
	if err != nil {
		err = msgp.WrapError(err, "PassiveType")
		return
	}
	for za0001 := range z.PassiveType {
		err = en.WriteInt(z.PassiveType[za0001])
		if err != nil {
			err = msgp.WrapError(err, "PassiveType", za0001)
			return
		}
	}
	// write "SpawnWeight"
	err = en.Append(0xab, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SpawnWeight)
	if err != nil {
		err = msgp.WrapError(err, "SpawnWeight")
		return
	}
	// write "Stat1Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Max")
		return
	}
	// write "Stat1Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Min")
		return
	}
	// write "StatsKeys"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.StatsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "StatsKeys")
		return
	}
	for za0002 := range z.StatsKeys {
		err = en.WriteInt(z.StatsKeys[za0002])
		if err != nil {
			err = msgp.WrapError(err, "StatsKeys", za0002)
			return
		}
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AlternatePassiveAddition) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "AlternateTreeVersionsKey"
	o = append(o, 0x88, 0xb8, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x54, 0x72, 0x65, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.AlternateTreeVersionsKey)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "PassiveType"
	o = append(o, 0xab, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PassiveType)))
	for za0001 := range z.PassiveType {
		o = msgp.AppendInt(o, z.PassiveType[za0001])
	}
	// string "SpawnWeight"
	o = append(o, 0xab, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.SpawnWeight)
	// string "Stat1Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat1Max)
	// string "Stat1Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat1Min)
	// string "StatsKeys"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.StatsKeys)))
	for za0002 := range z.StatsKeys {
		o = msgp.AppendInt(o, z.StatsKeys[za0002])
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AlternatePassiveAddition) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AlternateTreeVersionsKey":
			z.AlternateTreeVersionsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AlternateTreeVersionsKey")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "PassiveType":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PassiveType")
				return
			}
			if cap(z.PassiveType) >= int(zb0002) {
				z.PassiveType = (z.PassiveType)[:zb0002]
			} else {
				z.PassiveType = make([]int, zb0002)
			}
			for za0001 := range z.PassiveType {
				z.PassiveType[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PassiveType", za0001)
					return
				}
			}
		case "SpawnWeight":
			z.SpawnWeight, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeight")
				return
			}
		case "Stat1Max":
			z.Stat1Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Max")
				return
			}
		case "Stat1Min":
			z.Stat1Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Min")
				return
			}
		case "StatsKeys":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKeys")
				return
			}
			if cap(z.StatsKeys) >= int(zb0003) {
				z.StatsKeys = (z.StatsKeys)[:zb0003]
			} else {
				z.StatsKeys = make([]int, zb0003)
			}
			for za0002 := range z.StatsKeys {
				z.StatsKeys[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKeys", za0002)
					return
				}
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AlternatePassiveAddition) Msgsize() (s int) {
	s = 1 + 25 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.ID) + 12 + msgp.ArrayHeaderSize + (len(z.PassiveType) * (msgp.IntSize)) + 12 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 10 + msgp.ArrayHeaderSize + (len(z.StatsKeys) * (msgp.IntSize)) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AlternatePassiveSkill) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AchievementItemsKeys":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AchievementItemsKeys")
				return
			}
			if cap(z.AchievementItemsKeys) >= int(zb0002) {
				z.AchievementItemsKeys = (z.AchievementItemsKeys)[:zb0002]
			} else {
				z.AchievementItemsKeys = make([]interface{}, zb0002)
			}
			for za0001 := range z.AchievementItemsKeys {
				z.AchievementItemsKeys[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "AchievementItemsKeys", za0001)
					return
				}
			}
		case "AlternateTreeVersionsKey":
			z.AlternateTreeVersionsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AlternateTreeVersionsKey")
				return
			}
		case "DDSIcon":
			z.DDSIcon, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DDSIcon")
				return
			}
		case "FlavourText":
			z.FlavourText, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FlavourText")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "PassiveType":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "PassiveType")
				return
			}
			if cap(z.PassiveType) >= int(zb0003) {
				z.PassiveType = (z.PassiveType)[:zb0003]
			} else {
				z.PassiveType = make([]int, zb0003)
			}
			for za0002 := range z.PassiveType {
				z.PassiveType[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PassiveType", za0002)
					return
				}
			}
		case "RandomMax":
			z.RandomMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RandomMax")
				return
			}
		case "RandomMin":
			z.RandomMin, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RandomMin")
				return
			}
		case "SpawnWeight":
			z.SpawnWeight, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeight")
				return
			}
		case "Stat1Max":
			z.Stat1Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Max")
				return
			}
		case "Stat1Min":
			z.Stat1Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Min")
				return
			}
		case "Stat2Max":
			z.Stat2Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat2Max")
				return
			}
		case "Stat2Min":
			z.Stat2Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat2Min")
				return
			}
		case "StatsKeys":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "StatsKeys")
				return
			}
			if cap(z.StatsKeys) >= int(zb0004) {
				z.StatsKeys = (z.StatsKeys)[:zb0004]
			} else {
				z.StatsKeys = make([]int, zb0004)
			}
			for za0003 := range z.StatsKeys {
				z.StatsKeys[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKeys", za0003)
					return
				}
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *AlternatePassiveSkill) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 16
	// write "AchievementItemsKeys"
	err = en.Append(0xde, 0x0, 0x10, 0xb4, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AchievementItemsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "AchievementItemsKeys")
		return
	}
	for za0001 := range z.AchievementItemsKeys {
		err = en.WriteIntf(z.AchievementItemsKeys[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AchievementItemsKeys", za0001)
			return
		}
	}
	// write "AlternateTreeVersionsKey"
	err = en.Append(0xb8, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x54, 0x72, 0x65, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AlternateTreeVersionsKey)
	if err != nil {
		err = msgp.WrapError(err, "AlternateTreeVersionsKey")
		return
	}
	// write "DDSIcon"
	err = en.Append(0xa7, 0x44, 0x44, 0x53, 0x49, 0x63, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.DDSIcon)
	if err != nil {
		err = msgp.WrapError(err, "DDSIcon")
		return
	}
	// write "FlavourText"
	err = en.Append(0xab, 0x46, 0x6c, 0x61, 0x76, 0x6f, 0x75, 0x72, 0x54, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.FlavourText)
	if err != nil {
		err = msgp.WrapError(err, "FlavourText")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "PassiveType"
	err = en.Append(0xab, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.PassiveType)))
	if err != nil {
		err = msgp.WrapError(err, "PassiveType")
		return
	}
	for za0002 := range z.PassiveType {
		err = en.WriteInt(z.PassiveType[za0002])
		if err != nil {
			err = msgp.WrapError(err, "PassiveType", za0002)
			return
		}
	}
	// write "RandomMax"
	err = en.Append(0xa9, 0x52, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RandomMax)
	if err != nil {
		err = msgp.WrapError(err, "RandomMax")
		return
	}
	// write "RandomMin"
	err = en.Append(0xa9, 0x52, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RandomMin)
	if err != nil {
		err = msgp.WrapError(err, "RandomMin")
		return
	}
	// write "SpawnWeight"
	err = en.Append(0xab, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SpawnWeight)
	if err != nil {
		err = msgp.WrapError(err, "SpawnWeight")
		return
	}
	// write "Stat1Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Max")
		return
	}
	// write "Stat1Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Min")
		return
	}
	// write "Stat2Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat2Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat2Max")
		return
	}
	// write "Stat2Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat2Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat2Min")
		return
	}
	// write "StatsKeys"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.StatsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "StatsKeys")
		return
	}
	for za0003 := range z.StatsKeys {
		err = en.WriteInt(z.StatsKeys[za0003])
		if err != nil {
			err = msgp.WrapError(err, "StatsKeys", za0003)
			return
		}
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *AlternatePassiveSkill) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 16
	// string "AchievementItemsKeys"
	o = append(o, 0xde, 0x0, 0x10, 0xb4, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AchievementItemsKeys)))
	for za0001 := range z.AchievementItemsKeys {
		o, err = msgp.AppendIntf(o, z.AchievementItemsKeys[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AchievementItemsKeys", za0001)
			return
		}
	}
	// string "AlternateTreeVersionsKey"
	o = append(o, 0xb8, 0x41, 0x6c, 0x74, 0x65, 0x72, 0x6e, 0x61, 0x74, 0x65, 0x54, 0x72, 0x65, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.AlternateTreeVersionsKey)
	// string "DDSIcon"
	o = append(o, 0xa7, 0x44, 0x44, 0x53, 0x49, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.DDSIcon)
	// string "FlavourText"
	o = append(o, 0xab, 0x46, 0x6c, 0x61, 0x76, 0x6f, 0x75, 0x72, 0x54, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.FlavourText)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "PassiveType"
	o = append(o, 0xab, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.PassiveType)))
	for za0002 := range z.PassiveType {
		o = msgp.AppendInt(o, z.PassiveType[za0002])
	}
	// string "RandomMax"
	o = append(o, 0xa9, 0x52, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.RandomMax)
	// string "RandomMin"
	o = append(o, 0xa9, 0x52, 0x61, 0x6e, 0x64, 0x6f, 0x6d, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.RandomMin)
	// string "SpawnWeight"
	o = append(o, 0xab, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.SpawnWeight)
	// string "Stat1Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat1Max)
	// string "Stat1Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat1Min)
	// string "Stat2Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat2Max)
	// string "Stat2Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat2Min)
	// string "StatsKeys"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.StatsKeys)))
	for za0003 := range z.StatsKeys {
		o = msgp.AppendInt(o, z.StatsKeys[za0003])
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AlternatePassiveSkill) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AchievementItemsKeys":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AchievementItemsKeys")
				return
			}
			if cap(z.AchievementItemsKeys) >= int(zb0002) {
				z.AchievementItemsKeys = (z.AchievementItemsKeys)[:zb0002]
			} else {
				z.AchievementItemsKeys = make([]interface{}, zb0002)
			}
			for za0001 := range z.AchievementItemsKeys {
				z.AchievementItemsKeys[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AchievementItemsKeys", za0001)
					return
				}
			}
		case "AlternateTreeVersionsKey":
			z.AlternateTreeVersionsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AlternateTreeVersionsKey")
				return
			}
		case "DDSIcon":
			z.DDSIcon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DDSIcon")
				return
			}
		case "FlavourText":
			z.FlavourText, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FlavourText")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "PassiveType":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PassiveType")
				return
			}
			if cap(z.PassiveType) >= int(zb0003) {
				z.PassiveType = (z.PassiveType)[:zb0003]
			} else {
				z.PassiveType = make([]int, zb0003)
			}
			for za0002 := range z.PassiveType {
				z.PassiveType[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PassiveType", za0002)
					return
				}
			}
		case "RandomMax":
			z.RandomMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RandomMax")
				return
			}
		case "RandomMin":
			z.RandomMin, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RandomMin")
				return
			}
		case "SpawnWeight":
			z.SpawnWeight, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeight")
				return
			}
		case "Stat1Max":
			z.Stat1Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Max")
				return
			}
		case "Stat1Min":
			z.Stat1Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Min")
				return
			}
		case "Stat2Max":
			z.Stat2Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat2Max")
				return
			}
		case "Stat2Min":
			z.Stat2Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat2Min")
				return
			}
		case "StatsKeys":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKeys")
				return
			}
			if cap(z.StatsKeys) >= int(zb0004) {
				z.StatsKeys = (z.StatsKeys)[:zb0004]
			} else {
				z.StatsKeys = make([]int, zb0004)
			}
			for za0003 := range z.StatsKeys {
				z.StatsKeys[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKeys", za0003)
					return
				}
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *AlternatePassiveSkill) Msgsize() (s int) {
	s = 3 + 21 + msgp.ArrayHeaderSize
	for za0001 := range z.AchievementItemsKeys {
		s += msgp.GuessSize(z.AchievementItemsKeys[za0001])
	}
	s += 25 + msgp.IntSize + 8 + msgp.StringPrefixSize + len(z.DDSIcon) + 12 + msgp.StringPrefixSize + len(z.FlavourText) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.Name) + 12 + msgp.ArrayHeaderSize + (len(z.PassiveType) * (msgp.IntSize)) + 10 + msgp.IntSize + 10 + msgp.IntSize + 12 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 10 + msgp.ArrayHeaderSize + (len(z.StatsKeys) * (msgp.IntSize)) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *AlternateTreeVersion) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ConquerorType":
			z.ConquerorType, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ConquerorType")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z AlternateTreeVersion) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "ConquerorType"
	err = en.Append(0x82, 0xad, 0x43, 0x6f, 0x6e, 0x71, 0x75, 0x65, 0x72, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.ConquerorType)
	if err != nil {
		err = msgp.WrapError(err, "ConquerorType")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z AlternateTreeVersion) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "ConquerorType"
	o = append(o, 0x82, 0xad, 0x43, 0x6f, 0x6e, 0x71, 0x75, 0x65, 0x72, 0x6f, 0x72, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendString(o, z.ConquerorType)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *AlternateTreeVersion) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ConquerorType":
			z.ConquerorType, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConquerorType")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z AlternateTreeVersion) Msgsize() (s int) {
	s = 1 + 14 + msgp.StringPrefixSize + len(z.ConquerorType) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ArmourType) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ArmourMax":
			z.ArmourMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ArmourMax")
				return
			}
		case "ArmourMin":
			z.ArmourMin, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ArmourMin")
				return
			}
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "EnergyShieldMax":
			z.EnergyShieldMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "EnergyShieldMax")
				return
			}
		case "EnergyShieldMin":
			z.EnergyShieldMin, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "EnergyShieldMin")
				return
			}
		case "EvasionMax":
			z.EvasionMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "EvasionMax")
				return
			}
		case "EvasionMin":
			z.EvasionMin, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "EvasionMin")
				return
			}
		case "IncreasedMovementSpeed":
			z.IncreasedMovementSpeed, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "IncreasedMovementSpeed")
				return
			}
		case "WardMax":
			z.WardMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "WardMax")
				return
			}
		case "WardMin":
			z.WardMin, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "WardMin")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ArmourType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "ArmourMax"
	err = en.Append(0x8b, 0xa9, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ArmourMax)
	if err != nil {
		err = msgp.WrapError(err, "ArmourMax")
		return
	}
	// write "ArmourMin"
	err = en.Append(0xa9, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ArmourMin)
	if err != nil {
		err = msgp.WrapError(err, "ArmourMin")
		return
	}
	// write "BaseItemTypesKey"
	err = en.Append(0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "EnergyShieldMax"
	err = en.Append(0xaf, 0x45, 0x6e, 0x65, 0x72, 0x67, 0x79, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.EnergyShieldMax)
	if err != nil {
		err = msgp.WrapError(err, "EnergyShieldMax")
		return
	}
	// write "EnergyShieldMin"
	err = en.Append(0xaf, 0x45, 0x6e, 0x65, 0x72, 0x67, 0x79, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.EnergyShieldMin)
	if err != nil {
		err = msgp.WrapError(err, "EnergyShieldMin")
		return
	}
	// write "EvasionMax"
	err = en.Append(0xaa, 0x45, 0x76, 0x61, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.EvasionMax)
	if err != nil {
		err = msgp.WrapError(err, "EvasionMax")
		return
	}
	// write "EvasionMin"
	err = en.Append(0xaa, 0x45, 0x76, 0x61, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.EvasionMin)
	if err != nil {
		err = msgp.WrapError(err, "EvasionMin")
		return
	}
	// write "IncreasedMovementSpeed"
	err = en.Append(0xb6, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65, 0x64, 0x4d, 0x6f, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x53, 0x70, 0x65, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.IncreasedMovementSpeed)
	if err != nil {
		err = msgp.WrapError(err, "IncreasedMovementSpeed")
		return
	}
	// write "WardMax"
	err = en.Append(0xa7, 0x57, 0x61, 0x72, 0x64, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.WardMax)
	if err != nil {
		err = msgp.WrapError(err, "WardMax")
		return
	}
	// write "WardMin"
	err = en.Append(0xa7, 0x57, 0x61, 0x72, 0x64, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.WardMin)
	if err != nil {
		err = msgp.WrapError(err, "WardMin")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ArmourType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "ArmourMax"
	o = append(o, 0x8b, 0xa9, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.ArmourMax)
	// string "ArmourMin"
	o = append(o, 0xa9, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.ArmourMin)
	// string "BaseItemTypesKey"
	o = append(o, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.BaseItemTypesKey)
	// string "EnergyShieldMax"
	o = append(o, 0xaf, 0x45, 0x6e, 0x65, 0x72, 0x67, 0x79, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.EnergyShieldMax)
	// string "EnergyShieldMin"
	o = append(o, 0xaf, 0x45, 0x6e, 0x65, 0x72, 0x67, 0x79, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.EnergyShieldMin)
	// string "EvasionMax"
	o = append(o, 0xaa, 0x45, 0x76, 0x61, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.EvasionMax)
	// string "EvasionMin"
	o = append(o, 0xaa, 0x45, 0x76, 0x61, 0x73, 0x69, 0x6f, 0x6e, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.EvasionMin)
	// string "IncreasedMovementSpeed"
	o = append(o, 0xb6, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x61, 0x73, 0x65, 0x64, 0x4d, 0x6f, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x53, 0x70, 0x65, 0x65, 0x64)
	o = msgp.AppendInt(o, z.IncreasedMovementSpeed)
	// string "WardMax"
	o = append(o, 0xa7, 0x57, 0x61, 0x72, 0x64, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.WardMax)
	// string "WardMin"
	o = append(o, 0xa7, 0x57, 0x61, 0x72, 0x64, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.WardMin)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ArmourType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ArmourMax":
			z.ArmourMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ArmourMax")
				return
			}
		case "ArmourMin":
			z.ArmourMin, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ArmourMin")
				return
			}
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "EnergyShieldMax":
			z.EnergyShieldMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EnergyShieldMax")
				return
			}
		case "EnergyShieldMin":
			z.EnergyShieldMin, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EnergyShieldMin")
				return
			}
		case "EvasionMax":
			z.EvasionMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EvasionMax")
				return
			}
		case "EvasionMin":
			z.EvasionMin, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EvasionMin")
				return
			}
		case "IncreasedMovementSpeed":
			z.IncreasedMovementSpeed, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncreasedMovementSpeed")
				return
			}
		case "WardMax":
			z.WardMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WardMax")
				return
			}
		case "WardMin":
			z.WardMin, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WardMin")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ArmourType) Msgsize() (s int) {
	s = 1 + 10 + msgp.IntSize + 10 + msgp.IntSize + 17 + msgp.IntSize + 16 + msgp.IntSize + 16 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 23 + msgp.IntSize + 8 + msgp.IntSize + 8 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *BaseItemType) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DropLevel":
			z.DropLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DropLevel")
				return
			}
		case "EquipAchievementItemsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "EquipAchievementItemsKey")
					return
				}
				z.EquipAchievementItemsKey = nil
			} else {
				if z.EquipAchievementItemsKey == nil {
					z.EquipAchievementItemsKey = new(int)
				}
				*z.EquipAchievementItemsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "EquipAchievementItemsKey")
					return
				}
			}
		case "FlavourTextKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "FlavourTextKey")
					return
				}
				z.FlavourTextKey = nil
			} else {
				if z.FlavourTextKey == nil {
					z.FlavourTextKey = new(int)
				}
				*z.FlavourTextKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "FlavourTextKey")
					return
				}
			}
		case "FragmentBaseItemTypesKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "FragmentBaseItemTypesKey")
					return
				}
				z.FragmentBaseItemTypesKey = nil
			} else {
				if z.FragmentBaseItemTypesKey == nil {
					z.FragmentBaseItemTypesKey = new(int)
				}
				*z.FragmentBaseItemTypesKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "FragmentBaseItemTypesKey")
					return
				}
			}
		case "Hash":
			z.Hash, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		case "Height":
			z.Height, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IdentifyMagicAchievementItems":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "IdentifyMagicAchievementItems")
				return
			}
			if cap(z.IdentifyMagicAchievementItems) >= int(zb0002) {
				z.IdentifyMagicAchievementItems = (z.IdentifyMagicAchievementItems)[:zb0002]
			} else {
				z.IdentifyMagicAchievementItems = make([]interface{}, zb0002)
			}
			for za0001 := range z.IdentifyMagicAchievementItems {
				z.IdentifyMagicAchievementItems[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "IdentifyMagicAchievementItems", za0001)
					return
				}
			}
		case "IdentifyAchievementItems":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "IdentifyAchievementItems")
				return
			}
			if cap(z.IdentifyAchievementItems) >= int(zb0003) {
				z.IdentifyAchievementItems = (z.IdentifyAchievementItems)[:zb0003]
			} else {
				z.IdentifyAchievementItems = make([]interface{}, zb0003)
			}
			for za0002 := range z.IdentifyAchievementItems {
				z.IdentifyAchievementItems[za0002], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "IdentifyAchievementItems", za0002)
					return
				}
			}
		case "ImplicitModsKeys":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ImplicitModsKeys")
				return
			}
			if cap(z.ImplicitModsKeys) >= int(zb0004) {
				z.ImplicitModsKeys = (z.ImplicitModsKeys)[:zb0004]
			} else {
				z.ImplicitModsKeys = make([]int, zb0004)
			}
			for za0003 := range z.ImplicitModsKeys {
				z.ImplicitModsKeys[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ImplicitModsKeys", za0003)
					return
				}
			}
		case "Inflection":
			z.Inflection, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Inflection")
				return
			}
		case "InheritsFrom":
			z.InheritsFrom, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "InheritsFrom")
				return
			}
		case "IsCorrupted":
			z.IsCorrupted, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsCorrupted")
				return
			}
		case "ItemClassesKey":
			z.ItemClassesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ItemClassesKey")
				return
			}
		case "ItemVisualIdentity":
			z.ItemVisualIdentity, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ItemVisualIdentity")
				return
			}
		case "ModDomain":
			z.ModDomain, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ModDomain")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SiteVisibility":
			z.SiteVisibility, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SiteVisibility")
				return
			}
		case "SizeOnGround":
			z.SizeOnGround, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SizeOnGround")
				return
			}
		case "SoundEffect":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SoundEffect")
					return
				}
				z.SoundEffect = nil
			} else {
				if z.SoundEffect == nil {
					z.SoundEffect = new(int)
				}
				*z.SoundEffect, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SoundEffect")
					return
				}
			}
		case "TagsKeys":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TagsKeys")
				return
			}
			if cap(z.TagsKeys) >= int(zb0005) {
				z.TagsKeys = (z.TagsKeys)[:zb0005]
			} else {
				z.TagsKeys = make([]int, zb0005)
			}
			for za0004 := range z.TagsKeys {
				z.TagsKeys[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TagsKeys", za0004)
					return
				}
			}
		case "VendorRecipeAchievementItems":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "VendorRecipeAchievementItems")
				return
			}
			if cap(z.VendorRecipeAchievementItems) >= int(zb0006) {
				z.VendorRecipeAchievementItems = (z.VendorRecipeAchievementItems)[:zb0006]
			} else {
				z.VendorRecipeAchievementItems = make([]int, zb0006)
			}
			for za0005 := range z.VendorRecipeAchievementItems {
				z.VendorRecipeAchievementItems[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "VendorRecipeAchievementItems", za0005)
					return
				}
			}
		case "Width":
			z.Width, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *BaseItemType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 24
	// write "DropLevel"
	err = en.Append(0xde, 0x0, 0x18, 0xa9, 0x44, 0x72, 0x6f, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DropLevel)
	if err != nil {
		err = msgp.WrapError(err, "DropLevel")
		return
	}
	// write "EquipAchievementItemsKey"
	err = en.Append(0xb8, 0x45, 0x71, 0x75, 0x69, 0x70, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.EquipAchievementItemsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.EquipAchievementItemsKey)
		if err != nil {
			err = msgp.WrapError(err, "EquipAchievementItemsKey")
			return
		}
	}
	// write "FlavourTextKey"
	err = en.Append(0xae, 0x46, 0x6c, 0x61, 0x76, 0x6f, 0x75, 0x72, 0x54, 0x65, 0x78, 0x74, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.FlavourTextKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.FlavourTextKey)
		if err != nil {
			err = msgp.WrapError(err, "FlavourTextKey")
			return
		}
	}
	// write "FragmentBaseItemTypesKey"
	err = en.Append(0xb8, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.FragmentBaseItemTypesKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.FragmentBaseItemTypesKey)
		if err != nil {
			err = msgp.WrapError(err, "FragmentBaseItemTypesKey")
			return
		}
	}
	// write "Hash"
	err = en.Append(0xa4, 0x48, 0x61, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	// write "Height"
	err = en.Append(0xa6, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Height)
	if err != nil {
		err = msgp.WrapError(err, "Height")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "IdentifyMagicAchievementItems"
	err = en.Append(0xbd, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x79, 0x4d, 0x61, 0x67, 0x69, 0x63, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.IdentifyMagicAchievementItems)))
	if err != nil {
		err = msgp.WrapError(err, "IdentifyMagicAchievementItems")
		return
	}
	for za0001 := range z.IdentifyMagicAchievementItems {
		err = en.WriteIntf(z.IdentifyMagicAchievementItems[za0001])
		if err != nil {
			err = msgp.WrapError(err, "IdentifyMagicAchievementItems", za0001)
			return
		}
	}
	// write "IdentifyAchievementItems"
	err = en.Append(0xb8, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x79, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.IdentifyAchievementItems)))
	if err != nil {
		err = msgp.WrapError(err, "IdentifyAchievementItems")
		return
	}
	for za0002 := range z.IdentifyAchievementItems {
		err = en.WriteIntf(z.IdentifyAchievementItems[za0002])
		if err != nil {
			err = msgp.WrapError(err, "IdentifyAchievementItems", za0002)
			return
		}
	}
	// write "ImplicitModsKeys"
	err = en.Append(0xb0, 0x49, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ImplicitModsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "ImplicitModsKeys")
		return
	}
	for za0003 := range z.ImplicitModsKeys {
		err = en.WriteInt(z.ImplicitModsKeys[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ImplicitModsKeys", za0003)
			return
		}
	}
	// write "Inflection"
	err = en.Append(0xaa, 0x49, 0x6e, 0x66, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Inflection)
	if err != nil {
		err = msgp.WrapError(err, "Inflection")
		return
	}
	// write "InheritsFrom"
	err = en.Append(0xac, 0x49, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x73, 0x46, 0x72, 0x6f, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteString(z.InheritsFrom)
	if err != nil {
		err = msgp.WrapError(err, "InheritsFrom")
		return
	}
	// write "IsCorrupted"
	err = en.Append(0xab, 0x49, 0x73, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsCorrupted)
	if err != nil {
		err = msgp.WrapError(err, "IsCorrupted")
		return
	}
	// write "ItemClassesKey"
	err = en.Append(0xae, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ItemClassesKey)
	if err != nil {
		err = msgp.WrapError(err, "ItemClassesKey")
		return
	}
	// write "ItemVisualIdentity"
	err = en.Append(0xb2, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ItemVisualIdentity)
	if err != nil {
		err = msgp.WrapError(err, "ItemVisualIdentity")
		return
	}
	// write "ModDomain"
	err = en.Append(0xa9, 0x4d, 0x6f, 0x64, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ModDomain)
	if err != nil {
		err = msgp.WrapError(err, "ModDomain")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "SiteVisibility"
	err = en.Append(0xae, 0x53, 0x69, 0x74, 0x65, 0x56, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SiteVisibility)
	if err != nil {
		err = msgp.WrapError(err, "SiteVisibility")
		return
	}
	// write "SizeOnGround"
	err = en.Append(0xac, 0x53, 0x69, 0x7a, 0x65, 0x4f, 0x6e, 0x47, 0x72, 0x6f, 0x75, 0x6e, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SizeOnGround)
	if err != nil {
		err = msgp.WrapError(err, "SizeOnGround")
		return
	}
	// write "SoundEffect"
	err = en.Append(0xab, 0x53, 0x6f, 0x75, 0x6e, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	if z.SoundEffect == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.SoundEffect)
		if err != nil {
			err = msgp.WrapError(err, "SoundEffect")
			return
		}
	}
	// write "TagsKeys"
	err = en.Append(0xa8, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TagsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "TagsKeys")
		return
	}
	for za0004 := range z.TagsKeys {
		err = en.WriteInt(z.TagsKeys[za0004])
		if err != nil {
			err = msgp.WrapError(err, "TagsKeys", za0004)
			return
		}
	}
	// write "VendorRecipeAchievementItems"
	err = en.Append(0xbc, 0x56, 0x65, 0x6e, 0x64, 0x6f, 0x72, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.VendorRecipeAchievementItems)))
	if err != nil {
		err = msgp.WrapError(err, "VendorRecipeAchievementItems")
		return
	}
	for za0005 := range z.VendorRecipeAchievementItems {
		err = en.WriteInt(z.VendorRecipeAchievementItems[za0005])
		if err != nil {
			err = msgp.WrapError(err, "VendorRecipeAchievementItems", za0005)
			return
		}
	}
	// write "Width"
	err = en.Append(0xa5, 0x57, 0x69, 0x64, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Width)
	if err != nil {
		err = msgp.WrapError(err, "Width")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *BaseItemType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 24
	// string "DropLevel"
	o = append(o, 0xde, 0x0, 0x18, 0xa9, 0x44, 0x72, 0x6f, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.DropLevel)
	// string "EquipAchievementItemsKey"
	o = append(o, 0xb8, 0x45, 0x71, 0x75, 0x69, 0x70, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if z.EquipAchievementItemsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.EquipAchievementItemsKey)
	}
	// string "FlavourTextKey"
	o = append(o, 0xae, 0x46, 0x6c, 0x61, 0x76, 0x6f, 0x75, 0x72, 0x54, 0x65, 0x78, 0x74, 0x4b, 0x65, 0x79)
	if z.FlavourTextKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.FlavourTextKey)
	}
	// string "FragmentBaseItemTypesKey"
	o = append(o, 0xb8, 0x46, 0x72, 0x61, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if z.FragmentBaseItemTypesKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.FragmentBaseItemTypesKey)
	}
	// string "Hash"
	o = append(o, 0xa4, 0x48, 0x61, 0x73, 0x68)
	o = msgp.AppendInt(o, z.Hash)
	// string "Height"
	o = append(o, 0xa6, 0x48, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.Height)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "IdentifyMagicAchievementItems"
	o = append(o, 0xbd, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x79, 0x4d, 0x61, 0x67, 0x69, 0x63, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.IdentifyMagicAchievementItems)))
	for za0001 := range z.IdentifyMagicAchievementItems {
		o, err = msgp.AppendIntf(o, z.IdentifyMagicAchievementItems[za0001])
		if err != nil {
			err = msgp.WrapError(err, "IdentifyMagicAchievementItems", za0001)
			return
		}
	}
	// string "IdentifyAchievementItems"
	o = append(o, 0xb8, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x66, 0x79, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.IdentifyAchievementItems)))
	for za0002 := range z.IdentifyAchievementItems {
		o, err = msgp.AppendIntf(o, z.IdentifyAchievementItems[za0002])
		if err != nil {
			err = msgp.WrapError(err, "IdentifyAchievementItems", za0002)
			return
		}
	}
	// string "ImplicitModsKeys"
	o = append(o, 0xb0, 0x49, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ImplicitModsKeys)))
	for za0003 := range z.ImplicitModsKeys {
		o = msgp.AppendInt(o, z.ImplicitModsKeys[za0003])
	}
	// string "Inflection"
	o = append(o, 0xaa, 0x49, 0x6e, 0x66, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Inflection)
	// string "InheritsFrom"
	o = append(o, 0xac, 0x49, 0x6e, 0x68, 0x65, 0x72, 0x69, 0x74, 0x73, 0x46, 0x72, 0x6f, 0x6d)
	o = msgp.AppendString(o, z.InheritsFrom)
	// string "IsCorrupted"
	o = append(o, 0xab, 0x49, 0x73, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.IsCorrupted)
	// string "ItemClassesKey"
	o = append(o, 0xae, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.ItemClassesKey)
	// string "ItemVisualIdentity"
	o = append(o, 0xb2, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.ItemVisualIdentity)
	// string "ModDomain"
	o = append(o, 0xa9, 0x4d, 0x6f, 0x64, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.ModDomain)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "SiteVisibility"
	o = append(o, 0xae, 0x53, 0x69, 0x74, 0x65, 0x56, 0x69, 0x73, 0x69, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.SiteVisibility)
	// string "SizeOnGround"
	o = append(o, 0xac, 0x53, 0x69, 0x7a, 0x65, 0x4f, 0x6e, 0x47, 0x72, 0x6f, 0x75, 0x6e, 0x64)
	o = msgp.AppendInt(o, z.SizeOnGround)
	// string "SoundEffect"
	o = append(o, 0xab, 0x53, 0x6f, 0x75, 0x6e, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if z.SoundEffect == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.SoundEffect)
	}
	// string "TagsKeys"
	o = append(o, 0xa8, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TagsKeys)))
	for za0004 := range z.TagsKeys {
		o = msgp.AppendInt(o, z.TagsKeys[za0004])
	}
	// string "VendorRecipeAchievementItems"
	o = append(o, 0xbc, 0x56, 0x65, 0x6e, 0x64, 0x6f, 0x72, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.VendorRecipeAchievementItems)))
	for za0005 := range z.VendorRecipeAchievementItems {
		o = msgp.AppendInt(o, z.VendorRecipeAchievementItems[za0005])
	}
	// string "Width"
	o = append(o, 0xa5, 0x57, 0x69, 0x64, 0x74, 0x68)
	o = msgp.AppendInt(o, z.Width)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *BaseItemType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DropLevel":
			z.DropLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DropLevel")
				return
			}
		case "EquipAchievementItemsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.EquipAchievementItemsKey = nil
			} else {
				if z.EquipAchievementItemsKey == nil {
					z.EquipAchievementItemsKey = new(int)
				}
				*z.EquipAchievementItemsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EquipAchievementItemsKey")
					return
				}
			}
		case "FlavourTextKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.FlavourTextKey = nil
			} else {
				if z.FlavourTextKey == nil {
					z.FlavourTextKey = new(int)
				}
				*z.FlavourTextKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FlavourTextKey")
					return
				}
			}
		case "FragmentBaseItemTypesKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.FragmentBaseItemTypesKey = nil
			} else {
				if z.FragmentBaseItemTypesKey == nil {
					z.FragmentBaseItemTypesKey = new(int)
				}
				*z.FragmentBaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FragmentBaseItemTypesKey")
					return
				}
			}
		case "Hash":
			z.Hash, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		case "Height":
			z.Height, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Height")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IdentifyMagicAchievementItems":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IdentifyMagicAchievementItems")
				return
			}
			if cap(z.IdentifyMagicAchievementItems) >= int(zb0002) {
				z.IdentifyMagicAchievementItems = (z.IdentifyMagicAchievementItems)[:zb0002]
			} else {
				z.IdentifyMagicAchievementItems = make([]interface{}, zb0002)
			}
			for za0001 := range z.IdentifyMagicAchievementItems {
				z.IdentifyMagicAchievementItems[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IdentifyMagicAchievementItems", za0001)
					return
				}
			}
		case "IdentifyAchievementItems":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IdentifyAchievementItems")
				return
			}
			if cap(z.IdentifyAchievementItems) >= int(zb0003) {
				z.IdentifyAchievementItems = (z.IdentifyAchievementItems)[:zb0003]
			} else {
				z.IdentifyAchievementItems = make([]interface{}, zb0003)
			}
			for za0002 := range z.IdentifyAchievementItems {
				z.IdentifyAchievementItems[za0002], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IdentifyAchievementItems", za0002)
					return
				}
			}
		case "ImplicitModsKeys":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImplicitModsKeys")
				return
			}
			if cap(z.ImplicitModsKeys) >= int(zb0004) {
				z.ImplicitModsKeys = (z.ImplicitModsKeys)[:zb0004]
			} else {
				z.ImplicitModsKeys = make([]int, zb0004)
			}
			for za0003 := range z.ImplicitModsKeys {
				z.ImplicitModsKeys[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ImplicitModsKeys", za0003)
					return
				}
			}
		case "Inflection":
			z.Inflection, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Inflection")
				return
			}
		case "InheritsFrom":
			z.InheritsFrom, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InheritsFrom")
				return
			}
		case "IsCorrupted":
			z.IsCorrupted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsCorrupted")
				return
			}
		case "ItemClassesKey":
			z.ItemClassesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemClassesKey")
				return
			}
		case "ItemVisualIdentity":
			z.ItemVisualIdentity, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemVisualIdentity")
				return
			}
		case "ModDomain":
			z.ModDomain, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModDomain")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SiteVisibility":
			z.SiteVisibility, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SiteVisibility")
				return
			}
		case "SizeOnGround":
			z.SizeOnGround, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SizeOnGround")
				return
			}
		case "SoundEffect":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SoundEffect = nil
			} else {
				if z.SoundEffect == nil {
					z.SoundEffect = new(int)
				}
				*z.SoundEffect, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SoundEffect")
					return
				}
			}
		case "TagsKeys":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TagsKeys")
				return
			}
			if cap(z.TagsKeys) >= int(zb0005) {
				z.TagsKeys = (z.TagsKeys)[:zb0005]
			} else {
				z.TagsKeys = make([]int, zb0005)
			}
			for za0004 := range z.TagsKeys {
				z.TagsKeys[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TagsKeys", za0004)
					return
				}
			}
		case "VendorRecipeAchievementItems":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VendorRecipeAchievementItems")
				return
			}
			if cap(z.VendorRecipeAchievementItems) >= int(zb0006) {
				z.VendorRecipeAchievementItems = (z.VendorRecipeAchievementItems)[:zb0006]
			} else {
				z.VendorRecipeAchievementItems = make([]int, zb0006)
			}
			for za0005 := range z.VendorRecipeAchievementItems {
				z.VendorRecipeAchievementItems[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VendorRecipeAchievementItems", za0005)
					return
				}
			}
		case "Width":
			z.Width, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Width")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *BaseItemType) Msgsize() (s int) {
	s = 3 + 10 + msgp.IntSize + 25
	if z.EquipAchievementItemsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15
	if z.FlavourTextKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 25
	if z.FragmentBaseItemTypesKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 5 + msgp.IntSize + 7 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.ID) + 30 + msgp.ArrayHeaderSize
	for za0001 := range z.IdentifyMagicAchievementItems {
		s += msgp.GuessSize(z.IdentifyMagicAchievementItems[za0001])
	}
	s += 25 + msgp.ArrayHeaderSize
	for za0002 := range z.IdentifyAchievementItems {
		s += msgp.GuessSize(z.IdentifyAchievementItems[za0002])
	}
	s += 17 + msgp.ArrayHeaderSize + (len(z.ImplicitModsKeys) * (msgp.IntSize)) + 11 + msgp.StringPrefixSize + len(z.Inflection) + 13 + msgp.StringPrefixSize + len(z.InheritsFrom) + 12 + msgp.BoolSize + 15 + msgp.IntSize + 19 + msgp.IntSize + 10 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 15 + msgp.IntSize + 13 + msgp.IntSize + 12
	if z.SoundEffect == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 9 + msgp.ArrayHeaderSize + (len(z.TagsKeys) * (msgp.IntSize)) + 29 + msgp.ArrayHeaderSize + (len(z.VendorRecipeAchievementItems) * (msgp.IntSize)) + 6 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ComponentAttributeRequirement) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "ReqDex":
			z.ReqDex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ReqDex")
				return
			}
		case "ReqInt":
			z.ReqInt, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ReqInt")
				return
			}
		case "ReqStr":
			z.ReqStr, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ReqStr")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ComponentAttributeRequirement) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "BaseItemTypesKey"
	err = en.Append(0x85, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "ReqDex"
	err = en.Append(0xa6, 0x52, 0x65, 0x71, 0x44, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ReqDex)
	if err != nil {
		err = msgp.WrapError(err, "ReqDex")
		return
	}
	// write "ReqInt"
	err = en.Append(0xa6, 0x52, 0x65, 0x71, 0x49, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ReqInt)
	if err != nil {
		err = msgp.WrapError(err, "ReqInt")
		return
	}
	// write "ReqStr"
	err = en.Append(0xa6, 0x52, 0x65, 0x71, 0x53, 0x74, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ReqStr)
	if err != nil {
		err = msgp.WrapError(err, "ReqStr")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ComponentAttributeRequirement) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "BaseItemTypesKey"
	o = append(o, 0x85, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.BaseItemTypesKey)
	// string "ReqDex"
	o = append(o, 0xa6, 0x52, 0x65, 0x71, 0x44, 0x65, 0x78)
	o = msgp.AppendInt(o, z.ReqDex)
	// string "ReqInt"
	o = append(o, 0xa6, 0x52, 0x65, 0x71, 0x49, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.ReqInt)
	// string "ReqStr"
	o = append(o, 0xa6, 0x52, 0x65, 0x71, 0x53, 0x74, 0x72)
	o = msgp.AppendInt(o, z.ReqStr)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ComponentAttributeRequirement) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "ReqDex":
			z.ReqDex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqDex")
				return
			}
		case "ReqInt":
			z.ReqInt, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqInt")
				return
			}
		case "ReqStr":
			z.ReqStr, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReqStr")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ComponentAttributeRequirement) Msgsize() (s int) {
	s = 1 + 17 + msgp.StringPrefixSize + len(z.BaseItemTypesKey) + 7 + msgp.IntSize + 7 + msgp.IntSize + 7 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ComponentCharge) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "MaxCharges":
			z.MaxCharges, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaxCharges")
				return
			}
		case "MaxCharges2":
			z.MaxCharges2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaxCharges2")
				return
			}
		case "PerCharge":
			z.PerCharge, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PerCharge")
				return
			}
		case "PerCharge2":
			z.PerCharge2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PerCharge2")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ComponentCharge) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "BaseItemTypesKey"
	err = en.Append(0x86, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteString(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "MaxCharges"
	err = en.Append(0xaa, 0x4d, 0x61, 0x78, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaxCharges)
	if err != nil {
		err = msgp.WrapError(err, "MaxCharges")
		return
	}
	// write "MaxCharges2"
	err = en.Append(0xab, 0x4d, 0x61, 0x78, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x73, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaxCharges2)
	if err != nil {
		err = msgp.WrapError(err, "MaxCharges2")
		return
	}
	// write "PerCharge"
	err = en.Append(0xa9, 0x50, 0x65, 0x72, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PerCharge)
	if err != nil {
		err = msgp.WrapError(err, "PerCharge")
		return
	}
	// write "PerCharge2"
	err = en.Append(0xaa, 0x50, 0x65, 0x72, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PerCharge2)
	if err != nil {
		err = msgp.WrapError(err, "PerCharge2")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ComponentCharge) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "BaseItemTypesKey"
	o = append(o, 0x86, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendString(o, z.BaseItemTypesKey)
	// string "MaxCharges"
	o = append(o, 0xaa, 0x4d, 0x61, 0x78, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x73)
	o = msgp.AppendInt(o, z.MaxCharges)
	// string "MaxCharges2"
	o = append(o, 0xab, 0x4d, 0x61, 0x78, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x73, 0x32)
	o = msgp.AppendInt(o, z.MaxCharges2)
	// string "PerCharge"
	o = append(o, 0xa9, 0x50, 0x65, 0x72, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65)
	o = msgp.AppendInt(o, z.PerCharge)
	// string "PerCharge2"
	o = append(o, 0xaa, 0x50, 0x65, 0x72, 0x43, 0x68, 0x61, 0x72, 0x67, 0x65, 0x32)
	o = msgp.AppendInt(o, z.PerCharge2)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ComponentCharge) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "MaxCharges":
			z.MaxCharges, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxCharges")
				return
			}
		case "MaxCharges2":
			z.MaxCharges2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxCharges2")
				return
			}
		case "PerCharge":
			z.PerCharge, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PerCharge")
				return
			}
		case "PerCharge2":
			z.PerCharge2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PerCharge2")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ComponentCharge) Msgsize() (s int) {
	s = 1 + 17 + msgp.StringPrefixSize + len(z.BaseItemTypesKey) + 11 + msgp.IntSize + 12 + msgp.IntSize + 10 + msgp.IntSize + 11 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Condition) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Min":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Min")
					return
				}
				z.Min = nil
			} else {
				if z.Min == nil {
					z.Min = new(int)
				}
				*z.Min, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Min")
					return
				}
			}
		case "Max":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Max")
					return
				}
				z.Max = nil
			} else {
				if z.Max == nil {
					z.Max = new(int)
				}
				*z.Max, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Max")
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Condition) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "Min"
	err = en.Append(0x82, 0xa3, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	if z.Min == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Min)
		if err != nil {
			err = msgp.WrapError(err, "Min")
			return
		}
	}
	// write "Max"
	err = en.Append(0xa3, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	if z.Max == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Max)
		if err != nil {
			err = msgp.WrapError(err, "Max")
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Condition) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "Min"
	o = append(o, 0x82, 0xa3, 0x4d, 0x69, 0x6e)
	if z.Min == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Min)
	}
	// string "Max"
	o = append(o, 0xa3, 0x4d, 0x61, 0x78)
	if z.Max == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Max)
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Condition) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Min":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Min = nil
			} else {
				if z.Min == nil {
					z.Min = new(int)
				}
				*z.Min, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Min")
					return
				}
			}
		case "Max":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Max = nil
			} else {
				if z.Max == nil {
					z.Max = new(int)
				}
				*z.Max, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Max")
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Condition) Msgsize() (s int) {
	s = 1 + 4
	if z.Min == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 4
	if z.Max == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CostType) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "FormatText":
			z.FormatText, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "FormatText")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "StatsKey":
			z.StatsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CostType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "FormatText"
	err = en.Append(0x84, 0xaa, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.FormatText)
	if err != nil {
		err = msgp.WrapError(err, "FormatText")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "StatsKey"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CostType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "FormatText"
	o = append(o, 0x84, 0xaa, 0x46, 0x6f, 0x72, 0x6d, 0x61, 0x74, 0x54, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.FormatText)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "StatsKey"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.StatsKey)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CostType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "FormatText":
			z.FormatText, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FormatText")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "StatsKey":
			z.StatsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CostType) Msgsize() (s int) {
	s = 1 + 11 + msgp.StringPrefixSize + len(z.FormatText) + 3 + msgp.StringPrefixSize + len(z.ID) + 9 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *CraftingBenchOption) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AddEnchantment":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AddEnchantment")
					return
				}
				z.AddEnchantment = nil
			} else {
				if z.AddEnchantment == nil {
					z.AddEnchantment = new(int)
				}
				*z.AddEnchantment, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AddEnchantment")
					return
				}
			}
		case "AddMod":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AddMod")
					return
				}
				z.AddMod = nil
			} else {
				if z.AddMod == nil {
					z.AddMod = new(int)
				}
				*z.AddMod, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AddMod")
					return
				}
			}
		case "CostBaseItemTypes":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CostBaseItemTypes")
				return
			}
			if cap(z.CostBaseItemTypes) >= int(zb0002) {
				z.CostBaseItemTypes = (z.CostBaseItemTypes)[:zb0002]
			} else {
				z.CostBaseItemTypes = make([]int, zb0002)
			}
			for za0001 := range z.CostBaseItemTypes {
				z.CostBaseItemTypes[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CostBaseItemTypes", za0001)
					return
				}
			}
		case "CostValues":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CostValues")
				return
			}
			if cap(z.CostValues) >= int(zb0003) {
				z.CostValues = (z.CostValues)[:zb0003]
			} else {
				z.CostValues = make([]int, zb0003)
			}
			for za0002 := range z.CostValues {
				z.CostValues[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CostValues", za0002)
					return
				}
			}
		case "CraftingBenchCustomAction":
			z.CraftingBenchCustomAction, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CraftingBenchCustomAction")
				return
			}
		case "CraftingItemClassCategories":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CraftingItemClassCategories")
				return
			}
			if cap(z.CraftingItemClassCategories) >= int(zb0004) {
				z.CraftingItemClassCategories = (z.CraftingItemClassCategories)[:zb0004]
			} else {
				z.CraftingItemClassCategories = make([]int, zb0004)
			}
			for za0003 := range z.CraftingItemClassCategories {
				z.CraftingItemClassCategories[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CraftingItemClassCategories", za0003)
					return
				}
			}
		case "Description":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "HideoutNPCSKey":
			z.HideoutNPCSKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HideoutNPCSKey")
				return
			}
		case "IsAreaOption":
			z.IsAreaOption, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsAreaOption")
				return
			}
		case "IsDisabled":
			z.IsDisabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsDisabled")
				return
			}
		case "ItemClasses":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ItemClasses")
				return
			}
			if cap(z.ItemClasses) >= int(zb0005) {
				z.ItemClasses = (z.ItemClasses)[:zb0005]
			} else {
				z.ItemClasses = make([]int, zb0005)
			}
			for za0004 := range z.ItemClasses {
				z.ItemClasses[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ItemClasses", za0004)
					return
				}
			}
		case "ItemQuantity":
			z.ItemQuantity, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ItemQuantity")
				return
			}
		case "Links":
			z.Links, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Links")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Order":
			z.Order, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Order")
				return
			}
		case "RecipeIDS":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "RecipeIDS")
				return
			}
			if cap(z.RecipeIDS) >= int(zb0006) {
				z.RecipeIDS = (z.RecipeIDS)[:zb0006]
			} else {
				z.RecipeIDS = make([]int, zb0006)
			}
			for za0005 := range z.RecipeIDS {
				z.RecipeIDS[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "RecipeIDS", za0005)
					return
				}
			}
		case "RequiredLevel":
			z.RequiredLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RequiredLevel")
				return
			}
		case "SocketColours":
			z.SocketColours, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SocketColours")
				return
			}
		case "Sockets":
			z.Sockets, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Sockets")
				return
			}
		case "SortCategory":
			z.SortCategory, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SortCategory")
				return
			}
		case "Tier":
			z.Tier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Tier")
				return
			}
		case "UnlockCategory":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "UnlockCategory")
					return
				}
				z.UnlockCategory = nil
			} else {
				if z.UnlockCategory == nil {
					z.UnlockCategory = new(int)
				}
				*z.UnlockCategory, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "UnlockCategory")
					return
				}
			}
		case "UnveilsRequired":
			z.UnveilsRequired, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "UnveilsRequired")
				return
			}
		case "UnveilsRequired2":
			z.UnveilsRequired2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "UnveilsRequired2")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *CraftingBenchOption) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 25
	// write "AddEnchantment"
	err = en.Append(0xde, 0x0, 0x19, 0xae, 0x41, 0x64, 0x64, 0x45, 0x6e, 0x63, 0x68, 0x61, 0x6e, 0x74, 0x6d, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	if z.AddEnchantment == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.AddEnchantment)
		if err != nil {
			err = msgp.WrapError(err, "AddEnchantment")
			return
		}
	}
	// write "AddMod"
	err = en.Append(0xa6, 0x41, 0x64, 0x64, 0x4d, 0x6f, 0x64)
	if err != nil {
		return
	}
	if z.AddMod == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.AddMod)
		if err != nil {
			err = msgp.WrapError(err, "AddMod")
			return
		}
	}
	// write "CostBaseItemTypes"
	err = en.Append(0xb1, 0x43, 0x6f, 0x73, 0x74, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CostBaseItemTypes)))
	if err != nil {
		err = msgp.WrapError(err, "CostBaseItemTypes")
		return
	}
	for za0001 := range z.CostBaseItemTypes {
		err = en.WriteInt(z.CostBaseItemTypes[za0001])
		if err != nil {
			err = msgp.WrapError(err, "CostBaseItemTypes", za0001)
			return
		}
	}
	// write "CostValues"
	err = en.Append(0xaa, 0x43, 0x6f, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CostValues)))
	if err != nil {
		err = msgp.WrapError(err, "CostValues")
		return
	}
	for za0002 := range z.CostValues {
		err = en.WriteInt(z.CostValues[za0002])
		if err != nil {
			err = msgp.WrapError(err, "CostValues", za0002)
			return
		}
	}
	// write "CraftingBenchCustomAction"
	err = en.Append(0xb9, 0x43, 0x72, 0x61, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x42, 0x65, 0x6e, 0x63, 0x68, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CraftingBenchCustomAction)
	if err != nil {
		err = msgp.WrapError(err, "CraftingBenchCustomAction")
		return
	}
	// write "CraftingItemClassCategories"
	err = en.Append(0xbb, 0x43, 0x72, 0x61, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CraftingItemClassCategories)))
	if err != nil {
		err = msgp.WrapError(err, "CraftingItemClassCategories")
		return
	}
	for za0003 := range z.CraftingItemClassCategories {
		err = en.WriteInt(z.CraftingItemClassCategories[za0003])
		if err != nil {
			err = msgp.WrapError(err, "CraftingItemClassCategories", za0003)
			return
		}
	}
	// write "Description"
	err = en.Append(0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "HideoutNPCSKey"
	err = en.Append(0xae, 0x48, 0x69, 0x64, 0x65, 0x6f, 0x75, 0x74, 0x4e, 0x50, 0x43, 0x53, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HideoutNPCSKey)
	if err != nil {
		err = msgp.WrapError(err, "HideoutNPCSKey")
		return
	}
	// write "IsAreaOption"
	err = en.Append(0xac, 0x49, 0x73, 0x41, 0x72, 0x65, 0x61, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsAreaOption)
	if err != nil {
		err = msgp.WrapError(err, "IsAreaOption")
		return
	}
	// write "IsDisabled"
	err = en.Append(0xaa, 0x49, 0x73, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsDisabled)
	if err != nil {
		err = msgp.WrapError(err, "IsDisabled")
		return
	}
	// write "ItemClasses"
	err = en.Append(0xab, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ItemClasses)))
	if err != nil {
		err = msgp.WrapError(err, "ItemClasses")
		return
	}
	for za0004 := range z.ItemClasses {
		err = en.WriteInt(z.ItemClasses[za0004])
		if err != nil {
			err = msgp.WrapError(err, "ItemClasses", za0004)
			return
		}
	}
	// write "ItemQuantity"
	err = en.Append(0xac, 0x49, 0x74, 0x65, 0x6d, 0x51, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ItemQuantity)
	if err != nil {
		err = msgp.WrapError(err, "ItemQuantity")
		return
	}
	// write "Links"
	err = en.Append(0xa5, 0x4c, 0x69, 0x6e, 0x6b, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Links)
	if err != nil {
		err = msgp.WrapError(err, "Links")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "Order"
	err = en.Append(0xa5, 0x4f, 0x72, 0x64, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Order)
	if err != nil {
		err = msgp.WrapError(err, "Order")
		return
	}
	// write "RecipeIDS"
	err = en.Append(0xa9, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x49, 0x44, 0x53)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.RecipeIDS)))
	if err != nil {
		err = msgp.WrapError(err, "RecipeIDS")
		return
	}
	for za0005 := range z.RecipeIDS {
		err = en.WriteInt(z.RecipeIDS[za0005])
		if err != nil {
			err = msgp.WrapError(err, "RecipeIDS", za0005)
			return
		}
	}
	// write "RequiredLevel"
	err = en.Append(0xad, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RequiredLevel)
	if err != nil {
		err = msgp.WrapError(err, "RequiredLevel")
		return
	}
	// write "SocketColours"
	err = en.Append(0xad, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteString(z.SocketColours)
	if err != nil {
		err = msgp.WrapError(err, "SocketColours")
		return
	}
	// write "Sockets"
	err = en.Append(0xa7, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Sockets)
	if err != nil {
		err = msgp.WrapError(err, "Sockets")
		return
	}
	// write "SortCategory"
	err = en.Append(0xac, 0x53, 0x6f, 0x72, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SortCategory)
	if err != nil {
		err = msgp.WrapError(err, "SortCategory")
		return
	}
	// write "Tier"
	err = en.Append(0xa4, 0x54, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Tier)
	if err != nil {
		err = msgp.WrapError(err, "Tier")
		return
	}
	// write "UnlockCategory"
	err = en.Append(0xae, 0x55, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	if err != nil {
		return
	}
	if z.UnlockCategory == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.UnlockCategory)
		if err != nil {
			err = msgp.WrapError(err, "UnlockCategory")
			return
		}
	}
	// write "UnveilsRequired"
	err = en.Append(0xaf, 0x55, 0x6e, 0x76, 0x65, 0x69, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.UnveilsRequired)
	if err != nil {
		err = msgp.WrapError(err, "UnveilsRequired")
		return
	}
	// write "UnveilsRequired2"
	err = en.Append(0xb0, 0x55, 0x6e, 0x76, 0x65, 0x69, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.UnveilsRequired2)
	if err != nil {
		err = msgp.WrapError(err, "UnveilsRequired2")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *CraftingBenchOption) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 25
	// string "AddEnchantment"
	o = append(o, 0xde, 0x0, 0x19, 0xae, 0x41, 0x64, 0x64, 0x45, 0x6e, 0x63, 0x68, 0x61, 0x6e, 0x74, 0x6d, 0x65, 0x6e, 0x74)
	if z.AddEnchantment == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.AddEnchantment)
	}
	// string "AddMod"
	o = append(o, 0xa6, 0x41, 0x64, 0x64, 0x4d, 0x6f, 0x64)
	if z.AddMod == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.AddMod)
	}
	// string "CostBaseItemTypes"
	o = append(o, 0xb1, 0x43, 0x6f, 0x73, 0x74, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CostBaseItemTypes)))
	for za0001 := range z.CostBaseItemTypes {
		o = msgp.AppendInt(o, z.CostBaseItemTypes[za0001])
	}
	// string "CostValues"
	o = append(o, 0xaa, 0x43, 0x6f, 0x73, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CostValues)))
	for za0002 := range z.CostValues {
		o = msgp.AppendInt(o, z.CostValues[za0002])
	}
	// string "CraftingBenchCustomAction"
	o = append(o, 0xb9, 0x43, 0x72, 0x61, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x42, 0x65, 0x6e, 0x63, 0x68, 0x43, 0x75, 0x73, 0x74, 0x6f, 0x6d, 0x41, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.CraftingBenchCustomAction)
	// string "CraftingItemClassCategories"
	o = append(o, 0xbb, 0x43, 0x72, 0x61, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x69, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CraftingItemClassCategories)))
	for za0003 := range z.CraftingItemClassCategories {
		o = msgp.AppendInt(o, z.CraftingItemClassCategories[za0003])
	}
	// string "Description"
	o = append(o, 0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "HideoutNPCSKey"
	o = append(o, 0xae, 0x48, 0x69, 0x64, 0x65, 0x6f, 0x75, 0x74, 0x4e, 0x50, 0x43, 0x53, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.HideoutNPCSKey)
	// string "IsAreaOption"
	o = append(o, 0xac, 0x49, 0x73, 0x41, 0x72, 0x65, 0x61, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendBool(o, z.IsAreaOption)
	// string "IsDisabled"
	o = append(o, 0xaa, 0x49, 0x73, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.IsDisabled)
	// string "ItemClasses"
	o = append(o, 0xab, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ItemClasses)))
	for za0004 := range z.ItemClasses {
		o = msgp.AppendInt(o, z.ItemClasses[za0004])
	}
	// string "ItemQuantity"
	o = append(o, 0xac, 0x49, 0x74, 0x65, 0x6d, 0x51, 0x75, 0x61, 0x6e, 0x74, 0x69, 0x74, 0x79)
	o = msgp.AppendInt(o, z.ItemQuantity)
	// string "Links"
	o = append(o, 0xa5, 0x4c, 0x69, 0x6e, 0x6b, 0x73)
	o = msgp.AppendInt(o, z.Links)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "Order"
	o = append(o, 0xa5, 0x4f, 0x72, 0x64, 0x65, 0x72)
	o = msgp.AppendInt(o, z.Order)
	// string "RecipeIDS"
	o = append(o, 0xa9, 0x52, 0x65, 0x63, 0x69, 0x70, 0x65, 0x49, 0x44, 0x53)
	o = msgp.AppendArrayHeader(o, uint32(len(z.RecipeIDS)))
	for za0005 := range z.RecipeIDS {
		o = msgp.AppendInt(o, z.RecipeIDS[za0005])
	}
	// string "RequiredLevel"
	o = append(o, 0xad, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.RequiredLevel)
	// string "SocketColours"
	o = append(o, 0xad, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x43, 0x6f, 0x6c, 0x6f, 0x75, 0x72, 0x73)
	o = msgp.AppendString(o, z.SocketColours)
	// string "Sockets"
	o = append(o, 0xa7, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x73)
	o = msgp.AppendInt(o, z.Sockets)
	// string "SortCategory"
	o = append(o, 0xac, 0x53, 0x6f, 0x72, 0x74, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	o = msgp.AppendInt(o, z.SortCategory)
	// string "Tier"
	o = append(o, 0xa4, 0x54, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.Tier)
	// string "UnlockCategory"
	o = append(o, 0xae, 0x55, 0x6e, 0x6c, 0x6f, 0x63, 0x6b, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	if z.UnlockCategory == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.UnlockCategory)
	}
	// string "UnveilsRequired"
	o = append(o, 0xaf, 0x55, 0x6e, 0x76, 0x65, 0x69, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64)
	o = msgp.AppendInt(o, z.UnveilsRequired)
	// string "UnveilsRequired2"
	o = append(o, 0xb0, 0x55, 0x6e, 0x76, 0x65, 0x69, 0x6c, 0x73, 0x52, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x64, 0x32)
	o = msgp.AppendInt(o, z.UnveilsRequired2)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *CraftingBenchOption) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AddEnchantment":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AddEnchantment = nil
			} else {
				if z.AddEnchantment == nil {
					z.AddEnchantment = new(int)
				}
				*z.AddEnchantment, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AddEnchantment")
					return
				}
			}
		case "AddMod":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AddMod = nil
			} else {
				if z.AddMod == nil {
					z.AddMod = new(int)
				}
				*z.AddMod, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AddMod")
					return
				}
			}
		case "CostBaseItemTypes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CostBaseItemTypes")
				return
			}
			if cap(z.CostBaseItemTypes) >= int(zb0002) {
				z.CostBaseItemTypes = (z.CostBaseItemTypes)[:zb0002]
			} else {
				z.CostBaseItemTypes = make([]int, zb0002)
			}
			for za0001 := range z.CostBaseItemTypes {
				z.CostBaseItemTypes[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CostBaseItemTypes", za0001)
					return
				}
			}
		case "CostValues":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CostValues")
				return
			}
			if cap(z.CostValues) >= int(zb0003) {
				z.CostValues = (z.CostValues)[:zb0003]
			} else {
				z.CostValues = make([]int, zb0003)
			}
			for za0002 := range z.CostValues {
				z.CostValues[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CostValues", za0002)
					return
				}
			}
		case "CraftingBenchCustomAction":
			z.CraftingBenchCustomAction, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CraftingBenchCustomAction")
				return
			}
		case "CraftingItemClassCategories":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CraftingItemClassCategories")
				return
			}
			if cap(z.CraftingItemClassCategories) >= int(zb0004) {
				z.CraftingItemClassCategories = (z.CraftingItemClassCategories)[:zb0004]
			} else {
				z.CraftingItemClassCategories = make([]int, zb0004)
			}
			for za0003 := range z.CraftingItemClassCategories {
				z.CraftingItemClassCategories[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CraftingItemClassCategories", za0003)
					return
				}
			}
		case "Description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "HideoutNPCSKey":
			z.HideoutNPCSKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HideoutNPCSKey")
				return
			}
		case "IsAreaOption":
			z.IsAreaOption, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsAreaOption")
				return
			}
		case "IsDisabled":
			z.IsDisabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsDisabled")
				return
			}
		case "ItemClasses":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemClasses")
				return
			}
			if cap(z.ItemClasses) >= int(zb0005) {
				z.ItemClasses = (z.ItemClasses)[:zb0005]
			} else {
				z.ItemClasses = make([]int, zb0005)
			}
			for za0004 := range z.ItemClasses {
				z.ItemClasses[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ItemClasses", za0004)
					return
				}
			}
		case "ItemQuantity":
			z.ItemQuantity, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemQuantity")
				return
			}
		case "Links":
			z.Links, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Links")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "Order":
			z.Order, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Order")
				return
			}
		case "RecipeIDS":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecipeIDS")
				return
			}
			if cap(z.RecipeIDS) >= int(zb0006) {
				z.RecipeIDS = (z.RecipeIDS)[:zb0006]
			} else {
				z.RecipeIDS = make([]int, zb0006)
			}
			for za0005 := range z.RecipeIDS {
				z.RecipeIDS[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RecipeIDS", za0005)
					return
				}
			}
		case "RequiredLevel":
			z.RequiredLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RequiredLevel")
				return
			}
		case "SocketColours":
			z.SocketColours, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SocketColours")
				return
			}
		case "Sockets":
			z.Sockets, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Sockets")
				return
			}
		case "SortCategory":
			z.SortCategory, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SortCategory")
				return
			}
		case "Tier":
			z.Tier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tier")
				return
			}
		case "UnlockCategory":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.UnlockCategory = nil
			} else {
				if z.UnlockCategory == nil {
					z.UnlockCategory = new(int)
				}
				*z.UnlockCategory, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "UnlockCategory")
					return
				}
			}
		case "UnveilsRequired":
			z.UnveilsRequired, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UnveilsRequired")
				return
			}
		case "UnveilsRequired2":
			z.UnveilsRequired2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "UnveilsRequired2")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *CraftingBenchOption) Msgsize() (s int) {
	s = 3 + 15
	if z.AddEnchantment == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 7
	if z.AddMod == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 18 + msgp.ArrayHeaderSize + (len(z.CostBaseItemTypes) * (msgp.IntSize)) + 11 + msgp.ArrayHeaderSize + (len(z.CostValues) * (msgp.IntSize)) + 26 + msgp.IntSize + 28 + msgp.ArrayHeaderSize + (len(z.CraftingItemClassCategories) * (msgp.IntSize)) + 12 + msgp.StringPrefixSize + len(z.Description) + 15 + msgp.IntSize + 13 + msgp.BoolSize + 11 + msgp.BoolSize + 12 + msgp.ArrayHeaderSize + (len(z.ItemClasses) * (msgp.IntSize)) + 13 + msgp.IntSize + 6 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 6 + msgp.IntSize + 10 + msgp.ArrayHeaderSize + (len(z.RecipeIDS) * (msgp.IntSize)) + 14 + msgp.IntSize + 14 + msgp.StringPrefixSize + len(z.SocketColours) + 8 + msgp.IntSize + 13 + msgp.IntSize + 5 + msgp.IntSize + 15
	if z.UnlockCategory == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 16 + msgp.IntSize + 17 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *DefaultMonsterStat) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Accuracy":
			z.Accuracy, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Accuracy")
				return
			}
		case "AllyLife":
			z.AllyLife, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AllyLife")
				return
			}
		case "Armour":
			z.Armour, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Armour")
				return
			}
		case "Damage":
			z.Damage, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Damage")
				return
			}
		case "Damage2":
			z.Damage2, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "Damage2")
				return
			}
		case "Difficulty":
			z.Difficulty, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Difficulty")
				return
			}
		case "DisplayLevel":
			z.DisplayLevel, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayLevel")
				return
			}
		case "Evasion":
			z.Evasion, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Evasion")
				return
			}
		case "Experience":
			z.Experience, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Experience")
				return
			}
		case "Life":
			z.Life, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Life")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *DefaultMonsterStat) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "Accuracy"
	err = en.Append(0x8b, 0xa8, 0x41, 0x63, 0x63, 0x75, 0x72, 0x61, 0x63, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Accuracy)
	if err != nil {
		err = msgp.WrapError(err, "Accuracy")
		return
	}
	// write "AllyLife"
	err = en.Append(0xa8, 0x41, 0x6c, 0x6c, 0x79, 0x4c, 0x69, 0x66, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AllyLife)
	if err != nil {
		err = msgp.WrapError(err, "AllyLife")
		return
	}
	// write "Armour"
	err = en.Append(0xa6, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Armour)
	if err != nil {
		err = msgp.WrapError(err, "Armour")
		return
	}
	// write "Damage"
	err = en.Append(0xa6, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Damage)
	if err != nil {
		err = msgp.WrapError(err, "Damage")
		return
	}
	// write "Damage2"
	err = en.Append(0xa7, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x32)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.Damage2)
	if err != nil {
		err = msgp.WrapError(err, "Damage2")
		return
	}
	// write "Difficulty"
	err = en.Append(0xaa, 0x44, 0x69, 0x66, 0x66, 0x69, 0x63, 0x75, 0x6c, 0x74, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Difficulty)
	if err != nil {
		err = msgp.WrapError(err, "Difficulty")
		return
	}
	// write "DisplayLevel"
	err = en.Append(0xac, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteString(z.DisplayLevel)
	if err != nil {
		err = msgp.WrapError(err, "DisplayLevel")
		return
	}
	// write "Evasion"
	err = en.Append(0xa7, 0x45, 0x76, 0x61, 0x73, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Evasion)
	if err != nil {
		err = msgp.WrapError(err, "Evasion")
		return
	}
	// write "Experience"
	err = en.Append(0xaa, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x65, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Experience)
	if err != nil {
		err = msgp.WrapError(err, "Experience")
		return
	}
	// write "Life"
	err = en.Append(0xa4, 0x4c, 0x69, 0x66, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Life)
	if err != nil {
		err = msgp.WrapError(err, "Life")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *DefaultMonsterStat) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "Accuracy"
	o = append(o, 0x8b, 0xa8, 0x41, 0x63, 0x63, 0x75, 0x72, 0x61, 0x63, 0x79)
	o = msgp.AppendInt(o, z.Accuracy)
	// string "AllyLife"
	o = append(o, 0xa8, 0x41, 0x6c, 0x6c, 0x79, 0x4c, 0x69, 0x66, 0x65)
	o = msgp.AppendInt(o, z.AllyLife)
	// string "Armour"
	o = append(o, 0xa6, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72)
	o = msgp.AppendInt(o, z.Armour)
	// string "Damage"
	o = append(o, 0xa6, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65)
	o = msgp.AppendFloat64(o, z.Damage)
	// string "Damage2"
	o = append(o, 0xa7, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x32)
	o = msgp.AppendFloat64(o, z.Damage2)
	// string "Difficulty"
	o = append(o, 0xaa, 0x44, 0x69, 0x66, 0x66, 0x69, 0x63, 0x75, 0x6c, 0x74, 0x79)
	o = msgp.AppendInt(o, z.Difficulty)
	// string "DisplayLevel"
	o = append(o, 0xac, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendString(o, z.DisplayLevel)
	// string "Evasion"
	o = append(o, 0xa7, 0x45, 0x76, 0x61, 0x73, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.Evasion)
	// string "Experience"
	o = append(o, 0xaa, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x65, 0x6e, 0x63, 0x65)
	o = msgp.AppendInt(o, z.Experience)
	// string "Life"
	o = append(o, 0xa4, 0x4c, 0x69, 0x66, 0x65)
	o = msgp.AppendInt(o, z.Life)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *DefaultMonsterStat) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Accuracy":
			z.Accuracy, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Accuracy")
				return
			}
		case "AllyLife":
			z.AllyLife, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllyLife")
				return
			}
		case "Armour":
			z.Armour, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Armour")
				return
			}
		case "Damage":
			z.Damage, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Damage")
				return
			}
		case "Damage2":
			z.Damage2, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Damage2")
				return
			}
		case "Difficulty":
			z.Difficulty, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Difficulty")
				return
			}
		case "DisplayLevel":
			z.DisplayLevel, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayLevel")
				return
			}
		case "Evasion":
			z.Evasion, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Evasion")
				return
			}
		case "Experience":
			z.Experience, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Experience")
				return
			}
		case "Life":
			z.Life, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Life")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *DefaultMonsterStat) Msgsize() (s int) {
	s = 1 + 9 + msgp.IntSize + 9 + msgp.IntSize + 7 + msgp.IntSize + 7 + msgp.Float64Size + 8 + msgp.Float64Size + 11 + msgp.IntSize + 13 + msgp.StringPrefixSize + len(z.DisplayLevel) + 8 + msgp.IntSize + 11 + msgp.IntSize + 5 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Essence) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AmuletModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AmuletModsKey")
					return
				}
				z.AmuletModsKey = nil
			} else {
				if z.AmuletModsKey == nil {
					z.AmuletModsKey = new(int)
				}
				*z.AmuletModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AmuletModsKey")
					return
				}
			}
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "BeltModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BeltModsKey")
					return
				}
				z.BeltModsKey = nil
			} else {
				if z.BeltModsKey == nil {
					z.BeltModsKey = new(int)
				}
				*z.BeltModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BeltModsKey")
					return
				}
			}
		case "BodyArmourModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BodyArmourModsKey")
					return
				}
				z.BodyArmourModsKey = nil
			} else {
				if z.BodyArmourModsKey == nil {
					z.BodyArmourModsKey = new(int)
				}
				*z.BodyArmourModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BodyArmourModsKey")
					return
				}
			}
		case "BootsModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BootsModsKey")
					return
				}
				z.BootsModsKey = nil
			} else {
				if z.BootsModsKey == nil {
					z.BootsModsKey = new(int)
				}
				*z.BootsModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BootsModsKey")
					return
				}
			}
		case "BowModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BowModsKey")
					return
				}
				z.BowModsKey = nil
			} else {
				if z.BowModsKey == nil {
					z.BowModsKey = new(int)
				}
				*z.BowModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BowModsKey")
					return
				}
			}
		case "ClawModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ClawModsKey")
					return
				}
				z.ClawModsKey = nil
			} else {
				if z.ClawModsKey == nil {
					z.ClawModsKey = new(int)
				}
				*z.ClawModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ClawModsKey")
					return
				}
			}
		case "DaggerModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DaggerModsKey")
					return
				}
				z.DaggerModsKey = nil
			} else {
				if z.DaggerModsKey == nil {
					z.DaggerModsKey = new(int)
				}
				*z.DaggerModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DaggerModsKey")
					return
				}
			}
		case "DisplayAmuletModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayAmuletModsKey")
					return
				}
				z.DisplayAmuletModsKey = nil
			} else {
				if z.DisplayAmuletModsKey == nil {
					z.DisplayAmuletModsKey = new(int)
				}
				*z.DisplayAmuletModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayAmuletModsKey")
					return
				}
			}
		case "DisplayArmourModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayArmourModsKey")
					return
				}
				z.DisplayArmourModsKey = nil
			} else {
				if z.DisplayArmourModsKey == nil {
					z.DisplayArmourModsKey = new(int)
				}
				*z.DisplayArmourModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayArmourModsKey")
					return
				}
			}
		case "DisplayBeltModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBeltModsKey")
					return
				}
				z.DisplayBeltModsKey = nil
			} else {
				if z.DisplayBeltModsKey == nil {
					z.DisplayBeltModsKey = new(int)
				}
				*z.DisplayBeltModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBeltModsKey")
					return
				}
			}
		case "DisplayBodyArmourModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBodyArmourModsKey")
					return
				}
				z.DisplayBodyArmourModsKey = nil
			} else {
				if z.DisplayBodyArmourModsKey == nil {
					z.DisplayBodyArmourModsKey = new(int)
				}
				*z.DisplayBodyArmourModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBodyArmourModsKey")
					return
				}
			}
		case "DisplayBootsModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBootsModsKey")
					return
				}
				z.DisplayBootsModsKey = nil
			} else {
				if z.DisplayBootsModsKey == nil {
					z.DisplayBootsModsKey = new(int)
				}
				*z.DisplayBootsModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBootsModsKey")
					return
				}
			}
		case "DisplayBowModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBowModsKey")
					return
				}
				z.DisplayBowModsKey = nil
			} else {
				if z.DisplayBowModsKey == nil {
					z.DisplayBowModsKey = new(int)
				}
				*z.DisplayBowModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayBowModsKey")
					return
				}
			}
		case "DisplayGlovesModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayGlovesModsKey")
					return
				}
				z.DisplayGlovesModsKey = nil
			} else {
				if z.DisplayGlovesModsKey == nil {
					z.DisplayGlovesModsKey = new(int)
				}
				*z.DisplayGlovesModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayGlovesModsKey")
					return
				}
			}
		case "DisplayHelmetModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayHelmetModsKey")
					return
				}
				z.DisplayHelmetModsKey = nil
			} else {
				if z.DisplayHelmetModsKey == nil {
					z.DisplayHelmetModsKey = new(int)
				}
				*z.DisplayHelmetModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayHelmetModsKey")
					return
				}
			}
		case "DisplayItemsModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayItemsModsKey")
					return
				}
				z.DisplayItemsModsKey = nil
			} else {
				if z.DisplayItemsModsKey == nil {
					z.DisplayItemsModsKey = new(int)
				}
				*z.DisplayItemsModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayItemsModsKey")
					return
				}
			}
		case "DisplayJewelleryModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayJewelleryModsKey")
					return
				}
				z.DisplayJewelleryModsKey = nil
			} else {
				if z.DisplayJewelleryModsKey == nil {
					z.DisplayJewelleryModsKey = new(int)
				}
				*z.DisplayJewelleryModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayJewelleryModsKey")
					return
				}
			}
		case "DisplayMeleeWeaponModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayMeleeWeaponModsKey")
					return
				}
				z.DisplayMeleeWeaponModsKey = nil
			} else {
				if z.DisplayMeleeWeaponModsKey == nil {
					z.DisplayMeleeWeaponModsKey = new(int)
				}
				*z.DisplayMeleeWeaponModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayMeleeWeaponModsKey")
					return
				}
			}
		case "DisplayMonsterModsKey":
			z.DisplayMonsterModsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DisplayMonsterModsKey")
				return
			}
		case "DisplayOneHandWeaponModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayOneHandWeaponModsKey")
					return
				}
				z.DisplayOneHandWeaponModsKey = nil
			} else {
				if z.DisplayOneHandWeaponModsKey == nil {
					z.DisplayOneHandWeaponModsKey = new(int)
				}
				*z.DisplayOneHandWeaponModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayOneHandWeaponModsKey")
					return
				}
			}
		case "DisplayQuiverModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayQuiverModsKey")
					return
				}
				z.DisplayQuiverModsKey = nil
			} else {
				if z.DisplayQuiverModsKey == nil {
					z.DisplayQuiverModsKey = new(int)
				}
				*z.DisplayQuiverModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayQuiverModsKey")
					return
				}
			}
		case "DisplayRangedWeaponModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayRangedWeaponModsKey")
					return
				}
				z.DisplayRangedWeaponModsKey = nil
			} else {
				if z.DisplayRangedWeaponModsKey == nil {
					z.DisplayRangedWeaponModsKey = new(int)
				}
				*z.DisplayRangedWeaponModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayRangedWeaponModsKey")
					return
				}
			}
		case "DisplayRingModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayRingModsKey")
					return
				}
				z.DisplayRingModsKey = nil
			} else {
				if z.DisplayRingModsKey == nil {
					z.DisplayRingModsKey = new(int)
				}
				*z.DisplayRingModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayRingModsKey")
					return
				}
			}
		case "DisplayShieldModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayShieldModsKey")
					return
				}
				z.DisplayShieldModsKey = nil
			} else {
				if z.DisplayShieldModsKey == nil {
					z.DisplayShieldModsKey = new(int)
				}
				*z.DisplayShieldModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayShieldModsKey")
					return
				}
			}
		case "DisplayTwoHandMeleeWeaponModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayTwoHandMeleeWeaponModsKey")
					return
				}
				z.DisplayTwoHandMeleeWeaponModsKey = nil
			} else {
				if z.DisplayTwoHandMeleeWeaponModsKey == nil {
					z.DisplayTwoHandMeleeWeaponModsKey = new(int)
				}
				*z.DisplayTwoHandMeleeWeaponModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayTwoHandMeleeWeaponModsKey")
					return
				}
			}
		case "DisplayTwoHandWeaponModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayTwoHandWeaponModsKey")
					return
				}
				z.DisplayTwoHandWeaponModsKey = nil
			} else {
				if z.DisplayTwoHandWeaponModsKey == nil {
					z.DisplayTwoHandWeaponModsKey = new(int)
				}
				*z.DisplayTwoHandWeaponModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayTwoHandWeaponModsKey")
					return
				}
			}
		case "DisplayWandModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayWandModsKey")
					return
				}
				z.DisplayWandModsKey = nil
			} else {
				if z.DisplayWandModsKey == nil {
					z.DisplayWandModsKey = new(int)
				}
				*z.DisplayWandModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayWandModsKey")
					return
				}
			}
		case "DisplayWeaponModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "DisplayWeaponModsKey")
					return
				}
				z.DisplayWeaponModsKey = nil
			} else {
				if z.DisplayWeaponModsKey == nil {
					z.DisplayWeaponModsKey = new(int)
				}
				*z.DisplayWeaponModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "DisplayWeaponModsKey")
					return
				}
			}
		case "DropLevelMaximum":
			z.DropLevelMaximum, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DropLevelMaximum")
				return
			}
		case "DropLevelMinimum":
			z.DropLevelMinimum, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DropLevelMinimum")
				return
			}
		case "EssenceTypeKey":
			z.EssenceTypeKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "EssenceTypeKey")
				return
			}
		case "GlovesModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "GlovesModsKey")
					return
				}
				z.GlovesModsKey = nil
			} else {
				if z.GlovesModsKey == nil {
					z.GlovesModsKey = new(int)
				}
				*z.GlovesModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GlovesModsKey")
					return
				}
			}
		case "HelmetModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HelmetModsKey")
					return
				}
				z.HelmetModsKey = nil
			} else {
				if z.HelmetModsKey == nil {
					z.HelmetModsKey = new(int)
				}
				*z.HelmetModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "HelmetModsKey")
					return
				}
			}
		case "IsScreamingEssence":
			z.IsScreamingEssence, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsScreamingEssence")
				return
			}
		case "ItemLevelRestriction":
			z.ItemLevelRestriction, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ItemLevelRestriction")
				return
			}
		case "Level":
			z.Level, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "MonsterModsKeys":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MonsterModsKeys")
				return
			}
			if cap(z.MonsterModsKeys) >= int(zb0002) {
				z.MonsterModsKeys = (z.MonsterModsKeys)[:zb0002]
			} else {
				z.MonsterModsKeys = make([]int, zb0002)
			}
			for za0001 := range z.MonsterModsKeys {
				z.MonsterModsKeys[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MonsterModsKeys", za0001)
					return
				}
			}
		case "OneHandAxeModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OneHandAxeModsKey")
					return
				}
				z.OneHandAxeModsKey = nil
			} else {
				if z.OneHandAxeModsKey == nil {
					z.OneHandAxeModsKey = new(int)
				}
				*z.OneHandAxeModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OneHandAxeModsKey")
					return
				}
			}
		case "OneHandMaceModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OneHandMaceModsKey")
					return
				}
				z.OneHandMaceModsKey = nil
			} else {
				if z.OneHandMaceModsKey == nil {
					z.OneHandMaceModsKey = new(int)
				}
				*z.OneHandMaceModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OneHandMaceModsKey")
					return
				}
			}
		case "OneHandSwordModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OneHandSwordModsKey")
					return
				}
				z.OneHandSwordModsKey = nil
			} else {
				if z.OneHandSwordModsKey == nil {
					z.OneHandSwordModsKey = new(int)
				}
				*z.OneHandSwordModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OneHandSwordModsKey")
					return
				}
			}
		case "OneHandThrustingSwordModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OneHandThrustingSwordModsKey")
					return
				}
				z.OneHandThrustingSwordModsKey = nil
			} else {
				if z.OneHandThrustingSwordModsKey == nil {
					z.OneHandThrustingSwordModsKey = new(int)
				}
				*z.OneHandThrustingSwordModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OneHandThrustingSwordModsKey")
					return
				}
			}
		case "RingModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RingModsKey")
					return
				}
				z.RingModsKey = nil
			} else {
				if z.RingModsKey == nil {
					z.RingModsKey = new(int)
				}
				*z.RingModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "RingModsKey")
					return
				}
			}
		case "SceptreModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SceptreModsKey")
					return
				}
				z.SceptreModsKey = nil
			} else {
				if z.SceptreModsKey == nil {
					z.SceptreModsKey = new(int)
				}
				*z.SceptreModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SceptreModsKey")
					return
				}
			}
		case "ShieldModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ShieldModsKey")
					return
				}
				z.ShieldModsKey = nil
			} else {
				if z.ShieldModsKey == nil {
					z.ShieldModsKey = new(int)
				}
				*z.ShieldModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ShieldModsKey")
					return
				}
			}
		case "StaffModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StaffModsKey")
					return
				}
				z.StaffModsKey = nil
			} else {
				if z.StaffModsKey == nil {
					z.StaffModsKey = new(int)
				}
				*z.StaffModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StaffModsKey")
					return
				}
			}
		case "TwoHandAxeModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TwoHandAxeModsKey")
					return
				}
				z.TwoHandAxeModsKey = nil
			} else {
				if z.TwoHandAxeModsKey == nil {
					z.TwoHandAxeModsKey = new(int)
				}
				*z.TwoHandAxeModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TwoHandAxeModsKey")
					return
				}
			}
		case "TwoHandMaceModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TwoHandMaceModsKey")
					return
				}
				z.TwoHandMaceModsKey = nil
			} else {
				if z.TwoHandMaceModsKey == nil {
					z.TwoHandMaceModsKey = new(int)
				}
				*z.TwoHandMaceModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TwoHandMaceModsKey")
					return
				}
			}
		case "TwoHandSwordModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "TwoHandSwordModsKey")
					return
				}
				z.TwoHandSwordModsKey = nil
			} else {
				if z.TwoHandSwordModsKey == nil {
					z.TwoHandSwordModsKey = new(int)
				}
				*z.TwoHandSwordModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TwoHandSwordModsKey")
					return
				}
			}
		case "WandModsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "WandModsKey")
					return
				}
				z.WandModsKey = nil
			} else {
				if z.WandModsKey == nil {
					z.WandModsKey = new(int)
				}
				*z.WandModsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "WandModsKey")
					return
				}
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Essence) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 51
	// write "AmuletModsKey"
	err = en.Append(0xde, 0x0, 0x33, 0xad, 0x41, 0x6d, 0x75, 0x6c, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.AmuletModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.AmuletModsKey)
		if err != nil {
			err = msgp.WrapError(err, "AmuletModsKey")
			return
		}
	}
	// write "BaseItemTypesKey"
	err = en.Append(0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "BeltModsKey"
	err = en.Append(0xab, 0x42, 0x65, 0x6c, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.BeltModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.BeltModsKey)
		if err != nil {
			err = msgp.WrapError(err, "BeltModsKey")
			return
		}
	}
	// write "BodyArmourModsKey"
	err = en.Append(0xb1, 0x42, 0x6f, 0x64, 0x79, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.BodyArmourModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.BodyArmourModsKey)
		if err != nil {
			err = msgp.WrapError(err, "BodyArmourModsKey")
			return
		}
	}
	// write "BootsModsKey"
	err = en.Append(0xac, 0x42, 0x6f, 0x6f, 0x74, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.BootsModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.BootsModsKey)
		if err != nil {
			err = msgp.WrapError(err, "BootsModsKey")
			return
		}
	}
	// write "BowModsKey"
	err = en.Append(0xaa, 0x42, 0x6f, 0x77, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.BowModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.BowModsKey)
		if err != nil {
			err = msgp.WrapError(err, "BowModsKey")
			return
		}
	}
	// write "ClawModsKey"
	err = en.Append(0xab, 0x43, 0x6c, 0x61, 0x77, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.ClawModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.ClawModsKey)
		if err != nil {
			err = msgp.WrapError(err, "ClawModsKey")
			return
		}
	}
	// write "DaggerModsKey"
	err = en.Append(0xad, 0x44, 0x61, 0x67, 0x67, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DaggerModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DaggerModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DaggerModsKey")
			return
		}
	}
	// write "DisplayAmuletModsKey"
	err = en.Append(0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x41, 0x6d, 0x75, 0x6c, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayAmuletModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayAmuletModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayAmuletModsKey")
			return
		}
	}
	// write "DisplayArmourModsKey"
	err = en.Append(0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayArmourModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayArmourModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayArmourModsKey")
			return
		}
	}
	// write "DisplayBeltModsKey"
	err = en.Append(0xb2, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x65, 0x6c, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayBeltModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayBeltModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayBeltModsKey")
			return
		}
	}
	// write "DisplayBodyArmourModsKey"
	err = en.Append(0xb8, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x6f, 0x64, 0x79, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayBodyArmourModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayBodyArmourModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayBodyArmourModsKey")
			return
		}
	}
	// write "DisplayBootsModsKey"
	err = en.Append(0xb3, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x6f, 0x6f, 0x74, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayBootsModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayBootsModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayBootsModsKey")
			return
		}
	}
	// write "DisplayBowModsKey"
	err = en.Append(0xb1, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x6f, 0x77, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayBowModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayBowModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayBowModsKey")
			return
		}
	}
	// write "DisplayGlovesModsKey"
	err = en.Append(0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x47, 0x6c, 0x6f, 0x76, 0x65, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayGlovesModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayGlovesModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayGlovesModsKey")
			return
		}
	}
	// write "DisplayHelmetModsKey"
	err = en.Append(0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x48, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayHelmetModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayHelmetModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayHelmetModsKey")
			return
		}
	}
	// write "DisplayItemsModsKey"
	err = en.Append(0xb3, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayItemsModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayItemsModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayItemsModsKey")
			return
		}
	}
	// write "DisplayJewelleryModsKey"
	err = en.Append(0xb7, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x6c, 0x65, 0x72, 0x79, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayJewelleryModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayJewelleryModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayJewelleryModsKey")
			return
		}
	}
	// write "DisplayMeleeWeaponModsKey"
	err = en.Append(0xb9, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4d, 0x65, 0x6c, 0x65, 0x65, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayMeleeWeaponModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayMeleeWeaponModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayMeleeWeaponModsKey")
			return
		}
	}
	// write "DisplayMonsterModsKey"
	err = en.Append(0xb5, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DisplayMonsterModsKey)
	if err != nil {
		err = msgp.WrapError(err, "DisplayMonsterModsKey")
		return
	}
	// write "DisplayOneHandWeaponModsKey"
	err = en.Append(0xbb, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayOneHandWeaponModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayOneHandWeaponModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayOneHandWeaponModsKey")
			return
		}
	}
	// write "DisplayQuiverModsKey"
	err = en.Append(0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x51, 0x75, 0x69, 0x76, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayQuiverModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayQuiverModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayQuiverModsKey")
			return
		}
	}
	// write "DisplayRangedWeaponModsKey"
	err = en.Append(0xba, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayRangedWeaponModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayRangedWeaponModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayRangedWeaponModsKey")
			return
		}
	}
	// write "DisplayRingModsKey"
	err = en.Append(0xb2, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x52, 0x69, 0x6e, 0x67, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayRingModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayRingModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayRingModsKey")
			return
		}
	}
	// write "DisplayShieldModsKey"
	err = en.Append(0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayShieldModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayShieldModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayShieldModsKey")
			return
		}
	}
	// write "DisplayTwoHandMeleeWeaponModsKey"
	err = en.Append(0xd9, 0x20, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x4d, 0x65, 0x6c, 0x65, 0x65, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayTwoHandMeleeWeaponModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayTwoHandMeleeWeaponModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayTwoHandMeleeWeaponModsKey")
			return
		}
	}
	// write "DisplayTwoHandWeaponModsKey"
	err = en.Append(0xbb, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayTwoHandWeaponModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayTwoHandWeaponModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayTwoHandWeaponModsKey")
			return
		}
	}
	// write "DisplayWandModsKey"
	err = en.Append(0xb2, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x57, 0x61, 0x6e, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayWandModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayWandModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayWandModsKey")
			return
		}
	}
	// write "DisplayWeaponModsKey"
	err = en.Append(0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.DisplayWeaponModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.DisplayWeaponModsKey)
		if err != nil {
			err = msgp.WrapError(err, "DisplayWeaponModsKey")
			return
		}
	}
	// write "DropLevelMaximum"
	err = en.Append(0xb0, 0x44, 0x72, 0x6f, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DropLevelMaximum)
	if err != nil {
		err = msgp.WrapError(err, "DropLevelMaximum")
		return
	}
	// write "DropLevelMinimum"
	err = en.Append(0xb0, 0x44, 0x72, 0x6f, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DropLevelMinimum)
	if err != nil {
		err = msgp.WrapError(err, "DropLevelMinimum")
		return
	}
	// write "EssenceTypeKey"
	err = en.Append(0xae, 0x45, 0x73, 0x73, 0x65, 0x6e, 0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.EssenceTypeKey)
	if err != nil {
		err = msgp.WrapError(err, "EssenceTypeKey")
		return
	}
	// write "GlovesModsKey"
	err = en.Append(0xad, 0x47, 0x6c, 0x6f, 0x76, 0x65, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.GlovesModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.GlovesModsKey)
		if err != nil {
			err = msgp.WrapError(err, "GlovesModsKey")
			return
		}
	}
	// write "HelmetModsKey"
	err = en.Append(0xad, 0x48, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.HelmetModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.HelmetModsKey)
		if err != nil {
			err = msgp.WrapError(err, "HelmetModsKey")
			return
		}
	}
	// write "IsScreamingEssence"
	err = en.Append(0xb2, 0x49, 0x73, 0x53, 0x63, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x45, 0x73, 0x73, 0x65, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsScreamingEssence)
	if err != nil {
		err = msgp.WrapError(err, "IsScreamingEssence")
		return
	}
	// write "ItemLevelRestriction"
	err = en.Append(0xb4, 0x49, 0x74, 0x65, 0x6d, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ItemLevelRestriction)
	if err != nil {
		err = msgp.WrapError(err, "ItemLevelRestriction")
		return
	}
	// write "Level"
	err = en.Append(0xa5, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Level)
	if err != nil {
		err = msgp.WrapError(err, "Level")
		return
	}
	// write "MonsterModsKeys"
	err = en.Append(0xaf, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MonsterModsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "MonsterModsKeys")
		return
	}
	for za0001 := range z.MonsterModsKeys {
		err = en.WriteInt(z.MonsterModsKeys[za0001])
		if err != nil {
			err = msgp.WrapError(err, "MonsterModsKeys", za0001)
			return
		}
	}
	// write "OneHandAxeModsKey"
	err = en.Append(0xb1, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x78, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.OneHandAxeModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.OneHandAxeModsKey)
		if err != nil {
			err = msgp.WrapError(err, "OneHandAxeModsKey")
			return
		}
	}
	// write "OneHandMaceModsKey"
	err = en.Append(0xb2, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x4d, 0x61, 0x63, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.OneHandMaceModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.OneHandMaceModsKey)
		if err != nil {
			err = msgp.WrapError(err, "OneHandMaceModsKey")
			return
		}
	}
	// write "OneHandSwordModsKey"
	err = en.Append(0xb3, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x53, 0x77, 0x6f, 0x72, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.OneHandSwordModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.OneHandSwordModsKey)
		if err != nil {
			err = msgp.WrapError(err, "OneHandSwordModsKey")
			return
		}
	}
	// write "OneHandThrustingSwordModsKey"
	err = en.Append(0xbc, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x54, 0x68, 0x72, 0x75, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x77, 0x6f, 0x72, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.OneHandThrustingSwordModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.OneHandThrustingSwordModsKey)
		if err != nil {
			err = msgp.WrapError(err, "OneHandThrustingSwordModsKey")
			return
		}
	}
	// write "RingModsKey"
	err = en.Append(0xab, 0x52, 0x69, 0x6e, 0x67, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.RingModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.RingModsKey)
		if err != nil {
			err = msgp.WrapError(err, "RingModsKey")
			return
		}
	}
	// write "SceptreModsKey"
	err = en.Append(0xae, 0x53, 0x63, 0x65, 0x70, 0x74, 0x72, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.SceptreModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.SceptreModsKey)
		if err != nil {
			err = msgp.WrapError(err, "SceptreModsKey")
			return
		}
	}
	// write "ShieldModsKey"
	err = en.Append(0xad, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.ShieldModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.ShieldModsKey)
		if err != nil {
			err = msgp.WrapError(err, "ShieldModsKey")
			return
		}
	}
	// write "StaffModsKey"
	err = en.Append(0xac, 0x53, 0x74, 0x61, 0x66, 0x66, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.StaffModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.StaffModsKey)
		if err != nil {
			err = msgp.WrapError(err, "StaffModsKey")
			return
		}
	}
	// write "TwoHandAxeModsKey"
	err = en.Append(0xb1, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x78, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.TwoHandAxeModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.TwoHandAxeModsKey)
		if err != nil {
			err = msgp.WrapError(err, "TwoHandAxeModsKey")
			return
		}
	}
	// write "TwoHandMaceModsKey"
	err = en.Append(0xb2, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x4d, 0x61, 0x63, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.TwoHandMaceModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.TwoHandMaceModsKey)
		if err != nil {
			err = msgp.WrapError(err, "TwoHandMaceModsKey")
			return
		}
	}
	// write "TwoHandSwordModsKey"
	err = en.Append(0xb3, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x53, 0x77, 0x6f, 0x72, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.TwoHandSwordModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.TwoHandSwordModsKey)
		if err != nil {
			err = msgp.WrapError(err, "TwoHandSwordModsKey")
			return
		}
	}
	// write "WandModsKey"
	err = en.Append(0xab, 0x57, 0x61, 0x6e, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.WandModsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.WandModsKey)
		if err != nil {
			err = msgp.WrapError(err, "WandModsKey")
			return
		}
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Essence) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 51
	// string "AmuletModsKey"
	o = append(o, 0xde, 0x0, 0x33, 0xad, 0x41, 0x6d, 0x75, 0x6c, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.AmuletModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.AmuletModsKey)
	}
	// string "BaseItemTypesKey"
	o = append(o, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.BaseItemTypesKey)
	// string "BeltModsKey"
	o = append(o, 0xab, 0x42, 0x65, 0x6c, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.BeltModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.BeltModsKey)
	}
	// string "BodyArmourModsKey"
	o = append(o, 0xb1, 0x42, 0x6f, 0x64, 0x79, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.BodyArmourModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.BodyArmourModsKey)
	}
	// string "BootsModsKey"
	o = append(o, 0xac, 0x42, 0x6f, 0x6f, 0x74, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.BootsModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.BootsModsKey)
	}
	// string "BowModsKey"
	o = append(o, 0xaa, 0x42, 0x6f, 0x77, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.BowModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.BowModsKey)
	}
	// string "ClawModsKey"
	o = append(o, 0xab, 0x43, 0x6c, 0x61, 0x77, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.ClawModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.ClawModsKey)
	}
	// string "DaggerModsKey"
	o = append(o, 0xad, 0x44, 0x61, 0x67, 0x67, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DaggerModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DaggerModsKey)
	}
	// string "DisplayAmuletModsKey"
	o = append(o, 0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x41, 0x6d, 0x75, 0x6c, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayAmuletModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayAmuletModsKey)
	}
	// string "DisplayArmourModsKey"
	o = append(o, 0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayArmourModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayArmourModsKey)
	}
	// string "DisplayBeltModsKey"
	o = append(o, 0xb2, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x65, 0x6c, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayBeltModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayBeltModsKey)
	}
	// string "DisplayBodyArmourModsKey"
	o = append(o, 0xb8, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x6f, 0x64, 0x79, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayBodyArmourModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayBodyArmourModsKey)
	}
	// string "DisplayBootsModsKey"
	o = append(o, 0xb3, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x6f, 0x6f, 0x74, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayBootsModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayBootsModsKey)
	}
	// string "DisplayBowModsKey"
	o = append(o, 0xb1, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x42, 0x6f, 0x77, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayBowModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayBowModsKey)
	}
	// string "DisplayGlovesModsKey"
	o = append(o, 0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x47, 0x6c, 0x6f, 0x76, 0x65, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayGlovesModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayGlovesModsKey)
	}
	// string "DisplayHelmetModsKey"
	o = append(o, 0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x48, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayHelmetModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayHelmetModsKey)
	}
	// string "DisplayItemsModsKey"
	o = append(o, 0xb3, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayItemsModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayItemsModsKey)
	}
	// string "DisplayJewelleryModsKey"
	o = append(o, 0xb7, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x6c, 0x65, 0x72, 0x79, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayJewelleryModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayJewelleryModsKey)
	}
	// string "DisplayMeleeWeaponModsKey"
	o = append(o, 0xb9, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4d, 0x65, 0x6c, 0x65, 0x65, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayMeleeWeaponModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayMeleeWeaponModsKey)
	}
	// string "DisplayMonsterModsKey"
	o = append(o, 0xb5, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.DisplayMonsterModsKey)
	// string "DisplayOneHandWeaponModsKey"
	o = append(o, 0xbb, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayOneHandWeaponModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayOneHandWeaponModsKey)
	}
	// string "DisplayQuiverModsKey"
	o = append(o, 0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x51, 0x75, 0x69, 0x76, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayQuiverModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayQuiverModsKey)
	}
	// string "DisplayRangedWeaponModsKey"
	o = append(o, 0xba, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x64, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayRangedWeaponModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayRangedWeaponModsKey)
	}
	// string "DisplayRingModsKey"
	o = append(o, 0xb2, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x52, 0x69, 0x6e, 0x67, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayRingModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayRingModsKey)
	}
	// string "DisplayShieldModsKey"
	o = append(o, 0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayShieldModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayShieldModsKey)
	}
	// string "DisplayTwoHandMeleeWeaponModsKey"
	o = append(o, 0xd9, 0x20, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x4d, 0x65, 0x6c, 0x65, 0x65, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayTwoHandMeleeWeaponModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayTwoHandMeleeWeaponModsKey)
	}
	// string "DisplayTwoHandWeaponModsKey"
	o = append(o, 0xbb, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayTwoHandWeaponModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayTwoHandWeaponModsKey)
	}
	// string "DisplayWandModsKey"
	o = append(o, 0xb2, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x57, 0x61, 0x6e, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayWandModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayWandModsKey)
	}
	// string "DisplayWeaponModsKey"
	o = append(o, 0xb4, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.DisplayWeaponModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.DisplayWeaponModsKey)
	}
	// string "DropLevelMaximum"
	o = append(o, 0xb0, 0x44, 0x72, 0x6f, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d)
	o = msgp.AppendInt(o, z.DropLevelMaximum)
	// string "DropLevelMinimum"
	o = append(o, 0xb0, 0x44, 0x72, 0x6f, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d)
	o = msgp.AppendInt(o, z.DropLevelMinimum)
	// string "EssenceTypeKey"
	o = append(o, 0xae, 0x45, 0x73, 0x73, 0x65, 0x6e, 0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.EssenceTypeKey)
	// string "GlovesModsKey"
	o = append(o, 0xad, 0x47, 0x6c, 0x6f, 0x76, 0x65, 0x73, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.GlovesModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.GlovesModsKey)
	}
	// string "HelmetModsKey"
	o = append(o, 0xad, 0x48, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.HelmetModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.HelmetModsKey)
	}
	// string "IsScreamingEssence"
	o = append(o, 0xb2, 0x49, 0x73, 0x53, 0x63, 0x72, 0x65, 0x61, 0x6d, 0x69, 0x6e, 0x67, 0x45, 0x73, 0x73, 0x65, 0x6e, 0x63, 0x65)
	o = msgp.AppendBool(o, z.IsScreamingEssence)
	// string "ItemLevelRestriction"
	o = append(o, 0xb4, 0x49, 0x74, 0x65, 0x6d, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.ItemLevelRestriction)
	// string "Level"
	o = append(o, 0xa5, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.Level)
	// string "MonsterModsKeys"
	o = append(o, 0xaf, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MonsterModsKeys)))
	for za0001 := range z.MonsterModsKeys {
		o = msgp.AppendInt(o, z.MonsterModsKeys[za0001])
	}
	// string "OneHandAxeModsKey"
	o = append(o, 0xb1, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x78, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.OneHandAxeModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.OneHandAxeModsKey)
	}
	// string "OneHandMaceModsKey"
	o = append(o, 0xb2, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x4d, 0x61, 0x63, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.OneHandMaceModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.OneHandMaceModsKey)
	}
	// string "OneHandSwordModsKey"
	o = append(o, 0xb3, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x53, 0x77, 0x6f, 0x72, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.OneHandSwordModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.OneHandSwordModsKey)
	}
	// string "OneHandThrustingSwordModsKey"
	o = append(o, 0xbc, 0x4f, 0x6e, 0x65, 0x48, 0x61, 0x6e, 0x64, 0x54, 0x68, 0x72, 0x75, 0x73, 0x74, 0x69, 0x6e, 0x67, 0x53, 0x77, 0x6f, 0x72, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.OneHandThrustingSwordModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.OneHandThrustingSwordModsKey)
	}
	// string "RingModsKey"
	o = append(o, 0xab, 0x52, 0x69, 0x6e, 0x67, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.RingModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.RingModsKey)
	}
	// string "SceptreModsKey"
	o = append(o, 0xae, 0x53, 0x63, 0x65, 0x70, 0x74, 0x72, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.SceptreModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.SceptreModsKey)
	}
	// string "ShieldModsKey"
	o = append(o, 0xad, 0x53, 0x68, 0x69, 0x65, 0x6c, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.ShieldModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.ShieldModsKey)
	}
	// string "StaffModsKey"
	o = append(o, 0xac, 0x53, 0x74, 0x61, 0x66, 0x66, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.StaffModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.StaffModsKey)
	}
	// string "TwoHandAxeModsKey"
	o = append(o, 0xb1, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x78, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.TwoHandAxeModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.TwoHandAxeModsKey)
	}
	// string "TwoHandMaceModsKey"
	o = append(o, 0xb2, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x4d, 0x61, 0x63, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.TwoHandMaceModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.TwoHandMaceModsKey)
	}
	// string "TwoHandSwordModsKey"
	o = append(o, 0xb3, 0x54, 0x77, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x53, 0x77, 0x6f, 0x72, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.TwoHandSwordModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.TwoHandSwordModsKey)
	}
	// string "WandModsKey"
	o = append(o, 0xab, 0x57, 0x61, 0x6e, 0x64, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79)
	if z.WandModsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.WandModsKey)
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Essence) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AmuletModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AmuletModsKey = nil
			} else {
				if z.AmuletModsKey == nil {
					z.AmuletModsKey = new(int)
				}
				*z.AmuletModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AmuletModsKey")
					return
				}
			}
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "BeltModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BeltModsKey = nil
			} else {
				if z.BeltModsKey == nil {
					z.BeltModsKey = new(int)
				}
				*z.BeltModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BeltModsKey")
					return
				}
			}
		case "BodyArmourModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BodyArmourModsKey = nil
			} else {
				if z.BodyArmourModsKey == nil {
					z.BodyArmourModsKey = new(int)
				}
				*z.BodyArmourModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BodyArmourModsKey")
					return
				}
			}
		case "BootsModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BootsModsKey = nil
			} else {
				if z.BootsModsKey == nil {
					z.BootsModsKey = new(int)
				}
				*z.BootsModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BootsModsKey")
					return
				}
			}
		case "BowModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BowModsKey = nil
			} else {
				if z.BowModsKey == nil {
					z.BowModsKey = new(int)
				}
				*z.BowModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BowModsKey")
					return
				}
			}
		case "ClawModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ClawModsKey = nil
			} else {
				if z.ClawModsKey == nil {
					z.ClawModsKey = new(int)
				}
				*z.ClawModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClawModsKey")
					return
				}
			}
		case "DaggerModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DaggerModsKey = nil
			} else {
				if z.DaggerModsKey == nil {
					z.DaggerModsKey = new(int)
				}
				*z.DaggerModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DaggerModsKey")
					return
				}
			}
		case "DisplayAmuletModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayAmuletModsKey = nil
			} else {
				if z.DisplayAmuletModsKey == nil {
					z.DisplayAmuletModsKey = new(int)
				}
				*z.DisplayAmuletModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayAmuletModsKey")
					return
				}
			}
		case "DisplayArmourModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayArmourModsKey = nil
			} else {
				if z.DisplayArmourModsKey == nil {
					z.DisplayArmourModsKey = new(int)
				}
				*z.DisplayArmourModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayArmourModsKey")
					return
				}
			}
		case "DisplayBeltModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayBeltModsKey = nil
			} else {
				if z.DisplayBeltModsKey == nil {
					z.DisplayBeltModsKey = new(int)
				}
				*z.DisplayBeltModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayBeltModsKey")
					return
				}
			}
		case "DisplayBodyArmourModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayBodyArmourModsKey = nil
			} else {
				if z.DisplayBodyArmourModsKey == nil {
					z.DisplayBodyArmourModsKey = new(int)
				}
				*z.DisplayBodyArmourModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayBodyArmourModsKey")
					return
				}
			}
		case "DisplayBootsModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayBootsModsKey = nil
			} else {
				if z.DisplayBootsModsKey == nil {
					z.DisplayBootsModsKey = new(int)
				}
				*z.DisplayBootsModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayBootsModsKey")
					return
				}
			}
		case "DisplayBowModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayBowModsKey = nil
			} else {
				if z.DisplayBowModsKey == nil {
					z.DisplayBowModsKey = new(int)
				}
				*z.DisplayBowModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayBowModsKey")
					return
				}
			}
		case "DisplayGlovesModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayGlovesModsKey = nil
			} else {
				if z.DisplayGlovesModsKey == nil {
					z.DisplayGlovesModsKey = new(int)
				}
				*z.DisplayGlovesModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayGlovesModsKey")
					return
				}
			}
		case "DisplayHelmetModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayHelmetModsKey = nil
			} else {
				if z.DisplayHelmetModsKey == nil {
					z.DisplayHelmetModsKey = new(int)
				}
				*z.DisplayHelmetModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayHelmetModsKey")
					return
				}
			}
		case "DisplayItemsModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayItemsModsKey = nil
			} else {
				if z.DisplayItemsModsKey == nil {
					z.DisplayItemsModsKey = new(int)
				}
				*z.DisplayItemsModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayItemsModsKey")
					return
				}
			}
		case "DisplayJewelleryModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayJewelleryModsKey = nil
			} else {
				if z.DisplayJewelleryModsKey == nil {
					z.DisplayJewelleryModsKey = new(int)
				}
				*z.DisplayJewelleryModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayJewelleryModsKey")
					return
				}
			}
		case "DisplayMeleeWeaponModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayMeleeWeaponModsKey = nil
			} else {
				if z.DisplayMeleeWeaponModsKey == nil {
					z.DisplayMeleeWeaponModsKey = new(int)
				}
				*z.DisplayMeleeWeaponModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayMeleeWeaponModsKey")
					return
				}
			}
		case "DisplayMonsterModsKey":
			z.DisplayMonsterModsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayMonsterModsKey")
				return
			}
		case "DisplayOneHandWeaponModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayOneHandWeaponModsKey = nil
			} else {
				if z.DisplayOneHandWeaponModsKey == nil {
					z.DisplayOneHandWeaponModsKey = new(int)
				}
				*z.DisplayOneHandWeaponModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayOneHandWeaponModsKey")
					return
				}
			}
		case "DisplayQuiverModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayQuiverModsKey = nil
			} else {
				if z.DisplayQuiverModsKey == nil {
					z.DisplayQuiverModsKey = new(int)
				}
				*z.DisplayQuiverModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayQuiverModsKey")
					return
				}
			}
		case "DisplayRangedWeaponModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayRangedWeaponModsKey = nil
			} else {
				if z.DisplayRangedWeaponModsKey == nil {
					z.DisplayRangedWeaponModsKey = new(int)
				}
				*z.DisplayRangedWeaponModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayRangedWeaponModsKey")
					return
				}
			}
		case "DisplayRingModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayRingModsKey = nil
			} else {
				if z.DisplayRingModsKey == nil {
					z.DisplayRingModsKey = new(int)
				}
				*z.DisplayRingModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayRingModsKey")
					return
				}
			}
		case "DisplayShieldModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayShieldModsKey = nil
			} else {
				if z.DisplayShieldModsKey == nil {
					z.DisplayShieldModsKey = new(int)
				}
				*z.DisplayShieldModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayShieldModsKey")
					return
				}
			}
		case "DisplayTwoHandMeleeWeaponModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayTwoHandMeleeWeaponModsKey = nil
			} else {
				if z.DisplayTwoHandMeleeWeaponModsKey == nil {
					z.DisplayTwoHandMeleeWeaponModsKey = new(int)
				}
				*z.DisplayTwoHandMeleeWeaponModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayTwoHandMeleeWeaponModsKey")
					return
				}
			}
		case "DisplayTwoHandWeaponModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayTwoHandWeaponModsKey = nil
			} else {
				if z.DisplayTwoHandWeaponModsKey == nil {
					z.DisplayTwoHandWeaponModsKey = new(int)
				}
				*z.DisplayTwoHandWeaponModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayTwoHandWeaponModsKey")
					return
				}
			}
		case "DisplayWandModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayWandModsKey = nil
			} else {
				if z.DisplayWandModsKey == nil {
					z.DisplayWandModsKey = new(int)
				}
				*z.DisplayWandModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayWandModsKey")
					return
				}
			}
		case "DisplayWeaponModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.DisplayWeaponModsKey = nil
			} else {
				if z.DisplayWeaponModsKey == nil {
					z.DisplayWeaponModsKey = new(int)
				}
				*z.DisplayWeaponModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "DisplayWeaponModsKey")
					return
				}
			}
		case "DropLevelMaximum":
			z.DropLevelMaximum, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DropLevelMaximum")
				return
			}
		case "DropLevelMinimum":
			z.DropLevelMinimum, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DropLevelMinimum")
				return
			}
		case "EssenceTypeKey":
			z.EssenceTypeKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EssenceTypeKey")
				return
			}
		case "GlovesModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.GlovesModsKey = nil
			} else {
				if z.GlovesModsKey == nil {
					z.GlovesModsKey = new(int)
				}
				*z.GlovesModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlovesModsKey")
					return
				}
			}
		case "HelmetModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HelmetModsKey = nil
			} else {
				if z.HelmetModsKey == nil {
					z.HelmetModsKey = new(int)
				}
				*z.HelmetModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HelmetModsKey")
					return
				}
			}
		case "IsScreamingEssence":
			z.IsScreamingEssence, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsScreamingEssence")
				return
			}
		case "ItemLevelRestriction":
			z.ItemLevelRestriction, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemLevelRestriction")
				return
			}
		case "Level":
			z.Level, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "MonsterModsKeys":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MonsterModsKeys")
				return
			}
			if cap(z.MonsterModsKeys) >= int(zb0002) {
				z.MonsterModsKeys = (z.MonsterModsKeys)[:zb0002]
			} else {
				z.MonsterModsKeys = make([]int, zb0002)
			}
			for za0001 := range z.MonsterModsKeys {
				z.MonsterModsKeys[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MonsterModsKeys", za0001)
					return
				}
			}
		case "OneHandAxeModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OneHandAxeModsKey = nil
			} else {
				if z.OneHandAxeModsKey == nil {
					z.OneHandAxeModsKey = new(int)
				}
				*z.OneHandAxeModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OneHandAxeModsKey")
					return
				}
			}
		case "OneHandMaceModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OneHandMaceModsKey = nil
			} else {
				if z.OneHandMaceModsKey == nil {
					z.OneHandMaceModsKey = new(int)
				}
				*z.OneHandMaceModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OneHandMaceModsKey")
					return
				}
			}
		case "OneHandSwordModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OneHandSwordModsKey = nil
			} else {
				if z.OneHandSwordModsKey == nil {
					z.OneHandSwordModsKey = new(int)
				}
				*z.OneHandSwordModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OneHandSwordModsKey")
					return
				}
			}
		case "OneHandThrustingSwordModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OneHandThrustingSwordModsKey = nil
			} else {
				if z.OneHandThrustingSwordModsKey == nil {
					z.OneHandThrustingSwordModsKey = new(int)
				}
				*z.OneHandThrustingSwordModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OneHandThrustingSwordModsKey")
					return
				}
			}
		case "RingModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RingModsKey = nil
			} else {
				if z.RingModsKey == nil {
					z.RingModsKey = new(int)
				}
				*z.RingModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RingModsKey")
					return
				}
			}
		case "SceptreModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SceptreModsKey = nil
			} else {
				if z.SceptreModsKey == nil {
					z.SceptreModsKey = new(int)
				}
				*z.SceptreModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SceptreModsKey")
					return
				}
			}
		case "ShieldModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ShieldModsKey = nil
			} else {
				if z.ShieldModsKey == nil {
					z.ShieldModsKey = new(int)
				}
				*z.ShieldModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ShieldModsKey")
					return
				}
			}
		case "StaffModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StaffModsKey = nil
			} else {
				if z.StaffModsKey == nil {
					z.StaffModsKey = new(int)
				}
				*z.StaffModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StaffModsKey")
					return
				}
			}
		case "TwoHandAxeModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TwoHandAxeModsKey = nil
			} else {
				if z.TwoHandAxeModsKey == nil {
					z.TwoHandAxeModsKey = new(int)
				}
				*z.TwoHandAxeModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TwoHandAxeModsKey")
					return
				}
			}
		case "TwoHandMaceModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TwoHandMaceModsKey = nil
			} else {
				if z.TwoHandMaceModsKey == nil {
					z.TwoHandMaceModsKey = new(int)
				}
				*z.TwoHandMaceModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TwoHandMaceModsKey")
					return
				}
			}
		case "TwoHandSwordModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.TwoHandSwordModsKey = nil
			} else {
				if z.TwoHandSwordModsKey == nil {
					z.TwoHandSwordModsKey = new(int)
				}
				*z.TwoHandSwordModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TwoHandSwordModsKey")
					return
				}
			}
		case "WandModsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.WandModsKey = nil
			} else {
				if z.WandModsKey == nil {
					z.WandModsKey = new(int)
				}
				*z.WandModsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WandModsKey")
					return
				}
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Essence) Msgsize() (s int) {
	s = 3 + 14
	if z.AmuletModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 17 + msgp.IntSize + 12
	if z.BeltModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 18
	if z.BodyArmourModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 13
	if z.BootsModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 11
	if z.BowModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 12
	if z.ClawModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 14
	if z.DaggerModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.DisplayAmuletModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.DisplayArmourModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19
	if z.DisplayBeltModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 25
	if z.DisplayBodyArmourModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 20
	if z.DisplayBootsModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 18
	if z.DisplayBowModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.DisplayGlovesModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.DisplayHelmetModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 20
	if z.DisplayItemsModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 24
	if z.DisplayJewelleryModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 26
	if z.DisplayMeleeWeaponModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 22 + msgp.IntSize + 28
	if z.DisplayOneHandWeaponModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.DisplayQuiverModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 27
	if z.DisplayRangedWeaponModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19
	if z.DisplayRingModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.DisplayShieldModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 34
	if z.DisplayTwoHandMeleeWeaponModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 28
	if z.DisplayTwoHandWeaponModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19
	if z.DisplayWandModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.DisplayWeaponModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 17 + msgp.IntSize + 17 + msgp.IntSize + 15 + msgp.IntSize + 14
	if z.GlovesModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 14
	if z.HelmetModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19 + msgp.BoolSize + 21 + msgp.IntSize + 6 + msgp.IntSize + 16 + msgp.ArrayHeaderSize + (len(z.MonsterModsKeys) * (msgp.IntSize)) + 18
	if z.OneHandAxeModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19
	if z.OneHandMaceModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 20
	if z.OneHandSwordModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 29
	if z.OneHandThrustingSwordModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 12
	if z.RingModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15
	if z.SceptreModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 14
	if z.ShieldModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 13
	if z.StaffModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 18
	if z.TwoHandAxeModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19
	if z.TwoHandMaceModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 20
	if z.TwoHandSwordModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 12
	if z.WandModsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Flask) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "BuffDefinitionsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BuffDefinitionsKey")
					return
				}
				z.BuffDefinitionsKey = nil
			} else {
				if z.BuffDefinitionsKey == nil {
					z.BuffDefinitionsKey = new(int)
				}
				*z.BuffDefinitionsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BuffDefinitionsKey")
					return
				}
			}
		case "BuffStatValues":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BuffStatValues")
				return
			}
			if cap(z.BuffStatValues) >= int(zb0002) {
				z.BuffStatValues = (z.BuffStatValues)[:zb0002]
			} else {
				z.BuffStatValues = make([]int, zb0002)
			}
			for za0001 := range z.BuffStatValues {
				z.BuffStatValues[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BuffStatValues", za0001)
					return
				}
			}
		case "BuffStatValues2":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BuffStatValues2")
				return
			}
			if cap(z.BuffStatValues2) >= int(zb0003) {
				z.BuffStatValues2 = (z.BuffStatValues2)[:zb0003]
			} else {
				z.BuffStatValues2 = make([]int, zb0003)
			}
			for za0002 := range z.BuffStatValues2 {
				z.BuffStatValues2[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BuffStatValues2", za0002)
					return
				}
			}
		case "Group":
			z.Group, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "LifePerUse":
			z.LifePerUse, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LifePerUse")
				return
			}
		case "ManaPerUse":
			z.ManaPerUse, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ManaPerUse")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "RecoveryTime":
			z.RecoveryTime, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RecoveryTime")
				return
			}
		case "RecoveryTime2":
			z.RecoveryTime2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RecoveryTime2")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Flask) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "BaseItemTypesKey"
	err = en.Append(0x8b, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "BuffDefinitionsKey"
	err = en.Append(0xb2, 0x42, 0x75, 0x66, 0x66, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.BuffDefinitionsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.BuffDefinitionsKey)
		if err != nil {
			err = msgp.WrapError(err, "BuffDefinitionsKey")
			return
		}
	}
	// write "BuffStatValues"
	err = en.Append(0xae, 0x42, 0x75, 0x66, 0x66, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BuffStatValues)))
	if err != nil {
		err = msgp.WrapError(err, "BuffStatValues")
		return
	}
	for za0001 := range z.BuffStatValues {
		err = en.WriteInt(z.BuffStatValues[za0001])
		if err != nil {
			err = msgp.WrapError(err, "BuffStatValues", za0001)
			return
		}
	}
	// write "BuffStatValues2"
	err = en.Append(0xaf, 0x42, 0x75, 0x66, 0x66, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BuffStatValues2)))
	if err != nil {
		err = msgp.WrapError(err, "BuffStatValues2")
		return
	}
	for za0002 := range z.BuffStatValues2 {
		err = en.WriteInt(z.BuffStatValues2[za0002])
		if err != nil {
			err = msgp.WrapError(err, "BuffStatValues2", za0002)
			return
		}
	}
	// write "Group"
	err = en.Append(0xa5, 0x47, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Group)
	if err != nil {
		err = msgp.WrapError(err, "Group")
		return
	}
	// write "LifePerUse"
	err = en.Append(0xaa, 0x4c, 0x69, 0x66, 0x65, 0x50, 0x65, 0x72, 0x55, 0x73, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.LifePerUse)
	if err != nil {
		err = msgp.WrapError(err, "LifePerUse")
		return
	}
	// write "ManaPerUse"
	err = en.Append(0xaa, 0x4d, 0x61, 0x6e, 0x61, 0x50, 0x65, 0x72, 0x55, 0x73, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ManaPerUse)
	if err != nil {
		err = msgp.WrapError(err, "ManaPerUse")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "RecoveryTime"
	err = en.Append(0xac, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RecoveryTime)
	if err != nil {
		err = msgp.WrapError(err, "RecoveryTime")
		return
	}
	// write "RecoveryTime2"
	err = en.Append(0xad, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RecoveryTime2)
	if err != nil {
		err = msgp.WrapError(err, "RecoveryTime2")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Flask) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "BaseItemTypesKey"
	o = append(o, 0x8b, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.BaseItemTypesKey)
	// string "BuffDefinitionsKey"
	o = append(o, 0xb2, 0x42, 0x75, 0x66, 0x66, 0x44, 0x65, 0x66, 0x69, 0x6e, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x4b, 0x65, 0x79)
	if z.BuffDefinitionsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.BuffDefinitionsKey)
	}
	// string "BuffStatValues"
	o = append(o, 0xae, 0x42, 0x75, 0x66, 0x66, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BuffStatValues)))
	for za0001 := range z.BuffStatValues {
		o = msgp.AppendInt(o, z.BuffStatValues[za0001])
	}
	// string "BuffStatValues2"
	o = append(o, 0xaf, 0x42, 0x75, 0x66, 0x66, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BuffStatValues2)))
	for za0002 := range z.BuffStatValues2 {
		o = msgp.AppendInt(o, z.BuffStatValues2[za0002])
	}
	// string "Group"
	o = append(o, 0xa5, 0x47, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendInt(o, z.Group)
	// string "LifePerUse"
	o = append(o, 0xaa, 0x4c, 0x69, 0x66, 0x65, 0x50, 0x65, 0x72, 0x55, 0x73, 0x65)
	o = msgp.AppendInt(o, z.LifePerUse)
	// string "ManaPerUse"
	o = append(o, 0xaa, 0x4d, 0x61, 0x6e, 0x61, 0x50, 0x65, 0x72, 0x55, 0x73, 0x65)
	o = msgp.AppendInt(o, z.ManaPerUse)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "RecoveryTime"
	o = append(o, 0xac, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.RecoveryTime)
	// string "RecoveryTime2"
	o = append(o, 0xad, 0x52, 0x65, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x54, 0x69, 0x6d, 0x65, 0x32)
	o = msgp.AppendInt(o, z.RecoveryTime2)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Flask) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "BuffDefinitionsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BuffDefinitionsKey = nil
			} else {
				if z.BuffDefinitionsKey == nil {
					z.BuffDefinitionsKey = new(int)
				}
				*z.BuffDefinitionsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BuffDefinitionsKey")
					return
				}
			}
		case "BuffStatValues":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuffStatValues")
				return
			}
			if cap(z.BuffStatValues) >= int(zb0002) {
				z.BuffStatValues = (z.BuffStatValues)[:zb0002]
			} else {
				z.BuffStatValues = make([]int, zb0002)
			}
			for za0001 := range z.BuffStatValues {
				z.BuffStatValues[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BuffStatValues", za0001)
					return
				}
			}
		case "BuffStatValues2":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BuffStatValues2")
				return
			}
			if cap(z.BuffStatValues2) >= int(zb0003) {
				z.BuffStatValues2 = (z.BuffStatValues2)[:zb0003]
			} else {
				z.BuffStatValues2 = make([]int, zb0003)
			}
			for za0002 := range z.BuffStatValues2 {
				z.BuffStatValues2[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BuffStatValues2", za0002)
					return
				}
			}
		case "Group":
			z.Group, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Group")
				return
			}
		case "LifePerUse":
			z.LifePerUse, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifePerUse")
				return
			}
		case "ManaPerUse":
			z.ManaPerUse, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManaPerUse")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "RecoveryTime":
			z.RecoveryTime, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecoveryTime")
				return
			}
		case "RecoveryTime2":
			z.RecoveryTime2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RecoveryTime2")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Flask) Msgsize() (s int) {
	s = 1 + 17 + msgp.IntSize + 19
	if z.BuffDefinitionsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15 + msgp.ArrayHeaderSize + (len(z.BuffStatValues) * (msgp.IntSize)) + 16 + msgp.ArrayHeaderSize + (len(z.BuffStatValues2) * (msgp.IntSize)) + 6 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 13 + msgp.IntSize + 14 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GrantedEffect) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IsSupport":
			z.IsSupport, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsSupport")
				return
			}
		case "SupportTypes":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SupportTypes")
				return
			}
			if cap(z.SupportTypes) >= int(zb0002) {
				z.SupportTypes = (z.SupportTypes)[:zb0002]
			} else {
				z.SupportTypes = make([]int, zb0002)
			}
			for za0001 := range z.SupportTypes {
				z.SupportTypes[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SupportTypes", za0001)
					return
				}
			}
		case "SupportGemLetter":
			z.SupportGemLetter, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SupportGemLetter")
				return
			}
		case "Attribute":
			z.Attribute, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Attribute")
				return
			}
		case "AddTypes":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AddTypes")
				return
			}
			if cap(z.AddTypes) >= int(zb0003) {
				z.AddTypes = (z.AddTypes)[:zb0003]
			} else {
				z.AddTypes = make([]int, zb0003)
			}
			for za0002 := range z.AddTypes {
				z.AddTypes[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AddTypes", za0002)
					return
				}
			}
		case "ExcludeTypes":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ExcludeTypes")
				return
			}
			if cap(z.ExcludeTypes) >= int(zb0004) {
				z.ExcludeTypes = (z.ExcludeTypes)[:zb0004]
			} else {
				z.ExcludeTypes = make([]int, zb0004)
			}
			for za0003 := range z.ExcludeTypes {
				z.ExcludeTypes[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ExcludeTypes", za0003)
					return
				}
			}
		case "SupportsGemsOnly":
			z.SupportsGemsOnly, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "SupportsGemsOnly")
				return
			}
		case "CannotBeSupported":
			z.CannotBeSupported, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CannotBeSupported")
				return
			}
		case "CastTime":
			z.CastTime, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CastTime")
				return
			}
		case "ActiveSkill":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ActiveSkill")
					return
				}
				z.ActiveSkill = nil
			} else {
				if z.ActiveSkill == nil {
					z.ActiveSkill = new(int)
				}
				*z.ActiveSkill, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ActiveSkill")
					return
				}
			}
		case "IgnoreMinionTypes":
			z.IgnoreMinionTypes, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IgnoreMinionTypes")
				return
			}
		case "AddMinionTypes":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AddMinionTypes")
				return
			}
			if cap(z.AddMinionTypes) >= int(zb0005) {
				z.AddMinionTypes = (z.AddMinionTypes)[:zb0005]
			} else {
				z.AddMinionTypes = make([]int, zb0005)
			}
			for za0004 := range z.AddMinionTypes {
				z.AddMinionTypes[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AddMinionTypes", za0004)
					return
				}
			}
		case "Animation":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Animation")
					return
				}
				z.Animation = nil
			} else {
				if z.Animation == nil {
					z.Animation = new(int)
				}
				*z.Animation, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Animation")
					return
				}
			}
		case "WeaponRestrictions":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "WeaponRestrictions")
				return
			}
			if cap(z.WeaponRestrictions) >= int(zb0006) {
				z.WeaponRestrictions = (z.WeaponRestrictions)[:zb0006]
			} else {
				z.WeaponRestrictions = make([]int, zb0006)
			}
			for za0005 := range z.WeaponRestrictions {
				z.WeaponRestrictions[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "WeaponRestrictions", za0005)
					return
				}
			}
		case "PlusVersionOf":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "PlusVersionOf")
					return
				}
				z.PlusVersionOf = nil
			} else {
				if z.PlusVersionOf == nil {
					z.PlusVersionOf = new(int)
				}
				*z.PlusVersionOf, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "PlusVersionOf")
					return
				}
			}
		case "GrantedEffectStatSets":
			z.GrantedEffectStatSets, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectStatSets")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GrantedEffect) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 18
	// write "ID"
	err = en.Append(0xde, 0x0, 0x12, 0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "IsSupport"
	err = en.Append(0xa9, 0x49, 0x73, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsSupport)
	if err != nil {
		err = msgp.WrapError(err, "IsSupport")
		return
	}
	// write "SupportTypes"
	err = en.Append(0xac, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SupportTypes)))
	if err != nil {
		err = msgp.WrapError(err, "SupportTypes")
		return
	}
	for za0001 := range z.SupportTypes {
		err = en.WriteInt(z.SupportTypes[za0001])
		if err != nil {
			err = msgp.WrapError(err, "SupportTypes", za0001)
			return
		}
	}
	// write "SupportGemLetter"
	err = en.Append(0xb0, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x47, 0x65, 0x6d, 0x4c, 0x65, 0x74, 0x74, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.SupportGemLetter)
	if err != nil {
		err = msgp.WrapError(err, "SupportGemLetter")
		return
	}
	// write "Attribute"
	err = en.Append(0xa9, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Attribute)
	if err != nil {
		err = msgp.WrapError(err, "Attribute")
		return
	}
	// write "AddTypes"
	err = en.Append(0xa8, 0x41, 0x64, 0x64, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AddTypes)))
	if err != nil {
		err = msgp.WrapError(err, "AddTypes")
		return
	}
	for za0002 := range z.AddTypes {
		err = en.WriteInt(z.AddTypes[za0002])
		if err != nil {
			err = msgp.WrapError(err, "AddTypes", za0002)
			return
		}
	}
	// write "ExcludeTypes"
	err = en.Append(0xac, 0x45, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ExcludeTypes)))
	if err != nil {
		err = msgp.WrapError(err, "ExcludeTypes")
		return
	}
	for za0003 := range z.ExcludeTypes {
		err = en.WriteInt(z.ExcludeTypes[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ExcludeTypes", za0003)
			return
		}
	}
	// write "SupportsGemsOnly"
	err = en.Append(0xb0, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x47, 0x65, 0x6d, 0x73, 0x4f, 0x6e, 0x6c, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBool(z.SupportsGemsOnly)
	if err != nil {
		err = msgp.WrapError(err, "SupportsGemsOnly")
		return
	}
	// write "CannotBeSupported"
	err = en.Append(0xb1, 0x43, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x42, 0x65, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CannotBeSupported)
	if err != nil {
		err = msgp.WrapError(err, "CannotBeSupported")
		return
	}
	// write "CastTime"
	err = en.Append(0xa8, 0x43, 0x61, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CastTime)
	if err != nil {
		err = msgp.WrapError(err, "CastTime")
		return
	}
	// write "ActiveSkill"
	err = en.Append(0xab, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c)
	if err != nil {
		return
	}
	if z.ActiveSkill == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.ActiveSkill)
		if err != nil {
			err = msgp.WrapError(err, "ActiveSkill")
			return
		}
	}
	// write "IgnoreMinionTypes"
	err = en.Append(0xb1, 0x49, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IgnoreMinionTypes)
	if err != nil {
		err = msgp.WrapError(err, "IgnoreMinionTypes")
		return
	}
	// write "AddMinionTypes"
	err = en.Append(0xae, 0x41, 0x64, 0x64, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AddMinionTypes)))
	if err != nil {
		err = msgp.WrapError(err, "AddMinionTypes")
		return
	}
	for za0004 := range z.AddMinionTypes {
		err = en.WriteInt(z.AddMinionTypes[za0004])
		if err != nil {
			err = msgp.WrapError(err, "AddMinionTypes", za0004)
			return
		}
	}
	// write "Animation"
	err = en.Append(0xa9, 0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	if z.Animation == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Animation)
		if err != nil {
			err = msgp.WrapError(err, "Animation")
			return
		}
	}
	// write "WeaponRestrictions"
	err = en.Append(0xb2, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.WeaponRestrictions)))
	if err != nil {
		err = msgp.WrapError(err, "WeaponRestrictions")
		return
	}
	for za0005 := range z.WeaponRestrictions {
		err = en.WriteInt(z.WeaponRestrictions[za0005])
		if err != nil {
			err = msgp.WrapError(err, "WeaponRestrictions", za0005)
			return
		}
	}
	// write "PlusVersionOf"
	err = en.Append(0xad, 0x50, 0x6c, 0x75, 0x73, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4f, 0x66)
	if err != nil {
		return
	}
	if z.PlusVersionOf == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.PlusVersionOf)
		if err != nil {
			err = msgp.WrapError(err, "PlusVersionOf")
			return
		}
	}
	// write "GrantedEffectStatSets"
	err = en.Append(0xb5, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x53, 0x74, 0x61, 0x74, 0x53, 0x65, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.GrantedEffectStatSets)
	if err != nil {
		err = msgp.WrapError(err, "GrantedEffectStatSets")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GrantedEffect) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 18
	// string "ID"
	o = append(o, 0xde, 0x0, 0x12, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "IsSupport"
	o = append(o, 0xa9, 0x49, 0x73, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74)
	o = msgp.AppendBool(o, z.IsSupport)
	// string "SupportTypes"
	o = append(o, 0xac, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SupportTypes)))
	for za0001 := range z.SupportTypes {
		o = msgp.AppendInt(o, z.SupportTypes[za0001])
	}
	// string "SupportGemLetter"
	o = append(o, 0xb0, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x47, 0x65, 0x6d, 0x4c, 0x65, 0x74, 0x74, 0x65, 0x72)
	o = msgp.AppendString(o, z.SupportGemLetter)
	// string "Attribute"
	o = append(o, 0xa9, 0x41, 0x74, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74, 0x65)
	o = msgp.AppendInt(o, z.Attribute)
	// string "AddTypes"
	o = append(o, 0xa8, 0x41, 0x64, 0x64, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AddTypes)))
	for za0002 := range z.AddTypes {
		o = msgp.AppendInt(o, z.AddTypes[za0002])
	}
	// string "ExcludeTypes"
	o = append(o, 0xac, 0x45, 0x78, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ExcludeTypes)))
	for za0003 := range z.ExcludeTypes {
		o = msgp.AppendInt(o, z.ExcludeTypes[za0003])
	}
	// string "SupportsGemsOnly"
	o = append(o, 0xb0, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x73, 0x47, 0x65, 0x6d, 0x73, 0x4f, 0x6e, 0x6c, 0x79)
	o = msgp.AppendBool(o, z.SupportsGemsOnly)
	// string "CannotBeSupported"
	o = append(o, 0xb1, 0x43, 0x61, 0x6e, 0x6e, 0x6f, 0x74, 0x42, 0x65, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.CannotBeSupported)
	// string "CastTime"
	o = append(o, 0xa8, 0x43, 0x61, 0x73, 0x74, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.CastTime)
	// string "ActiveSkill"
	o = append(o, 0xab, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c)
	if z.ActiveSkill == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.ActiveSkill)
	}
	// string "IgnoreMinionTypes"
	o = append(o, 0xb1, 0x49, 0x67, 0x6e, 0x6f, 0x72, 0x65, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendBool(o, z.IgnoreMinionTypes)
	// string "AddMinionTypes"
	o = append(o, 0xae, 0x41, 0x64, 0x64, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AddMinionTypes)))
	for za0004 := range z.AddMinionTypes {
		o = msgp.AppendInt(o, z.AddMinionTypes[za0004])
	}
	// string "Animation"
	o = append(o, 0xa9, 0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if z.Animation == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Animation)
	}
	// string "WeaponRestrictions"
	o = append(o, 0xb2, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.WeaponRestrictions)))
	for za0005 := range z.WeaponRestrictions {
		o = msgp.AppendInt(o, z.WeaponRestrictions[za0005])
	}
	// string "PlusVersionOf"
	o = append(o, 0xad, 0x50, 0x6c, 0x75, 0x73, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x4f, 0x66)
	if z.PlusVersionOf == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.PlusVersionOf)
	}
	// string "GrantedEffectStatSets"
	o = append(o, 0xb5, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x53, 0x74, 0x61, 0x74, 0x53, 0x65, 0x74, 0x73)
	o = msgp.AppendInt(o, z.GrantedEffectStatSets)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GrantedEffect) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IsSupport":
			z.IsSupport, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsSupport")
				return
			}
		case "SupportTypes":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SupportTypes")
				return
			}
			if cap(z.SupportTypes) >= int(zb0002) {
				z.SupportTypes = (z.SupportTypes)[:zb0002]
			} else {
				z.SupportTypes = make([]int, zb0002)
			}
			for za0001 := range z.SupportTypes {
				z.SupportTypes[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SupportTypes", za0001)
					return
				}
			}
		case "SupportGemLetter":
			z.SupportGemLetter, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SupportGemLetter")
				return
			}
		case "Attribute":
			z.Attribute, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Attribute")
				return
			}
		case "AddTypes":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AddTypes")
				return
			}
			if cap(z.AddTypes) >= int(zb0003) {
				z.AddTypes = (z.AddTypes)[:zb0003]
			} else {
				z.AddTypes = make([]int, zb0003)
			}
			for za0002 := range z.AddTypes {
				z.AddTypes[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AddTypes", za0002)
					return
				}
			}
		case "ExcludeTypes":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExcludeTypes")
				return
			}
			if cap(z.ExcludeTypes) >= int(zb0004) {
				z.ExcludeTypes = (z.ExcludeTypes)[:zb0004]
			} else {
				z.ExcludeTypes = make([]int, zb0004)
			}
			for za0003 := range z.ExcludeTypes {
				z.ExcludeTypes[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ExcludeTypes", za0003)
					return
				}
			}
		case "SupportsGemsOnly":
			z.SupportsGemsOnly, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SupportsGemsOnly")
				return
			}
		case "CannotBeSupported":
			z.CannotBeSupported, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CannotBeSupported")
				return
			}
		case "CastTime":
			z.CastTime, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CastTime")
				return
			}
		case "ActiveSkill":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ActiveSkill = nil
			} else {
				if z.ActiveSkill == nil {
					z.ActiveSkill = new(int)
				}
				*z.ActiveSkill, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ActiveSkill")
					return
				}
			}
		case "IgnoreMinionTypes":
			z.IgnoreMinionTypes, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IgnoreMinionTypes")
				return
			}
		case "AddMinionTypes":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AddMinionTypes")
				return
			}
			if cap(z.AddMinionTypes) >= int(zb0005) {
				z.AddMinionTypes = (z.AddMinionTypes)[:zb0005]
			} else {
				z.AddMinionTypes = make([]int, zb0005)
			}
			for za0004 := range z.AddMinionTypes {
				z.AddMinionTypes[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AddMinionTypes", za0004)
					return
				}
			}
		case "Animation":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Animation = nil
			} else {
				if z.Animation == nil {
					z.Animation = new(int)
				}
				*z.Animation, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Animation")
					return
				}
			}
		case "WeaponRestrictions":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "WeaponRestrictions")
				return
			}
			if cap(z.WeaponRestrictions) >= int(zb0006) {
				z.WeaponRestrictions = (z.WeaponRestrictions)[:zb0006]
			} else {
				z.WeaponRestrictions = make([]int, zb0006)
			}
			for za0005 := range z.WeaponRestrictions {
				z.WeaponRestrictions[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "WeaponRestrictions", za0005)
					return
				}
			}
		case "PlusVersionOf":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.PlusVersionOf = nil
			} else {
				if z.PlusVersionOf == nil {
					z.PlusVersionOf = new(int)
				}
				*z.PlusVersionOf, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "PlusVersionOf")
					return
				}
			}
		case "GrantedEffectStatSets":
			z.GrantedEffectStatSets, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectStatSets")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GrantedEffect) Msgsize() (s int) {
	s = 3 + 3 + msgp.StringPrefixSize + len(z.ID) + 10 + msgp.BoolSize + 13 + msgp.ArrayHeaderSize + (len(z.SupportTypes) * (msgp.IntSize)) + 17 + msgp.StringPrefixSize + len(z.SupportGemLetter) + 10 + msgp.IntSize + 9 + msgp.ArrayHeaderSize + (len(z.AddTypes) * (msgp.IntSize)) + 13 + msgp.ArrayHeaderSize + (len(z.ExcludeTypes) * (msgp.IntSize)) + 17 + msgp.BoolSize + 18 + msgp.BoolSize + 9 + msgp.IntSize + 12
	if z.ActiveSkill == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 18 + msgp.BoolSize + 15 + msgp.ArrayHeaderSize + (len(z.AddMinionTypes) * (msgp.IntSize)) + 10
	if z.Animation == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19 + msgp.ArrayHeaderSize + (len(z.WeaponRestrictions) * (msgp.IntSize)) + 14
	if z.PlusVersionOf == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 22 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GrantedEffectQualityStat) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "GrantedEffectsKey":
			z.GrantedEffectsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectsKey")
				return
			}
		case "SetID":
			z.SetID, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SetID")
				return
			}
		case "StatsKeys":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "StatsKeys")
				return
			}
			if cap(z.StatsKeys) >= int(zb0002) {
				z.StatsKeys = (z.StatsKeys)[:zb0002]
			} else {
				z.StatsKeys = make([]int, zb0002)
			}
			for za0001 := range z.StatsKeys {
				z.StatsKeys[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKeys", za0001)
					return
				}
			}
		case "StatsValuesPermille":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "StatsValuesPermille")
				return
			}
			if cap(z.StatsValuesPermille) >= int(zb0003) {
				z.StatsValuesPermille = (z.StatsValuesPermille)[:zb0003]
			} else {
				z.StatsValuesPermille = make([]int, zb0003)
			}
			for za0002 := range z.StatsValuesPermille {
				z.StatsValuesPermille[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsValuesPermille", za0002)
					return
				}
			}
		case "Weight":
			z.Weight, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Weight")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GrantedEffectQualityStat) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 6
	// write "GrantedEffectsKey"
	err = en.Append(0x86, 0xb1, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.GrantedEffectsKey)
	if err != nil {
		err = msgp.WrapError(err, "GrantedEffectsKey")
		return
	}
	// write "SetID"
	err = en.Append(0xa5, 0x53, 0x65, 0x74, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SetID)
	if err != nil {
		err = msgp.WrapError(err, "SetID")
		return
	}
	// write "StatsKeys"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.StatsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "StatsKeys")
		return
	}
	for za0001 := range z.StatsKeys {
		err = en.WriteInt(z.StatsKeys[za0001])
		if err != nil {
			err = msgp.WrapError(err, "StatsKeys", za0001)
			return
		}
	}
	// write "StatsValuesPermille"
	err = en.Append(0xb3, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x6c, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.StatsValuesPermille)))
	if err != nil {
		err = msgp.WrapError(err, "StatsValuesPermille")
		return
	}
	for za0002 := range z.StatsValuesPermille {
		err = en.WriteInt(z.StatsValuesPermille[za0002])
		if err != nil {
			err = msgp.WrapError(err, "StatsValuesPermille", za0002)
			return
		}
	}
	// write "Weight"
	err = en.Append(0xa6, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Weight)
	if err != nil {
		err = msgp.WrapError(err, "Weight")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GrantedEffectQualityStat) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 6
	// string "GrantedEffectsKey"
	o = append(o, 0x86, 0xb1, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.GrantedEffectsKey)
	// string "SetID"
	o = append(o, 0xa5, 0x53, 0x65, 0x74, 0x49, 0x44)
	o = msgp.AppendInt(o, z.SetID)
	// string "StatsKeys"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.StatsKeys)))
	for za0001 := range z.StatsKeys {
		o = msgp.AppendInt(o, z.StatsKeys[za0001])
	}
	// string "StatsValuesPermille"
	o = append(o, 0xb3, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73, 0x50, 0x65, 0x72, 0x6d, 0x69, 0x6c, 0x6c, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.StatsValuesPermille)))
	for za0002 := range z.StatsValuesPermille {
		o = msgp.AppendInt(o, z.StatsValuesPermille[za0002])
	}
	// string "Weight"
	o = append(o, 0xa6, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74)
	o = msgp.AppendInt(o, z.Weight)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GrantedEffectQualityStat) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "GrantedEffectsKey":
			z.GrantedEffectsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectsKey")
				return
			}
		case "SetID":
			z.SetID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SetID")
				return
			}
		case "StatsKeys":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKeys")
				return
			}
			if cap(z.StatsKeys) >= int(zb0002) {
				z.StatsKeys = (z.StatsKeys)[:zb0002]
			} else {
				z.StatsKeys = make([]int, zb0002)
			}
			for za0001 := range z.StatsKeys {
				z.StatsKeys[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKeys", za0001)
					return
				}
			}
		case "StatsValuesPermille":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsValuesPermille")
				return
			}
			if cap(z.StatsValuesPermille) >= int(zb0003) {
				z.StatsValuesPermille = (z.StatsValuesPermille)[:zb0003]
			} else {
				z.StatsValuesPermille = make([]int, zb0003)
			}
			for za0002 := range z.StatsValuesPermille {
				z.StatsValuesPermille[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsValuesPermille", za0002)
					return
				}
			}
		case "Weight":
			z.Weight, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Weight")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GrantedEffectQualityStat) Msgsize() (s int) {
	s = 1 + 18 + msgp.IntSize + 6 + msgp.IntSize + 10 + msgp.ArrayHeaderSize + (len(z.StatsKeys) * (msgp.IntSize)) + 20 + msgp.ArrayHeaderSize + (len(z.StatsValuesPermille) * (msgp.IntSize)) + 7 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GrantedEffectStatSet) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ImplicitStats":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ImplicitStats")
				return
			}
			if cap(z.ImplicitStats) >= int(zb0002) {
				z.ImplicitStats = (z.ImplicitStats)[:zb0002]
			} else {
				z.ImplicitStats = make([]int, zb0002)
			}
			for za0001 := range z.ImplicitStats {
				z.ImplicitStats[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ImplicitStats", za0001)
					return
				}
			}
		case "ConstantStats":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ConstantStats")
				return
			}
			if cap(z.ConstantStats) >= int(zb0003) {
				z.ConstantStats = (z.ConstantStats)[:zb0003]
			} else {
				z.ConstantStats = make([]int, zb0003)
			}
			for za0002 := range z.ConstantStats {
				z.ConstantStats[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ConstantStats", za0002)
					return
				}
			}
		case "ConstantStatsValues":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ConstantStatsValues")
				return
			}
			if cap(z.ConstantStatsValues) >= int(zb0004) {
				z.ConstantStatsValues = (z.ConstantStatsValues)[:zb0004]
			} else {
				z.ConstantStatsValues = make([]int, zb0004)
			}
			for za0003 := range z.ConstantStatsValues {
				z.ConstantStatsValues[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ConstantStatsValues", za0003)
					return
				}
			}
		case "BaseEffectiveness":
			z.BaseEffectiveness, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "BaseEffectiveness")
				return
			}
		case "IncrementalEffectiveness":
			z.IncrementalEffectiveness, err = dc.ReadFloat64()
			if err != nil {
				err = msgp.WrapError(err, "IncrementalEffectiveness")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GrantedEffectStatSet) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 7
	// write "Key"
	err = en.Append(0x87, 0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "ImplicitStats"
	err = en.Append(0xad, 0x49, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ImplicitStats)))
	if err != nil {
		err = msgp.WrapError(err, "ImplicitStats")
		return
	}
	for za0001 := range z.ImplicitStats {
		err = en.WriteInt(z.ImplicitStats[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ImplicitStats", za0001)
			return
		}
	}
	// write "ConstantStats"
	err = en.Append(0xad, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ConstantStats)))
	if err != nil {
		err = msgp.WrapError(err, "ConstantStats")
		return
	}
	for za0002 := range z.ConstantStats {
		err = en.WriteInt(z.ConstantStats[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ConstantStats", za0002)
			return
		}
	}
	// write "ConstantStatsValues"
	err = en.Append(0xb3, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ConstantStatsValues)))
	if err != nil {
		err = msgp.WrapError(err, "ConstantStatsValues")
		return
	}
	for za0003 := range z.ConstantStatsValues {
		err = en.WriteInt(z.ConstantStatsValues[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ConstantStatsValues", za0003)
			return
		}
	}
	// write "BaseEffectiveness"
	err = en.Append(0xb1, 0x42, 0x61, 0x73, 0x65, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.BaseEffectiveness)
	if err != nil {
		err = msgp.WrapError(err, "BaseEffectiveness")
		return
	}
	// write "IncrementalEffectiveness"
	err = en.Append(0xb8, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteFloat64(z.IncrementalEffectiveness)
	if err != nil {
		err = msgp.WrapError(err, "IncrementalEffectiveness")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GrantedEffectStatSet) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 7
	// string "Key"
	o = append(o, 0x87, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "ImplicitStats"
	o = append(o, 0xad, 0x49, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ImplicitStats)))
	for za0001 := range z.ImplicitStats {
		o = msgp.AppendInt(o, z.ImplicitStats[za0001])
	}
	// string "ConstantStats"
	o = append(o, 0xad, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ConstantStats)))
	for za0002 := range z.ConstantStats {
		o = msgp.AppendInt(o, z.ConstantStats[za0002])
	}
	// string "ConstantStatsValues"
	o = append(o, 0xb3, 0x43, 0x6f, 0x6e, 0x73, 0x74, 0x61, 0x6e, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ConstantStatsValues)))
	for za0003 := range z.ConstantStatsValues {
		o = msgp.AppendInt(o, z.ConstantStatsValues[za0003])
	}
	// string "BaseEffectiveness"
	o = append(o, 0xb1, 0x42, 0x61, 0x73, 0x65, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
	o = msgp.AppendFloat64(o, z.BaseEffectiveness)
	// string "IncrementalEffectiveness"
	o = append(o, 0xb8, 0x49, 0x6e, 0x63, 0x72, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x61, 0x6c, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
	o = msgp.AppendFloat64(o, z.IncrementalEffectiveness)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GrantedEffectStatSet) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ImplicitStats":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImplicitStats")
				return
			}
			if cap(z.ImplicitStats) >= int(zb0002) {
				z.ImplicitStats = (z.ImplicitStats)[:zb0002]
			} else {
				z.ImplicitStats = make([]int, zb0002)
			}
			for za0001 := range z.ImplicitStats {
				z.ImplicitStats[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ImplicitStats", za0001)
					return
				}
			}
		case "ConstantStats":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConstantStats")
				return
			}
			if cap(z.ConstantStats) >= int(zb0003) {
				z.ConstantStats = (z.ConstantStats)[:zb0003]
			} else {
				z.ConstantStats = make([]int, zb0003)
			}
			for za0002 := range z.ConstantStats {
				z.ConstantStats[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConstantStats", za0002)
					return
				}
			}
		case "ConstantStatsValues":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ConstantStatsValues")
				return
			}
			if cap(z.ConstantStatsValues) >= int(zb0004) {
				z.ConstantStatsValues = (z.ConstantStatsValues)[:zb0004]
			} else {
				z.ConstantStatsValues = make([]int, zb0004)
			}
			for za0003 := range z.ConstantStatsValues {
				z.ConstantStatsValues[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ConstantStatsValues", za0003)
					return
				}
			}
		case "BaseEffectiveness":
			z.BaseEffectiveness, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseEffectiveness")
				return
			}
		case "IncrementalEffectiveness":
			z.IncrementalEffectiveness, bts, err = msgp.ReadFloat64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IncrementalEffectiveness")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GrantedEffectStatSet) Msgsize() (s int) {
	s = 1 + 4 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.ID) + 14 + msgp.ArrayHeaderSize + (len(z.ImplicitStats) * (msgp.IntSize)) + 14 + msgp.ArrayHeaderSize + (len(z.ConstantStats) * (msgp.IntSize)) + 20 + msgp.ArrayHeaderSize + (len(z.ConstantStatsValues) * (msgp.IntSize)) + 18 + msgp.Float64Size + 25 + msgp.Float64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GrantedEffectStatSetsPerLevel) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AdditionalBooleanStats":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AdditionalBooleanStats")
				return
			}
			if cap(z.AdditionalBooleanStats) >= int(zb0002) {
				z.AdditionalBooleanStats = (z.AdditionalBooleanStats)[:zb0002]
			} else {
				z.AdditionalBooleanStats = make([]int, zb0002)
			}
			for za0001 := range z.AdditionalBooleanStats {
				z.AdditionalBooleanStats[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AdditionalBooleanStats", za0001)
					return
				}
			}
		case "AdditionalStats":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AdditionalStats")
				return
			}
			if cap(z.AdditionalStats) >= int(zb0003) {
				z.AdditionalStats = (z.AdditionalStats)[:zb0003]
			} else {
				z.AdditionalStats = make([]int, zb0003)
			}
			for za0002 := range z.AdditionalStats {
				z.AdditionalStats[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AdditionalStats", za0002)
					return
				}
			}
		case "AdditionalStatsValues":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AdditionalStatsValues")
				return
			}
			if cap(z.AdditionalStatsValues) >= int(zb0004) {
				z.AdditionalStatsValues = (z.AdditionalStatsValues)[:zb0004]
			} else {
				z.AdditionalStatsValues = make([]int, zb0004)
			}
			for za0003 := range z.AdditionalStatsValues {
				z.AdditionalStatsValues[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AdditionalStatsValues", za0003)
					return
				}
			}
		case "AttackCritChance":
			z.AttackCritChance, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AttackCritChance")
				return
			}
		case "BaseMultiplier":
			z.BaseMultiplier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseMultiplier")
				return
			}
		case "BaseResolvedValues":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BaseResolvedValues")
				return
			}
			if cap(z.BaseResolvedValues) >= int(zb0005) {
				z.BaseResolvedValues = (z.BaseResolvedValues)[:zb0005]
			} else {
				z.BaseResolvedValues = make([]int, zb0005)
			}
			for za0004 := range z.BaseResolvedValues {
				z.BaseResolvedValues[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BaseResolvedValues", za0004)
					return
				}
			}
		case "DamageEffectiveness":
			z.DamageEffectiveness, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DamageEffectiveness")
				return
			}
		case "FloatStats":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "FloatStats")
				return
			}
			if cap(z.FloatStats) >= int(zb0006) {
				z.FloatStats = (z.FloatStats)[:zb0006]
			} else {
				z.FloatStats = make([]int, zb0006)
			}
			for za0005 := range z.FloatStats {
				z.FloatStats[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "FloatStats", za0005)
					return
				}
			}
		case "FloatStatsValues":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "FloatStatsValues")
				return
			}
			if cap(z.FloatStatsValues) >= int(zb0007) {
				z.FloatStatsValues = (z.FloatStatsValues)[:zb0007]
			} else {
				z.FloatStatsValues = make([]float64, zb0007)
			}
			for za0006 := range z.FloatStatsValues {
				z.FloatStatsValues[za0006], err = dc.ReadFloat64()
				if err != nil {
					err = msgp.WrapError(err, "FloatStatsValues", za0006)
					return
				}
			}
		case "GemLevel":
			z.GemLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "GemLevel")
				return
			}
		case "GrantedEffects":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffects")
				return
			}
			if cap(z.GrantedEffects) >= int(zb0008) {
				z.GrantedEffects = (z.GrantedEffects)[:zb0008]
			} else {
				z.GrantedEffects = make([]int, zb0008)
			}
			for za0007 := range z.GrantedEffects {
				z.GrantedEffects[za0007], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffects", za0007)
					return
				}
			}
		case "InterpolationBases":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "InterpolationBases")
				return
			}
			if cap(z.InterpolationBases) >= int(zb0009) {
				z.InterpolationBases = (z.InterpolationBases)[:zb0009]
			} else {
				z.InterpolationBases = make([]int, zb0009)
			}
			for za0008 := range z.InterpolationBases {
				z.InterpolationBases[za0008], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "InterpolationBases", za0008)
					return
				}
			}
		case "PlayerLevelReq":
			z.PlayerLevelReq, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PlayerLevelReq")
				return
			}
		case "OffhandCritChance":
			z.OffhandCritChance, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "OffhandCritChance")
				return
			}
		case "StatInterpolations":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "StatInterpolations")
				return
			}
			if cap(z.StatInterpolations) >= int(zb0010) {
				z.StatInterpolations = (z.StatInterpolations)[:zb0010]
			} else {
				z.StatInterpolations = make([]int, zb0010)
			}
			for za0009 := range z.StatInterpolations {
				z.StatInterpolations[za0009], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatInterpolations", za0009)
					return
				}
			}
		case "StatSet":
			z.StatSet, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatSet")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GrantedEffectStatSetsPerLevel) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 17
	// write "AdditionalBooleanStats"
	err = en.Append(0xde, 0x0, 0x11, 0xb6, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AdditionalBooleanStats)))
	if err != nil {
		err = msgp.WrapError(err, "AdditionalBooleanStats")
		return
	}
	for za0001 := range z.AdditionalBooleanStats {
		err = en.WriteInt(z.AdditionalBooleanStats[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AdditionalBooleanStats", za0001)
			return
		}
	}
	// write "AdditionalStats"
	err = en.Append(0xaf, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AdditionalStats)))
	if err != nil {
		err = msgp.WrapError(err, "AdditionalStats")
		return
	}
	for za0002 := range z.AdditionalStats {
		err = en.WriteInt(z.AdditionalStats[za0002])
		if err != nil {
			err = msgp.WrapError(err, "AdditionalStats", za0002)
			return
		}
	}
	// write "AdditionalStatsValues"
	err = en.Append(0xb5, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AdditionalStatsValues)))
	if err != nil {
		err = msgp.WrapError(err, "AdditionalStatsValues")
		return
	}
	for za0003 := range z.AdditionalStatsValues {
		err = en.WriteInt(z.AdditionalStatsValues[za0003])
		if err != nil {
			err = msgp.WrapError(err, "AdditionalStatsValues", za0003)
			return
		}
	}
	// write "AttackCritChance"
	err = en.Append(0xb0, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x43, 0x72, 0x69, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AttackCritChance)
	if err != nil {
		err = msgp.WrapError(err, "AttackCritChance")
		return
	}
	// write "BaseMultiplier"
	err = en.Append(0xae, 0x42, 0x61, 0x73, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "BaseMultiplier")
		return
	}
	// write "BaseResolvedValues"
	err = en.Append(0xb2, 0x42, 0x61, 0x73, 0x65, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BaseResolvedValues)))
	if err != nil {
		err = msgp.WrapError(err, "BaseResolvedValues")
		return
	}
	for za0004 := range z.BaseResolvedValues {
		err = en.WriteInt(z.BaseResolvedValues[za0004])
		if err != nil {
			err = msgp.WrapError(err, "BaseResolvedValues", za0004)
			return
		}
	}
	// write "DamageEffectiveness"
	err = en.Append(0xb3, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DamageEffectiveness)
	if err != nil {
		err = msgp.WrapError(err, "DamageEffectiveness")
		return
	}
	// write "FloatStats"
	err = en.Append(0xaa, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.FloatStats)))
	if err != nil {
		err = msgp.WrapError(err, "FloatStats")
		return
	}
	for za0005 := range z.FloatStats {
		err = en.WriteInt(z.FloatStats[za0005])
		if err != nil {
			err = msgp.WrapError(err, "FloatStats", za0005)
			return
		}
	}
	// write "FloatStatsValues"
	err = en.Append(0xb0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.FloatStatsValues)))
	if err != nil {
		err = msgp.WrapError(err, "FloatStatsValues")
		return
	}
	for za0006 := range z.FloatStatsValues {
		err = en.WriteFloat64(z.FloatStatsValues[za0006])
		if err != nil {
			err = msgp.WrapError(err, "FloatStatsValues", za0006)
			return
		}
	}
	// write "GemLevel"
	err = en.Append(0xa8, 0x47, 0x65, 0x6d, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.GemLevel)
	if err != nil {
		err = msgp.WrapError(err, "GemLevel")
		return
	}
	// write "GrantedEffects"
	err = en.Append(0xae, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GrantedEffects)))
	if err != nil {
		err = msgp.WrapError(err, "GrantedEffects")
		return
	}
	for za0007 := range z.GrantedEffects {
		err = en.WriteInt(z.GrantedEffects[za0007])
		if err != nil {
			err = msgp.WrapError(err, "GrantedEffects", za0007)
			return
		}
	}
	// write "InterpolationBases"
	err = en.Append(0xb2, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x61, 0x73, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.InterpolationBases)))
	if err != nil {
		err = msgp.WrapError(err, "InterpolationBases")
		return
	}
	for za0008 := range z.InterpolationBases {
		err = en.WriteInt(z.InterpolationBases[za0008])
		if err != nil {
			err = msgp.WrapError(err, "InterpolationBases", za0008)
			return
		}
	}
	// write "PlayerLevelReq"
	err = en.Append(0xae, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x65, 0x71)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PlayerLevelReq)
	if err != nil {
		err = msgp.WrapError(err, "PlayerLevelReq")
		return
	}
	// write "OffhandCritChance"
	err = en.Append(0xb1, 0x4f, 0x66, 0x66, 0x68, 0x61, 0x6e, 0x64, 0x43, 0x72, 0x69, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.OffhandCritChance)
	if err != nil {
		err = msgp.WrapError(err, "OffhandCritChance")
		return
	}
	// write "StatInterpolations"
	err = en.Append(0xb2, 0x53, 0x74, 0x61, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.StatInterpolations)))
	if err != nil {
		err = msgp.WrapError(err, "StatInterpolations")
		return
	}
	for za0009 := range z.StatInterpolations {
		err = en.WriteInt(z.StatInterpolations[za0009])
		if err != nil {
			err = msgp.WrapError(err, "StatInterpolations", za0009)
			return
		}
	}
	// write "StatSet"
	err = en.Append(0xa7, 0x53, 0x74, 0x61, 0x74, 0x53, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatSet)
	if err != nil {
		err = msgp.WrapError(err, "StatSet")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GrantedEffectStatSetsPerLevel) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 17
	// string "AdditionalBooleanStats"
	o = append(o, 0xde, 0x0, 0x11, 0xb6, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x42, 0x6f, 0x6f, 0x6c, 0x65, 0x61, 0x6e, 0x53, 0x74, 0x61, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AdditionalBooleanStats)))
	for za0001 := range z.AdditionalBooleanStats {
		o = msgp.AppendInt(o, z.AdditionalBooleanStats[za0001])
	}
	// string "AdditionalStats"
	o = append(o, 0xaf, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AdditionalStats)))
	for za0002 := range z.AdditionalStats {
		o = msgp.AppendInt(o, z.AdditionalStats[za0002])
	}
	// string "AdditionalStatsValues"
	o = append(o, 0xb5, 0x41, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AdditionalStatsValues)))
	for za0003 := range z.AdditionalStatsValues {
		o = msgp.AppendInt(o, z.AdditionalStatsValues[za0003])
	}
	// string "AttackCritChance"
	o = append(o, 0xb0, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x43, 0x72, 0x69, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendInt(o, z.AttackCritChance)
	// string "BaseMultiplier"
	o = append(o, 0xae, 0x42, 0x61, 0x73, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.BaseMultiplier)
	// string "BaseResolvedValues"
	o = append(o, 0xb2, 0x42, 0x61, 0x73, 0x65, 0x52, 0x65, 0x73, 0x6f, 0x6c, 0x76, 0x65, 0x64, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BaseResolvedValues)))
	for za0004 := range z.BaseResolvedValues {
		o = msgp.AppendInt(o, z.BaseResolvedValues[za0004])
	}
	// string "DamageEffectiveness"
	o = append(o, 0xb3, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x69, 0x76, 0x65, 0x6e, 0x65, 0x73, 0x73)
	o = msgp.AppendInt(o, z.DamageEffectiveness)
	// string "FloatStats"
	o = append(o, 0xaa, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.FloatStats)))
	for za0005 := range z.FloatStats {
		o = msgp.AppendInt(o, z.FloatStats[za0005])
	}
	// string "FloatStatsValues"
	o = append(o, 0xb0, 0x46, 0x6c, 0x6f, 0x61, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.FloatStatsValues)))
	for za0006 := range z.FloatStatsValues {
		o = msgp.AppendFloat64(o, z.FloatStatsValues[za0006])
	}
	// string "GemLevel"
	o = append(o, 0xa8, 0x47, 0x65, 0x6d, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.GemLevel)
	// string "GrantedEffects"
	o = append(o, 0xae, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GrantedEffects)))
	for za0007 := range z.GrantedEffects {
		o = msgp.AppendInt(o, z.GrantedEffects[za0007])
	}
	// string "InterpolationBases"
	o = append(o, 0xb2, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x42, 0x61, 0x73, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.InterpolationBases)))
	for za0008 := range z.InterpolationBases {
		o = msgp.AppendInt(o, z.InterpolationBases[za0008])
	}
	// string "PlayerLevelReq"
	o = append(o, 0xae, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x65, 0x71)
	o = msgp.AppendInt(o, z.PlayerLevelReq)
	// string "OffhandCritChance"
	o = append(o, 0xb1, 0x4f, 0x66, 0x66, 0x68, 0x61, 0x6e, 0x64, 0x43, 0x72, 0x69, 0x74, 0x43, 0x68, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendInt(o, z.OffhandCritChance)
	// string "StatInterpolations"
	o = append(o, 0xb2, 0x53, 0x74, 0x61, 0x74, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x70, 0x6f, 0x6c, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.StatInterpolations)))
	for za0009 := range z.StatInterpolations {
		o = msgp.AppendInt(o, z.StatInterpolations[za0009])
	}
	// string "StatSet"
	o = append(o, 0xa7, 0x53, 0x74, 0x61, 0x74, 0x53, 0x65, 0x74)
	o = msgp.AppendInt(o, z.StatSet)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GrantedEffectStatSetsPerLevel) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AdditionalBooleanStats":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdditionalBooleanStats")
				return
			}
			if cap(z.AdditionalBooleanStats) >= int(zb0002) {
				z.AdditionalBooleanStats = (z.AdditionalBooleanStats)[:zb0002]
			} else {
				z.AdditionalBooleanStats = make([]int, zb0002)
			}
			for za0001 := range z.AdditionalBooleanStats {
				z.AdditionalBooleanStats[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AdditionalBooleanStats", za0001)
					return
				}
			}
		case "AdditionalStats":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdditionalStats")
				return
			}
			if cap(z.AdditionalStats) >= int(zb0003) {
				z.AdditionalStats = (z.AdditionalStats)[:zb0003]
			} else {
				z.AdditionalStats = make([]int, zb0003)
			}
			for za0002 := range z.AdditionalStats {
				z.AdditionalStats[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AdditionalStats", za0002)
					return
				}
			}
		case "AdditionalStatsValues":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AdditionalStatsValues")
				return
			}
			if cap(z.AdditionalStatsValues) >= int(zb0004) {
				z.AdditionalStatsValues = (z.AdditionalStatsValues)[:zb0004]
			} else {
				z.AdditionalStatsValues = make([]int, zb0004)
			}
			for za0003 := range z.AdditionalStatsValues {
				z.AdditionalStatsValues[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AdditionalStatsValues", za0003)
					return
				}
			}
		case "AttackCritChance":
			z.AttackCritChance, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AttackCritChance")
				return
			}
		case "BaseMultiplier":
			z.BaseMultiplier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseMultiplier")
				return
			}
		case "BaseResolvedValues":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseResolvedValues")
				return
			}
			if cap(z.BaseResolvedValues) >= int(zb0005) {
				z.BaseResolvedValues = (z.BaseResolvedValues)[:zb0005]
			} else {
				z.BaseResolvedValues = make([]int, zb0005)
			}
			for za0004 := range z.BaseResolvedValues {
				z.BaseResolvedValues[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BaseResolvedValues", za0004)
					return
				}
			}
		case "DamageEffectiveness":
			z.DamageEffectiveness, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DamageEffectiveness")
				return
			}
		case "FloatStats":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FloatStats")
				return
			}
			if cap(z.FloatStats) >= int(zb0006) {
				z.FloatStats = (z.FloatStats)[:zb0006]
			} else {
				z.FloatStats = make([]int, zb0006)
			}
			for za0005 := range z.FloatStats {
				z.FloatStats[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatStats", za0005)
					return
				}
			}
		case "FloatStatsValues":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FloatStatsValues")
				return
			}
			if cap(z.FloatStatsValues) >= int(zb0007) {
				z.FloatStatsValues = (z.FloatStatsValues)[:zb0007]
			} else {
				z.FloatStatsValues = make([]float64, zb0007)
			}
			for za0006 := range z.FloatStatsValues {
				z.FloatStatsValues[za0006], bts, err = msgp.ReadFloat64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FloatStatsValues", za0006)
					return
				}
			}
		case "GemLevel":
			z.GemLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GemLevel")
				return
			}
		case "GrantedEffects":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffects")
				return
			}
			if cap(z.GrantedEffects) >= int(zb0008) {
				z.GrantedEffects = (z.GrantedEffects)[:zb0008]
			} else {
				z.GrantedEffects = make([]int, zb0008)
			}
			for za0007 := range z.GrantedEffects {
				z.GrantedEffects[za0007], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffects", za0007)
					return
				}
			}
		case "InterpolationBases":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InterpolationBases")
				return
			}
			if cap(z.InterpolationBases) >= int(zb0009) {
				z.InterpolationBases = (z.InterpolationBases)[:zb0009]
			} else {
				z.InterpolationBases = make([]int, zb0009)
			}
			for za0008 := range z.InterpolationBases {
				z.InterpolationBases[za0008], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "InterpolationBases", za0008)
					return
				}
			}
		case "PlayerLevelReq":
			z.PlayerLevelReq, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayerLevelReq")
				return
			}
		case "OffhandCritChance":
			z.OffhandCritChance, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "OffhandCritChance")
				return
			}
		case "StatInterpolations":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatInterpolations")
				return
			}
			if cap(z.StatInterpolations) >= int(zb0010) {
				z.StatInterpolations = (z.StatInterpolations)[:zb0010]
			} else {
				z.StatInterpolations = make([]int, zb0010)
			}
			for za0009 := range z.StatInterpolations {
				z.StatInterpolations[za0009], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatInterpolations", za0009)
					return
				}
			}
		case "StatSet":
			z.StatSet, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatSet")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GrantedEffectStatSetsPerLevel) Msgsize() (s int) {
	s = 3 + 23 + msgp.ArrayHeaderSize + (len(z.AdditionalBooleanStats) * (msgp.IntSize)) + 16 + msgp.ArrayHeaderSize + (len(z.AdditionalStats) * (msgp.IntSize)) + 22 + msgp.ArrayHeaderSize + (len(z.AdditionalStatsValues) * (msgp.IntSize)) + 17 + msgp.IntSize + 15 + msgp.IntSize + 19 + msgp.ArrayHeaderSize + (len(z.BaseResolvedValues) * (msgp.IntSize)) + 20 + msgp.IntSize + 11 + msgp.ArrayHeaderSize + (len(z.FloatStats) * (msgp.IntSize)) + 17 + msgp.ArrayHeaderSize + (len(z.FloatStatsValues) * (msgp.Float64Size)) + 9 + msgp.IntSize + 15 + msgp.ArrayHeaderSize + (len(z.GrantedEffects) * (msgp.IntSize)) + 19 + msgp.ArrayHeaderSize + (len(z.InterpolationBases) * (msgp.IntSize)) + 15 + msgp.IntSize + 18 + msgp.IntSize + 19 + msgp.ArrayHeaderSize + (len(z.StatInterpolations) * (msgp.IntSize)) + 8 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *GrantedEffectsPerLevel) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AttackSpeedMultiplier":
			z.AttackSpeedMultiplier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AttackSpeedMultiplier")
				return
			}
		case "AttackTime":
			z.AttackTime, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AttackTime")
				return
			}
		case "Cooldown":
			z.Cooldown, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Cooldown")
				return
			}
		case "CooldownBypassType":
			z.CooldownBypassType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CooldownBypassType")
				return
			}
		case "CooldownGroup":
			z.CooldownGroup, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CooldownGroup")
				return
			}
		case "CostAmounts":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CostAmounts")
				return
			}
			if cap(z.CostAmounts) >= int(zb0002) {
				z.CostAmounts = (z.CostAmounts)[:zb0002]
			} else {
				z.CostAmounts = make([]int, zb0002)
			}
			for za0001 := range z.CostAmounts {
				z.CostAmounts[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CostAmounts", za0001)
					return
				}
			}
		case "CostMultiplier":
			z.CostMultiplier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CostMultiplier")
				return
			}
		case "CostTypes":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CostTypes")
				return
			}
			if cap(z.CostTypes) >= int(zb0003) {
				z.CostTypes = (z.CostTypes)[:zb0003]
			} else {
				z.CostTypes = make([]int, zb0003)
			}
			for za0002 := range z.CostTypes {
				z.CostTypes[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CostTypes", za0002)
					return
				}
			}
		case "GrantedEffect":
			z.GrantedEffect, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffect")
				return
			}
		case "Level":
			z.Level, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "LifeReservationFlat":
			z.LifeReservationFlat, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LifeReservationFlat")
				return
			}
		case "LifeReservationPercent":
			z.LifeReservationPercent, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LifeReservationPercent")
				return
			}
		case "ManaReservationFlat":
			z.ManaReservationFlat, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ManaReservationFlat")
				return
			}
		case "ManaReservationPercent":
			z.ManaReservationPercent, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ManaReservationPercent")
				return
			}
		case "PlayerLevelReq":
			z.PlayerLevelReq, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PlayerLevelReq")
				return
			}
		case "SoulGainPreventionDuration":
			z.SoulGainPreventionDuration, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SoulGainPreventionDuration")
				return
			}
		case "StoredUses":
			z.StoredUses, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StoredUses")
				return
			}
		case "VaalSouls":
			z.VaalSouls, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "VaalSouls")
				return
			}
		case "VaalStoredUses":
			z.VaalStoredUses, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "VaalStoredUses")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *GrantedEffectsPerLevel) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 20
	// write "AttackSpeedMultiplier"
	err = en.Append(0xde, 0x0, 0x14, 0xb5, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x53, 0x70, 0x65, 0x65, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AttackSpeedMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "AttackSpeedMultiplier")
		return
	}
	// write "AttackTime"
	err = en.Append(0xaa, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x54, 0x69, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AttackTime)
	if err != nil {
		err = msgp.WrapError(err, "AttackTime")
		return
	}
	// write "Cooldown"
	err = en.Append(0xa8, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Cooldown)
	if err != nil {
		err = msgp.WrapError(err, "Cooldown")
		return
	}
	// write "CooldownBypassType"
	err = en.Append(0xb2, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x42, 0x79, 0x70, 0x61, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CooldownBypassType)
	if err != nil {
		err = msgp.WrapError(err, "CooldownBypassType")
		return
	}
	// write "CooldownGroup"
	err = en.Append(0xad, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x47, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CooldownGroup)
	if err != nil {
		err = msgp.WrapError(err, "CooldownGroup")
		return
	}
	// write "CostAmounts"
	err = en.Append(0xab, 0x43, 0x6f, 0x73, 0x74, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CostAmounts)))
	if err != nil {
		err = msgp.WrapError(err, "CostAmounts")
		return
	}
	for za0001 := range z.CostAmounts {
		err = en.WriteInt(z.CostAmounts[za0001])
		if err != nil {
			err = msgp.WrapError(err, "CostAmounts", za0001)
			return
		}
	}
	// write "CostMultiplier"
	err = en.Append(0xae, 0x43, 0x6f, 0x73, 0x74, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CostMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "CostMultiplier")
		return
	}
	// write "CostTypes"
	err = en.Append(0xa9, 0x43, 0x6f, 0x73, 0x74, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CostTypes)))
	if err != nil {
		err = msgp.WrapError(err, "CostTypes")
		return
	}
	for za0002 := range z.CostTypes {
		err = en.WriteInt(z.CostTypes[za0002])
		if err != nil {
			err = msgp.WrapError(err, "CostTypes", za0002)
			return
		}
	}
	// write "GrantedEffect"
	err = en.Append(0xad, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.GrantedEffect)
	if err != nil {
		err = msgp.WrapError(err, "GrantedEffect")
		return
	}
	// write "Level"
	err = en.Append(0xa5, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Level)
	if err != nil {
		err = msgp.WrapError(err, "Level")
		return
	}
	// write "LifeReservationFlat"
	err = en.Append(0xb3, 0x4c, 0x69, 0x66, 0x65, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.LifeReservationFlat)
	if err != nil {
		err = msgp.WrapError(err, "LifeReservationFlat")
		return
	}
	// write "LifeReservationPercent"
	err = en.Append(0xb6, 0x4c, 0x69, 0x66, 0x65, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.LifeReservationPercent)
	if err != nil {
		err = msgp.WrapError(err, "LifeReservationPercent")
		return
	}
	// write "ManaReservationFlat"
	err = en.Append(0xb3, 0x4d, 0x61, 0x6e, 0x61, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x61, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ManaReservationFlat)
	if err != nil {
		err = msgp.WrapError(err, "ManaReservationFlat")
		return
	}
	// write "ManaReservationPercent"
	err = en.Append(0xb6, 0x4d, 0x61, 0x6e, 0x61, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ManaReservationPercent)
	if err != nil {
		err = msgp.WrapError(err, "ManaReservationPercent")
		return
	}
	// write "PlayerLevelReq"
	err = en.Append(0xae, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x65, 0x71)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PlayerLevelReq)
	if err != nil {
		err = msgp.WrapError(err, "PlayerLevelReq")
		return
	}
	// write "SoulGainPreventionDuration"
	err = en.Append(0xba, 0x53, 0x6f, 0x75, 0x6c, 0x47, 0x61, 0x69, 0x6e, 0x50, 0x72, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SoulGainPreventionDuration)
	if err != nil {
		err = msgp.WrapError(err, "SoulGainPreventionDuration")
		return
	}
	// write "StoredUses"
	err = en.Append(0xaa, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x55, 0x73, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StoredUses)
	if err != nil {
		err = msgp.WrapError(err, "StoredUses")
		return
	}
	// write "VaalSouls"
	err = en.Append(0xa9, 0x56, 0x61, 0x61, 0x6c, 0x53, 0x6f, 0x75, 0x6c, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.VaalSouls)
	if err != nil {
		err = msgp.WrapError(err, "VaalSouls")
		return
	}
	// write "VaalStoredUses"
	err = en.Append(0xae, 0x56, 0x61, 0x61, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x55, 0x73, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.VaalStoredUses)
	if err != nil {
		err = msgp.WrapError(err, "VaalStoredUses")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *GrantedEffectsPerLevel) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 20
	// string "AttackSpeedMultiplier"
	o = append(o, 0xde, 0x0, 0x14, 0xb5, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x53, 0x70, 0x65, 0x65, 0x64, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.AttackSpeedMultiplier)
	// string "AttackTime"
	o = append(o, 0xaa, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x54, 0x69, 0x6d, 0x65)
	o = msgp.AppendInt(o, z.AttackTime)
	// string "Cooldown"
	o = append(o, 0xa8, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e)
	o = msgp.AppendInt(o, z.Cooldown)
	// string "CooldownBypassType"
	o = append(o, 0xb2, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x42, 0x79, 0x70, 0x61, 0x73, 0x73, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, z.CooldownBypassType)
	// string "CooldownGroup"
	o = append(o, 0xad, 0x43, 0x6f, 0x6f, 0x6c, 0x64, 0x6f, 0x77, 0x6e, 0x47, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendInt(o, z.CooldownGroup)
	// string "CostAmounts"
	o = append(o, 0xab, 0x43, 0x6f, 0x73, 0x74, 0x41, 0x6d, 0x6f, 0x75, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CostAmounts)))
	for za0001 := range z.CostAmounts {
		o = msgp.AppendInt(o, z.CostAmounts[za0001])
	}
	// string "CostMultiplier"
	o = append(o, 0xae, 0x43, 0x6f, 0x73, 0x74, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.CostMultiplier)
	// string "CostTypes"
	o = append(o, 0xa9, 0x43, 0x6f, 0x73, 0x74, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CostTypes)))
	for za0002 := range z.CostTypes {
		o = msgp.AppendInt(o, z.CostTypes[za0002])
	}
	// string "GrantedEffect"
	o = append(o, 0xad, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	o = msgp.AppendInt(o, z.GrantedEffect)
	// string "Level"
	o = append(o, 0xa5, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.Level)
	// string "LifeReservationFlat"
	o = append(o, 0xb3, 0x4c, 0x69, 0x66, 0x65, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x61, 0x74)
	o = msgp.AppendInt(o, z.LifeReservationFlat)
	// string "LifeReservationPercent"
	o = append(o, 0xb6, 0x4c, 0x69, 0x66, 0x65, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.LifeReservationPercent)
	// string "ManaReservationFlat"
	o = append(o, 0xb3, 0x4d, 0x61, 0x6e, 0x61, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x46, 0x6c, 0x61, 0x74)
	o = msgp.AppendInt(o, z.ManaReservationFlat)
	// string "ManaReservationPercent"
	o = append(o, 0xb6, 0x4d, 0x61, 0x6e, 0x61, 0x52, 0x65, 0x73, 0x65, 0x72, 0x76, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x50, 0x65, 0x72, 0x63, 0x65, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.ManaReservationPercent)
	// string "PlayerLevelReq"
	o = append(o, 0xae, 0x50, 0x6c, 0x61, 0x79, 0x65, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x52, 0x65, 0x71)
	o = msgp.AppendInt(o, z.PlayerLevelReq)
	// string "SoulGainPreventionDuration"
	o = append(o, 0xba, 0x53, 0x6f, 0x75, 0x6c, 0x47, 0x61, 0x69, 0x6e, 0x50, 0x72, 0x65, 0x76, 0x65, 0x6e, 0x74, 0x69, 0x6f, 0x6e, 0x44, 0x75, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendInt(o, z.SoulGainPreventionDuration)
	// string "StoredUses"
	o = append(o, 0xaa, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x55, 0x73, 0x65, 0x73)
	o = msgp.AppendInt(o, z.StoredUses)
	// string "VaalSouls"
	o = append(o, 0xa9, 0x56, 0x61, 0x61, 0x6c, 0x53, 0x6f, 0x75, 0x6c, 0x73)
	o = msgp.AppendInt(o, z.VaalSouls)
	// string "VaalStoredUses"
	o = append(o, 0xae, 0x56, 0x61, 0x61, 0x6c, 0x53, 0x74, 0x6f, 0x72, 0x65, 0x64, 0x55, 0x73, 0x65, 0x73)
	o = msgp.AppendInt(o, z.VaalStoredUses)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *GrantedEffectsPerLevel) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AttackSpeedMultiplier":
			z.AttackSpeedMultiplier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AttackSpeedMultiplier")
				return
			}
		case "AttackTime":
			z.AttackTime, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AttackTime")
				return
			}
		case "Cooldown":
			z.Cooldown, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Cooldown")
				return
			}
		case "CooldownBypassType":
			z.CooldownBypassType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CooldownBypassType")
				return
			}
		case "CooldownGroup":
			z.CooldownGroup, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CooldownGroup")
				return
			}
		case "CostAmounts":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CostAmounts")
				return
			}
			if cap(z.CostAmounts) >= int(zb0002) {
				z.CostAmounts = (z.CostAmounts)[:zb0002]
			} else {
				z.CostAmounts = make([]int, zb0002)
			}
			for za0001 := range z.CostAmounts {
				z.CostAmounts[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CostAmounts", za0001)
					return
				}
			}
		case "CostMultiplier":
			z.CostMultiplier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CostMultiplier")
				return
			}
		case "CostTypes":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CostTypes")
				return
			}
			if cap(z.CostTypes) >= int(zb0003) {
				z.CostTypes = (z.CostTypes)[:zb0003]
			} else {
				z.CostTypes = make([]int, zb0003)
			}
			for za0002 := range z.CostTypes {
				z.CostTypes[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CostTypes", za0002)
					return
				}
			}
		case "GrantedEffect":
			z.GrantedEffect, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffect")
				return
			}
		case "Level":
			z.Level, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "LifeReservationFlat":
			z.LifeReservationFlat, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeReservationFlat")
				return
			}
		case "LifeReservationPercent":
			z.LifeReservationPercent, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeReservationPercent")
				return
			}
		case "ManaReservationFlat":
			z.ManaReservationFlat, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManaReservationFlat")
				return
			}
		case "ManaReservationPercent":
			z.ManaReservationPercent, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ManaReservationPercent")
				return
			}
		case "PlayerLevelReq":
			z.PlayerLevelReq, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PlayerLevelReq")
				return
			}
		case "SoulGainPreventionDuration":
			z.SoulGainPreventionDuration, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SoulGainPreventionDuration")
				return
			}
		case "StoredUses":
			z.StoredUses, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StoredUses")
				return
			}
		case "VaalSouls":
			z.VaalSouls, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VaalSouls")
				return
			}
		case "VaalStoredUses":
			z.VaalStoredUses, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "VaalStoredUses")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *GrantedEffectsPerLevel) Msgsize() (s int) {
	s = 3 + 22 + msgp.IntSize + 11 + msgp.IntSize + 9 + msgp.IntSize + 19 + msgp.IntSize + 14 + msgp.IntSize + 12 + msgp.ArrayHeaderSize + (len(z.CostAmounts) * (msgp.IntSize)) + 15 + msgp.IntSize + 10 + msgp.ArrayHeaderSize + (len(z.CostTypes) * (msgp.IntSize)) + 14 + msgp.IntSize + 6 + msgp.IntSize + 20 + msgp.IntSize + 23 + msgp.IntSize + 20 + msgp.IntSize + 23 + msgp.IntSize + 15 + msgp.IntSize + 27 + msgp.IntSize + 11 + msgp.IntSize + 10 + msgp.IntSize + 15 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ItemClass) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AllocateToMapOwner":
			z.AllocateToMapOwner, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AllocateToMapOwner")
				return
			}
		case "AlwaysAllocate":
			z.AlwaysAllocate, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AlwaysAllocate")
				return
			}
		case "AlwaysShow":
			z.AlwaysShow, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AlwaysShow")
				return
			}
		case "CanBeCorrupted":
			z.CanBeCorrupted, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanBeCorrupted")
				return
			}
		case "CanBeDoubleCorrupted":
			z.CanBeDoubleCorrupted, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanBeDoubleCorrupted")
				return
			}
		case "CanHaveAspects":
			z.CanHaveAspects, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanHaveAspects")
				return
			}
		case "CanHaveIncubators":
			z.CanHaveIncubators, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanHaveIncubators")
				return
			}
		case "CanHaveInfluence":
			z.CanHaveInfluence, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanHaveInfluence")
				return
			}
		case "CanHaveVeiledMods":
			z.CanHaveVeiledMods, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanHaveVeiledMods")
				return
			}
		case "CanScourge":
			z.CanScourge, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanScourge")
				return
			}
		case "CanTransferSkin":
			z.CanTransferSkin, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "CanTransferSkin")
				return
			}
		case "Flags":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
			if cap(z.Flags) >= int(zb0002) {
				z.Flags = (z.Flags)[:zb0002]
			} else {
				z.Flags = make([]int, zb0002)
			}
			for za0001 := range z.Flags {
				z.Flags[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Flags", za0001)
					return
				}
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ItemClassCategory":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ItemClassCategory")
					return
				}
				z.ItemClassCategory = nil
			} else {
				if z.ItemClassCategory == nil {
					z.ItemClassCategory = new(int)
				}
				*z.ItemClassCategory, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ItemClassCategory")
					return
				}
			}
		case "ItemStance":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ItemStance")
					return
				}
				z.ItemStance = nil
			} else {
				if z.ItemStance == nil {
					z.ItemStance = new(int)
				}
				*z.ItemStance, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ItemStance")
					return
				}
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "RemovedIfLeavesArea":
			z.RemovedIfLeavesArea, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "RemovedIfLeavesArea")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ItemClass) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 18
	// write "AllocateToMapOwner"
	err = en.Append(0xde, 0x0, 0x12, 0xb2, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x54, 0x6f, 0x4d, 0x61, 0x70, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AllocateToMapOwner)
	if err != nil {
		err = msgp.WrapError(err, "AllocateToMapOwner")
		return
	}
	// write "AlwaysAllocate"
	err = en.Append(0xae, 0x41, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AlwaysAllocate)
	if err != nil {
		err = msgp.WrapError(err, "AlwaysAllocate")
		return
	}
	// write "AlwaysShow"
	err = en.Append(0xaa, 0x41, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x53, 0x68, 0x6f, 0x77)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AlwaysShow)
	if err != nil {
		err = msgp.WrapError(err, "AlwaysShow")
		return
	}
	// write "CanBeCorrupted"
	err = en.Append(0xae, 0x43, 0x61, 0x6e, 0x42, 0x65, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanBeCorrupted)
	if err != nil {
		err = msgp.WrapError(err, "CanBeCorrupted")
		return
	}
	// write "CanBeDoubleCorrupted"
	err = en.Append(0xb4, 0x43, 0x61, 0x6e, 0x42, 0x65, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanBeDoubleCorrupted)
	if err != nil {
		err = msgp.WrapError(err, "CanBeDoubleCorrupted")
		return
	}
	// write "CanHaveAspects"
	err = en.Append(0xae, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x41, 0x73, 0x70, 0x65, 0x63, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanHaveAspects)
	if err != nil {
		err = msgp.WrapError(err, "CanHaveAspects")
		return
	}
	// write "CanHaveIncubators"
	err = en.Append(0xb1, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x49, 0x6e, 0x63, 0x75, 0x62, 0x61, 0x74, 0x6f, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanHaveIncubators)
	if err != nil {
		err = msgp.WrapError(err, "CanHaveIncubators")
		return
	}
	// write "CanHaveInfluence"
	err = en.Append(0xb0, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x49, 0x6e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanHaveInfluence)
	if err != nil {
		err = msgp.WrapError(err, "CanHaveInfluence")
		return
	}
	// write "CanHaveVeiledMods"
	err = en.Append(0xb1, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x56, 0x65, 0x69, 0x6c, 0x65, 0x64, 0x4d, 0x6f, 0x64, 0x73)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanHaveVeiledMods)
	if err != nil {
		err = msgp.WrapError(err, "CanHaveVeiledMods")
		return
	}
	// write "CanScourge"
	err = en.Append(0xaa, 0x43, 0x61, 0x6e, 0x53, 0x63, 0x6f, 0x75, 0x72, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanScourge)
	if err != nil {
		err = msgp.WrapError(err, "CanScourge")
		return
	}
	// write "CanTransferSkin"
	err = en.Append(0xaf, 0x43, 0x61, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x53, 0x6b, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.CanTransferSkin)
	if err != nil {
		err = msgp.WrapError(err, "CanTransferSkin")
		return
	}
	// write "Flags"
	err = en.Append(0xa5, 0x46, 0x6c, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Flags)))
	if err != nil {
		err = msgp.WrapError(err, "Flags")
		return
	}
	for za0001 := range z.Flags {
		err = en.WriteInt(z.Flags[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Flags", za0001)
			return
		}
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "ItemClassCategory"
	err = en.Append(0xb1, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	if err != nil {
		return
	}
	if z.ItemClassCategory == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.ItemClassCategory)
		if err != nil {
			err = msgp.WrapError(err, "ItemClassCategory")
			return
		}
	}
	// write "ItemStance"
	err = en.Append(0xaa, 0x49, 0x74, 0x65, 0x6d, 0x53, 0x74, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	if z.ItemStance == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.ItemStance)
		if err != nil {
			err = msgp.WrapError(err, "ItemStance")
			return
		}
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "RemovedIfLeavesArea"
	err = en.Append(0xb3, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x49, 0x66, 0x4c, 0x65, 0x61, 0x76, 0x65, 0x73, 0x41, 0x72, 0x65, 0x61)
	if err != nil {
		return
	}
	err = en.WriteBool(z.RemovedIfLeavesArea)
	if err != nil {
		err = msgp.WrapError(err, "RemovedIfLeavesArea")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ItemClass) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 18
	// string "AllocateToMapOwner"
	o = append(o, 0xde, 0x0, 0x12, 0xb2, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65, 0x54, 0x6f, 0x4d, 0x61, 0x70, 0x4f, 0x77, 0x6e, 0x65, 0x72)
	o = msgp.AppendBool(o, z.AllocateToMapOwner)
	// string "AlwaysAllocate"
	o = append(o, 0xae, 0x41, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x41, 0x6c, 0x6c, 0x6f, 0x63, 0x61, 0x74, 0x65)
	o = msgp.AppendBool(o, z.AlwaysAllocate)
	// string "AlwaysShow"
	o = append(o, 0xaa, 0x41, 0x6c, 0x77, 0x61, 0x79, 0x73, 0x53, 0x68, 0x6f, 0x77)
	o = msgp.AppendBool(o, z.AlwaysShow)
	// string "CanBeCorrupted"
	o = append(o, 0xae, 0x43, 0x61, 0x6e, 0x42, 0x65, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.CanBeCorrupted)
	// string "CanBeDoubleCorrupted"
	o = append(o, 0xb4, 0x43, 0x61, 0x6e, 0x42, 0x65, 0x44, 0x6f, 0x75, 0x62, 0x6c, 0x65, 0x43, 0x6f, 0x72, 0x72, 0x75, 0x70, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.CanBeDoubleCorrupted)
	// string "CanHaveAspects"
	o = append(o, 0xae, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x41, 0x73, 0x70, 0x65, 0x63, 0x74, 0x73)
	o = msgp.AppendBool(o, z.CanHaveAspects)
	// string "CanHaveIncubators"
	o = append(o, 0xb1, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x49, 0x6e, 0x63, 0x75, 0x62, 0x61, 0x74, 0x6f, 0x72, 0x73)
	o = msgp.AppendBool(o, z.CanHaveIncubators)
	// string "CanHaveInfluence"
	o = append(o, 0xb0, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x49, 0x6e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x63, 0x65)
	o = msgp.AppendBool(o, z.CanHaveInfluence)
	// string "CanHaveVeiledMods"
	o = append(o, 0xb1, 0x43, 0x61, 0x6e, 0x48, 0x61, 0x76, 0x65, 0x56, 0x65, 0x69, 0x6c, 0x65, 0x64, 0x4d, 0x6f, 0x64, 0x73)
	o = msgp.AppendBool(o, z.CanHaveVeiledMods)
	// string "CanScourge"
	o = append(o, 0xaa, 0x43, 0x61, 0x6e, 0x53, 0x63, 0x6f, 0x75, 0x72, 0x67, 0x65)
	o = msgp.AppendBool(o, z.CanScourge)
	// string "CanTransferSkin"
	o = append(o, 0xaf, 0x43, 0x61, 0x6e, 0x54, 0x72, 0x61, 0x6e, 0x73, 0x66, 0x65, 0x72, 0x53, 0x6b, 0x69, 0x6e)
	o = msgp.AppendBool(o, z.CanTransferSkin)
	// string "Flags"
	o = append(o, 0xa5, 0x46, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Flags)))
	for za0001 := range z.Flags {
		o = msgp.AppendInt(o, z.Flags[za0001])
	}
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "ItemClassCategory"
	o = append(o, 0xb1, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	if z.ItemClassCategory == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.ItemClassCategory)
	}
	// string "ItemStance"
	o = append(o, 0xaa, 0x49, 0x74, 0x65, 0x6d, 0x53, 0x74, 0x61, 0x6e, 0x63, 0x65)
	if z.ItemStance == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.ItemStance)
	}
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "RemovedIfLeavesArea"
	o = append(o, 0xb3, 0x52, 0x65, 0x6d, 0x6f, 0x76, 0x65, 0x64, 0x49, 0x66, 0x4c, 0x65, 0x61, 0x76, 0x65, 0x73, 0x41, 0x72, 0x65, 0x61)
	o = msgp.AppendBool(o, z.RemovedIfLeavesArea)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ItemClass) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AllocateToMapOwner":
			z.AllocateToMapOwner, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AllocateToMapOwner")
				return
			}
		case "AlwaysAllocate":
			z.AlwaysAllocate, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AlwaysAllocate")
				return
			}
		case "AlwaysShow":
			z.AlwaysShow, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AlwaysShow")
				return
			}
		case "CanBeCorrupted":
			z.CanBeCorrupted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanBeCorrupted")
				return
			}
		case "CanBeDoubleCorrupted":
			z.CanBeDoubleCorrupted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanBeDoubleCorrupted")
				return
			}
		case "CanHaveAspects":
			z.CanHaveAspects, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanHaveAspects")
				return
			}
		case "CanHaveIncubators":
			z.CanHaveIncubators, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanHaveIncubators")
				return
			}
		case "CanHaveInfluence":
			z.CanHaveInfluence, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanHaveInfluence")
				return
			}
		case "CanHaveVeiledMods":
			z.CanHaveVeiledMods, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanHaveVeiledMods")
				return
			}
		case "CanScourge":
			z.CanScourge, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanScourge")
				return
			}
		case "CanTransferSkin":
			z.CanTransferSkin, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CanTransferSkin")
				return
			}
		case "Flags":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flags")
				return
			}
			if cap(z.Flags) >= int(zb0002) {
				z.Flags = (z.Flags)[:zb0002]
			} else {
				z.Flags = make([]int, zb0002)
			}
			for za0001 := range z.Flags {
				z.Flags[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Flags", za0001)
					return
				}
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ItemClassCategory":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ItemClassCategory = nil
			} else {
				if z.ItemClassCategory == nil {
					z.ItemClassCategory = new(int)
				}
				*z.ItemClassCategory, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ItemClassCategory")
					return
				}
			}
		case "ItemStance":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ItemStance = nil
			} else {
				if z.ItemStance == nil {
					z.ItemStance = new(int)
				}
				*z.ItemStance, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ItemStance")
					return
				}
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "RemovedIfLeavesArea":
			z.RemovedIfLeavesArea, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RemovedIfLeavesArea")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ItemClass) Msgsize() (s int) {
	s = 3 + 19 + msgp.BoolSize + 15 + msgp.BoolSize + 11 + msgp.BoolSize + 15 + msgp.BoolSize + 21 + msgp.BoolSize + 15 + msgp.BoolSize + 18 + msgp.BoolSize + 17 + msgp.BoolSize + 18 + msgp.BoolSize + 11 + msgp.BoolSize + 16 + msgp.BoolSize + 6 + msgp.ArrayHeaderSize + (len(z.Flags) * (msgp.IntSize)) + 3 + msgp.StringPrefixSize + len(z.ID) + 18
	if z.ItemClassCategory == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 11
	if z.ItemStance == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 5 + msgp.StringPrefixSize + len(z.Name) + 20 + msgp.BoolSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ItemExperiencePerLevel) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "Experience":
			z.Experience, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Experience")
				return
			}
		case "ItemCurrentLevel":
			z.ItemCurrentLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ItemCurrentLevel")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *ItemExperiencePerLevel) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "BaseItemTypesKey"
	err = en.Append(0x84, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "Experience"
	err = en.Append(0xaa, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x65, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Experience)
	if err != nil {
		err = msgp.WrapError(err, "Experience")
		return
	}
	// write "ItemCurrentLevel"
	err = en.Append(0xb0, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ItemCurrentLevel)
	if err != nil {
		err = msgp.WrapError(err, "ItemCurrentLevel")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *ItemExperiencePerLevel) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "BaseItemTypesKey"
	o = append(o, 0x84, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.BaseItemTypesKey)
	// string "Experience"
	o = append(o, 0xaa, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x65, 0x6e, 0x63, 0x65)
	o = msgp.AppendInt(o, z.Experience)
	// string "ItemCurrentLevel"
	o = append(o, 0xb0, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x75, 0x72, 0x72, 0x65, 0x6e, 0x74, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.ItemCurrentLevel)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ItemExperiencePerLevel) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "Experience":
			z.Experience, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Experience")
				return
			}
		case "ItemCurrentLevel":
			z.ItemCurrentLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ItemCurrentLevel")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *ItemExperiencePerLevel) Msgsize() (s int) {
	s = 1 + 17 + msgp.IntSize + 11 + msgp.IntSize + 17 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *LangTranslation) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Conditions":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Conditions")
				return
			}
			if cap(z.Conditions) >= int(zb0002) {
				z.Conditions = (z.Conditions)[:zb0002]
			} else {
				z.Conditions = make([]Condition, zb0002)
			}
			for za0001 := range z.Conditions {
				err = z.Conditions[za0001].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "Conditions", za0001)
					return
				}
			}
		case "IndexHandlers":
			var zb0003 uint32
			zb0003, err = dc.ReadMapHeader()
			if err != nil {
				err = msgp.WrapError(err, "IndexHandlers")
				return
			}
			if z.IndexHandlers == nil {
				z.IndexHandlers = make(map[string]string, zb0003)
			} else if len(z.IndexHandlers) > 0 {
				for key := range z.IndexHandlers {
					delete(z.IndexHandlers, key)
				}
			}
			for zb0003 > 0 {
				zb0003--
				var za0002 string
				var za0003 string
				za0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "IndexHandlers")
					return
				}
				za0003, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "IndexHandlers", za0002)
					return
				}
				z.IndexHandlers[za0002] = za0003
			}
		case "String":
			z.String, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "String")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *LangTranslation) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "Conditions"
	err = en.Append(0x83, 0xaa, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Conditions)))
	if err != nil {
		err = msgp.WrapError(err, "Conditions")
		return
	}
	for za0001 := range z.Conditions {
		err = z.Conditions[za0001].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "Conditions", za0001)
			return
		}
	}
	// write "IndexHandlers"
	err = en.Append(0xad, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x73)
	if err != nil {
		return
	}
	err = en.WriteMapHeader(uint32(len(z.IndexHandlers)))
	if err != nil {
		err = msgp.WrapError(err, "IndexHandlers")
		return
	}
	for za0002, za0003 := range z.IndexHandlers {
		err = en.WriteString(za0002)
		if err != nil {
			err = msgp.WrapError(err, "IndexHandlers")
			return
		}
		err = en.WriteString(za0003)
		if err != nil {
			err = msgp.WrapError(err, "IndexHandlers", za0002)
			return
		}
	}
	// write "String"
	err = en.Append(0xa6, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.String)
	if err != nil {
		err = msgp.WrapError(err, "String")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *LangTranslation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "Conditions"
	o = append(o, 0x83, 0xaa, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Conditions)))
	for za0001 := range z.Conditions {
		o, err = z.Conditions[za0001].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "Conditions", za0001)
			return
		}
	}
	// string "IndexHandlers"
	o = append(o, 0xad, 0x49, 0x6e, 0x64, 0x65, 0x78, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x73)
	o = msgp.AppendMapHeader(o, uint32(len(z.IndexHandlers)))
	for za0002, za0003 := range z.IndexHandlers {
		o = msgp.AppendString(o, za0002)
		o = msgp.AppendString(o, za0003)
	}
	// string "String"
	o = append(o, 0xa6, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	o = msgp.AppendString(o, z.String)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *LangTranslation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Conditions":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Conditions")
				return
			}
			if cap(z.Conditions) >= int(zb0002) {
				z.Conditions = (z.Conditions)[:zb0002]
			} else {
				z.Conditions = make([]Condition, zb0002)
			}
			for za0001 := range z.Conditions {
				bts, err = z.Conditions[za0001].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "Conditions", za0001)
					return
				}
			}
		case "IndexHandlers":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadMapHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IndexHandlers")
				return
			}
			if z.IndexHandlers == nil {
				z.IndexHandlers = make(map[string]string, zb0003)
			} else if len(z.IndexHandlers) > 0 {
				for key := range z.IndexHandlers {
					delete(z.IndexHandlers, key)
				}
			}
			for zb0003 > 0 {
				var za0002 string
				var za0003 string
				zb0003--
				za0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IndexHandlers")
					return
				}
				za0003, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IndexHandlers", za0002)
					return
				}
				z.IndexHandlers[za0002] = za0003
			}
		case "String":
			z.String, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "String")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *LangTranslation) Msgsize() (s int) {
	s = 1 + 11 + msgp.ArrayHeaderSize
	for za0001 := range z.Conditions {
		s += z.Conditions[za0001].Msgsize()
	}
	s += 14 + msgp.MapHeaderSize
	if z.IndexHandlers != nil {
		for za0002, za0003 := range z.IndexHandlers {
			_ = za0003
			s += msgp.StringPrefixSize + len(za0002) + msgp.StringPrefixSize + len(za0003)
		}
	}
	s += 7 + msgp.StringPrefixSize + len(z.String)
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Mod) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AchievementItemsKey":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AchievementItemsKey")
				return
			}
			if cap(z.AchievementItemsKey) >= int(zb0002) {
				z.AchievementItemsKey = (z.AchievementItemsKey)[:zb0002]
			} else {
				z.AchievementItemsKey = make([]interface{}, zb0002)
			}
			for za0001 := range z.AchievementItemsKey {
				z.AchievementItemsKey[za0001], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "AchievementItemsKey", za0001)
					return
				}
			}
		case "ArchnemesisMinionMod":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "ArchnemesisMinionMod")
					return
				}
				z.ArchnemesisMinionMod = nil
			} else {
				if z.ArchnemesisMinionMod == nil {
					z.ArchnemesisMinionMod = new(int)
				}
				*z.ArchnemesisMinionMod, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ArchnemesisMinionMod")
					return
				}
			}
		case "BuffTemplate":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BuffTemplate")
					return
				}
				z.BuffTemplate = nil
			} else {
				if z.BuffTemplate == nil {
					z.BuffTemplate = new(int)
				}
				*z.BuffTemplate, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BuffTemplate")
					return
				}
			}
		case "ChestModType":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ChestModType")
				return
			}
			if cap(z.ChestModType) >= int(zb0003) {
				z.ChestModType = (z.ChestModType)[:zb0003]
			} else {
				z.ChestModType = make([]int, zb0003)
			}
			for za0002 := range z.ChestModType {
				z.ChestModType[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ChestModType", za0002)
					return
				}
			}
		case "CorrectGroup":
			z.CorrectGroup, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CorrectGroup")
				return
			}
		case "CraftingItemClassRestrictions":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "CraftingItemClassRestrictions")
				return
			}
			if cap(z.CraftingItemClassRestrictions) >= int(zb0004) {
				z.CraftingItemClassRestrictions = (z.CraftingItemClassRestrictions)[:zb0004]
			} else {
				z.CraftingItemClassRestrictions = make([]int, zb0004)
			}
			for za0003 := range z.CraftingItemClassRestrictions {
				z.CraftingItemClassRestrictions[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "CraftingItemClassRestrictions", za0003)
					return
				}
			}
		case "Domain":
			z.Domain, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Domain")
				return
			}
		case "FullAreaClearAchievementItemsKey":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "FullAreaClearAchievementItemsKey")
				return
			}
			if cap(z.FullAreaClearAchievementItemsKey) >= int(zb0005) {
				z.FullAreaClearAchievementItemsKey = (z.FullAreaClearAchievementItemsKey)[:zb0005]
			} else {
				z.FullAreaClearAchievementItemsKey = make([]interface{}, zb0005)
			}
			for za0004 := range z.FullAreaClearAchievementItemsKey {
				z.FullAreaClearAchievementItemsKey[za0004], err = dc.ReadIntf()
				if err != nil {
					err = msgp.WrapError(err, "FullAreaClearAchievementItemsKey", za0004)
					return
				}
			}
		case "GenerationType":
			z.GenerationType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "GenerationType")
				return
			}
		case "GenerationWeightTagsKeys":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GenerationWeightTagsKeys")
				return
			}
			if cap(z.GenerationWeightTagsKeys) >= int(zb0006) {
				z.GenerationWeightTagsKeys = (z.GenerationWeightTagsKeys)[:zb0006]
			} else {
				z.GenerationWeightTagsKeys = make([]int, zb0006)
			}
			for za0005 := range z.GenerationWeightTagsKeys {
				z.GenerationWeightTagsKeys[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GenerationWeightTagsKeys", za0005)
					return
				}
			}
		case "GenerationWeightValues":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GenerationWeightValues")
				return
			}
			if cap(z.GenerationWeightValues) >= int(zb0007) {
				z.GenerationWeightValues = (z.GenerationWeightValues)[:zb0007]
			} else {
				z.GenerationWeightValues = make([]int, zb0007)
			}
			for za0006 := range z.GenerationWeightValues {
				z.GenerationWeightValues[za0006], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GenerationWeightValues", za0006)
					return
				}
			}
		case "GrantedEffectsPerLevelKeys":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectsPerLevelKeys")
				return
			}
			if cap(z.GrantedEffectsPerLevelKeys) >= int(zb0008) {
				z.GrantedEffectsPerLevelKeys = (z.GrantedEffectsPerLevelKeys)[:zb0008]
			} else {
				z.GrantedEffectsPerLevelKeys = make([]int, zb0008)
			}
			for za0007 := range z.GrantedEffectsPerLevelKeys {
				z.GrantedEffectsPerLevelKeys[za0007], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffectsPerLevelKeys", za0007)
					return
				}
			}
		case "Hash16":
			z.Hash16, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hash16")
				return
			}
		case "Hash32":
			z.Hash32, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hash32")
				return
			}
		case "HeistAddStatValue1":
			z.HeistAddStatValue1, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HeistAddStatValue1")
				return
			}
		case "HeistAddStatValue2":
			z.HeistAddStatValue2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HeistAddStatValue2")
				return
			}
		case "HeistStatsKey0":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HeistStatsKey0")
					return
				}
				z.HeistStatsKey0 = nil
			} else {
				if z.HeistStatsKey0 == nil {
					z.HeistStatsKey0 = new(int)
				}
				*z.HeistStatsKey0, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "HeistStatsKey0")
					return
				}
			}
		case "HeistStatsKey1":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HeistStatsKey1")
					return
				}
				z.HeistStatsKey1 = nil
			} else {
				if z.HeistStatsKey1 == nil {
					z.HeistStatsKey1 = new(int)
				}
				*z.HeistStatsKey1, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "HeistStatsKey1")
					return
				}
			}
		case "HeistSubStatValue1":
			z.HeistSubStatValue1, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HeistSubStatValue1")
				return
			}
		case "HeistSubStatValue2":
			z.HeistSubStatValue2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "HeistSubStatValue2")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ImplicitTagsKeys":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ImplicitTagsKeys")
				return
			}
			if cap(z.ImplicitTagsKeys) >= int(zb0009) {
				z.ImplicitTagsKeys = (z.ImplicitTagsKeys)[:zb0009]
			} else {
				z.ImplicitTagsKeys = make([]int, zb0009)
			}
			for za0008 := range z.ImplicitTagsKeys {
				z.ImplicitTagsKeys[za0008], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ImplicitTagsKeys", za0008)
					return
				}
			}
		case "InfluenceTypes":
			z.InfluenceTypes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "InfluenceTypes")
				return
			}
		case "IsEssenceOnlyModifier":
			z.IsEssenceOnlyModifier, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsEssenceOnlyModifier")
				return
			}
		case "Level":
			z.Level, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "MaxLevel":
			z.MaxLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaxLevel")
				return
			}
		case "ModTypeKey":
			z.ModTypeKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ModTypeKey")
				return
			}
		case "ModifyMapsAchievements":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ModifyMapsAchievements")
				return
			}
			if cap(z.ModifyMapsAchievements) >= int(zb0010) {
				z.ModifyMapsAchievements = (z.ModifyMapsAchievements)[:zb0010]
			} else {
				z.ModifyMapsAchievements = make([]int, zb0010)
			}
			for za0009 := range z.ModifyMapsAchievements {
				z.ModifyMapsAchievements[za0009], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ModifyMapsAchievements", za0009)
					return
				}
			}
		case "MonsterKillAchievements":
			var zb0011 uint32
			zb0011, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "MonsterKillAchievements")
				return
			}
			if cap(z.MonsterKillAchievements) >= int(zb0011) {
				z.MonsterKillAchievements = (z.MonsterKillAchievements)[:zb0011]
			} else {
				z.MonsterKillAchievements = make([]int, zb0011)
			}
			for za0010 := range z.MonsterKillAchievements {
				z.MonsterKillAchievements[za0010], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MonsterKillAchievements", za0010)
					return
				}
			}
		case "MonsterMetadata":
			z.MonsterMetadata, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MonsterMetadata")
				return
			}
		case "MonsterOnDeath":
			z.MonsterOnDeath, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "MonsterOnDeath")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SpawnWeightTagsKeys":
			var zb0012 uint32
			zb0012, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeightTagsKeys")
				return
			}
			if cap(z.SpawnWeightTagsKeys) >= int(zb0012) {
				z.SpawnWeightTagsKeys = (z.SpawnWeightTagsKeys)[:zb0012]
			} else {
				z.SpawnWeightTagsKeys = make([]int, zb0012)
			}
			for za0011 := range z.SpawnWeightTagsKeys {
				z.SpawnWeightTagsKeys[za0011], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SpawnWeightTagsKeys", za0011)
					return
				}
			}
		case "SpawnWeightValues":
			var zb0013 uint32
			zb0013, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeightValues")
				return
			}
			if cap(z.SpawnWeightValues) >= int(zb0013) {
				z.SpawnWeightValues = (z.SpawnWeightValues)[:zb0013]
			} else {
				z.SpawnWeightValues = make([]int, zb0013)
			}
			for za0012 := range z.SpawnWeightValues {
				z.SpawnWeightValues[za0012], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SpawnWeightValues", za0012)
					return
				}
			}
		case "Stat1Max":
			z.Stat1Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Max")
				return
			}
		case "Stat1Min":
			z.Stat1Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Min")
				return
			}
		case "Stat2Max":
			z.Stat2Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat2Max")
				return
			}
		case "Stat2Min":
			z.Stat2Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat2Min")
				return
			}
		case "Stat3Max":
			z.Stat3Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat3Max")
				return
			}
		case "Stat3Min":
			z.Stat3Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat3Min")
				return
			}
		case "Stat4Max":
			z.Stat4Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat4Max")
				return
			}
		case "Stat4Min":
			z.Stat4Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat4Min")
				return
			}
		case "Stat5Max":
			z.Stat5Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat5Max")
				return
			}
		case "Stat5Min":
			z.Stat5Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat5Min")
				return
			}
		case "Stat6Max":
			z.Stat6Max, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat6Max")
				return
			}
		case "Stat6Min":
			z.Stat6Min, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat6Min")
				return
			}
		case "StatsKey1":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey1")
					return
				}
				z.StatsKey1 = nil
			} else {
				if z.StatsKey1 == nil {
					z.StatsKey1 = new(int)
				}
				*z.StatsKey1, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey1")
					return
				}
			}
		case "StatsKey2":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey2")
					return
				}
				z.StatsKey2 = nil
			} else {
				if z.StatsKey2 == nil {
					z.StatsKey2 = new(int)
				}
				*z.StatsKey2, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey2")
					return
				}
			}
		case "StatsKey3":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey3")
					return
				}
				z.StatsKey3 = nil
			} else {
				if z.StatsKey3 == nil {
					z.StatsKey3 = new(int)
				}
				*z.StatsKey3, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey3")
					return
				}
			}
		case "StatsKey4":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey4")
					return
				}
				z.StatsKey4 = nil
			} else {
				if z.StatsKey4 == nil {
					z.StatsKey4 = new(int)
				}
				*z.StatsKey4, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey4")
					return
				}
			}
		case "StatsKey5":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey5")
					return
				}
				z.StatsKey5 = nil
			} else {
				if z.StatsKey5 == nil {
					z.StatsKey5 = new(int)
				}
				*z.StatsKey5, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey5")
					return
				}
			}
		case "StatsKey6":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey6")
					return
				}
				z.StatsKey6 = nil
			} else {
				if z.StatsKey6 == nil {
					z.StatsKey6 = new(int)
				}
				*z.StatsKey6, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "StatsKey6")
					return
				}
			}
		case "TagsKeys":
			var zb0014 uint32
			zb0014, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TagsKeys")
				return
			}
			if cap(z.TagsKeys) >= int(zb0014) {
				z.TagsKeys = (z.TagsKeys)[:zb0014]
			} else {
				z.TagsKeys = make([]int, zb0014)
			}
			for za0013 := range z.TagsKeys {
				z.TagsKeys[za0013], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TagsKeys", za0013)
					return
				}
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Mod) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 54
	// write "AchievementItemsKey"
	err = en.Append(0xde, 0x0, 0x36, 0xb3, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AchievementItemsKey)))
	if err != nil {
		err = msgp.WrapError(err, "AchievementItemsKey")
		return
	}
	for za0001 := range z.AchievementItemsKey {
		err = en.WriteIntf(z.AchievementItemsKey[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AchievementItemsKey", za0001)
			return
		}
	}
	// write "ArchnemesisMinionMod"
	err = en.Append(0xb4, 0x41, 0x72, 0x63, 0x68, 0x6e, 0x65, 0x6d, 0x65, 0x73, 0x69, 0x73, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x4d, 0x6f, 0x64)
	if err != nil {
		return
	}
	if z.ArchnemesisMinionMod == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.ArchnemesisMinionMod)
		if err != nil {
			err = msgp.WrapError(err, "ArchnemesisMinionMod")
			return
		}
	}
	// write "BuffTemplate"
	err = en.Append(0xac, 0x42, 0x75, 0x66, 0x66, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65)
	if err != nil {
		return
	}
	if z.BuffTemplate == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.BuffTemplate)
		if err != nil {
			err = msgp.WrapError(err, "BuffTemplate")
			return
		}
	}
	// write "ChestModType"
	err = en.Append(0xac, 0x43, 0x68, 0x65, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ChestModType)))
	if err != nil {
		err = msgp.WrapError(err, "ChestModType")
		return
	}
	for za0002 := range z.ChestModType {
		err = en.WriteInt(z.ChestModType[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ChestModType", za0002)
			return
		}
	}
	// write "CorrectGroup"
	err = en.Append(0xac, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	err = en.WriteString(z.CorrectGroup)
	if err != nil {
		err = msgp.WrapError(err, "CorrectGroup")
		return
	}
	// write "CraftingItemClassRestrictions"
	err = en.Append(0xbd, 0x43, 0x72, 0x61, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.CraftingItemClassRestrictions)))
	if err != nil {
		err = msgp.WrapError(err, "CraftingItemClassRestrictions")
		return
	}
	for za0003 := range z.CraftingItemClassRestrictions {
		err = en.WriteInt(z.CraftingItemClassRestrictions[za0003])
		if err != nil {
			err = msgp.WrapError(err, "CraftingItemClassRestrictions", za0003)
			return
		}
	}
	// write "Domain"
	err = en.Append(0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Domain)
	if err != nil {
		err = msgp.WrapError(err, "Domain")
		return
	}
	// write "FullAreaClearAchievementItemsKey"
	err = en.Append(0xd9, 0x20, 0x46, 0x75, 0x6c, 0x6c, 0x41, 0x72, 0x65, 0x61, 0x43, 0x6c, 0x65, 0x61, 0x72, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.FullAreaClearAchievementItemsKey)))
	if err != nil {
		err = msgp.WrapError(err, "FullAreaClearAchievementItemsKey")
		return
	}
	for za0004 := range z.FullAreaClearAchievementItemsKey {
		err = en.WriteIntf(z.FullAreaClearAchievementItemsKey[za0004])
		if err != nil {
			err = msgp.WrapError(err, "FullAreaClearAchievementItemsKey", za0004)
			return
		}
	}
	// write "GenerationType"
	err = en.Append(0xae, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.GenerationType)
	if err != nil {
		err = msgp.WrapError(err, "GenerationType")
		return
	}
	// write "GenerationWeightTagsKeys"
	err = en.Append(0xb8, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GenerationWeightTagsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "GenerationWeightTagsKeys")
		return
	}
	for za0005 := range z.GenerationWeightTagsKeys {
		err = en.WriteInt(z.GenerationWeightTagsKeys[za0005])
		if err != nil {
			err = msgp.WrapError(err, "GenerationWeightTagsKeys", za0005)
			return
		}
	}
	// write "GenerationWeightValues"
	err = en.Append(0xb6, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GenerationWeightValues)))
	if err != nil {
		err = msgp.WrapError(err, "GenerationWeightValues")
		return
	}
	for za0006 := range z.GenerationWeightValues {
		err = en.WriteInt(z.GenerationWeightValues[za0006])
		if err != nil {
			err = msgp.WrapError(err, "GenerationWeightValues", za0006)
			return
		}
	}
	// write "GrantedEffectsPerLevelKeys"
	err = en.Append(0xba, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GrantedEffectsPerLevelKeys)))
	if err != nil {
		err = msgp.WrapError(err, "GrantedEffectsPerLevelKeys")
		return
	}
	for za0007 := range z.GrantedEffectsPerLevelKeys {
		err = en.WriteInt(z.GrantedEffectsPerLevelKeys[za0007])
		if err != nil {
			err = msgp.WrapError(err, "GrantedEffectsPerLevelKeys", za0007)
			return
		}
	}
	// write "Hash16"
	err = en.Append(0xa6, 0x48, 0x61, 0x73, 0x68, 0x31, 0x36)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Hash16)
	if err != nil {
		err = msgp.WrapError(err, "Hash16")
		return
	}
	// write "Hash32"
	err = en.Append(0xa6, 0x48, 0x61, 0x73, 0x68, 0x33, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Hash32)
	if err != nil {
		err = msgp.WrapError(err, "Hash32")
		return
	}
	// write "HeistAddStatValue1"
	err = en.Append(0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x41, 0x64, 0x64, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HeistAddStatValue1)
	if err != nil {
		err = msgp.WrapError(err, "HeistAddStatValue1")
		return
	}
	// write "HeistAddStatValue2"
	err = en.Append(0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x41, 0x64, 0x64, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HeistAddStatValue2)
	if err != nil {
		err = msgp.WrapError(err, "HeistAddStatValue2")
		return
	}
	// write "HeistStatsKey0"
	err = en.Append(0xae, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x30)
	if err != nil {
		return
	}
	if z.HeistStatsKey0 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.HeistStatsKey0)
		if err != nil {
			err = msgp.WrapError(err, "HeistStatsKey0")
			return
		}
	}
	// write "HeistStatsKey1"
	err = en.Append(0xae, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	if err != nil {
		return
	}
	if z.HeistStatsKey1 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.HeistStatsKey1)
		if err != nil {
			err = msgp.WrapError(err, "HeistStatsKey1")
			return
		}
	}
	// write "HeistSubStatValue1"
	err = en.Append(0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x75, 0x62, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HeistSubStatValue1)
	if err != nil {
		err = msgp.WrapError(err, "HeistSubStatValue1")
		return
	}
	// write "HeistSubStatValue2"
	err = en.Append(0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x75, 0x62, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.HeistSubStatValue2)
	if err != nil {
		err = msgp.WrapError(err, "HeistSubStatValue2")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "ImplicitTagsKeys"
	err = en.Append(0xb0, 0x49, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ImplicitTagsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "ImplicitTagsKeys")
		return
	}
	for za0008 := range z.ImplicitTagsKeys {
		err = en.WriteInt(z.ImplicitTagsKeys[za0008])
		if err != nil {
			err = msgp.WrapError(err, "ImplicitTagsKeys", za0008)
			return
		}
	}
	// write "InfluenceTypes"
	err = en.Append(0xae, 0x49, 0x6e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.InfluenceTypes)
	if err != nil {
		err = msgp.WrapError(err, "InfluenceTypes")
		return
	}
	// write "IsEssenceOnlyModifier"
	err = en.Append(0xb5, 0x49, 0x73, 0x45, 0x73, 0x73, 0x65, 0x6e, 0x63, 0x65, 0x4f, 0x6e, 0x6c, 0x79, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsEssenceOnlyModifier)
	if err != nil {
		err = msgp.WrapError(err, "IsEssenceOnlyModifier")
		return
	}
	// write "Level"
	err = en.Append(0xa5, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Level)
	if err != nil {
		err = msgp.WrapError(err, "Level")
		return
	}
	// write "MaxLevel"
	err = en.Append(0xa8, 0x4d, 0x61, 0x78, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaxLevel)
	if err != nil {
		err = msgp.WrapError(err, "MaxLevel")
		return
	}
	// write "ModTypeKey"
	err = en.Append(0xaa, 0x4d, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ModTypeKey)
	if err != nil {
		err = msgp.WrapError(err, "ModTypeKey")
		return
	}
	// write "ModifyMapsAchievements"
	err = en.Append(0xb6, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x4d, 0x61, 0x70, 0x73, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ModifyMapsAchievements)))
	if err != nil {
		err = msgp.WrapError(err, "ModifyMapsAchievements")
		return
	}
	for za0009 := range z.ModifyMapsAchievements {
		err = en.WriteInt(z.ModifyMapsAchievements[za0009])
		if err != nil {
			err = msgp.WrapError(err, "ModifyMapsAchievements", za0009)
			return
		}
	}
	// write "MonsterKillAchievements"
	err = en.Append(0xb7, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4b, 0x69, 0x6c, 0x6c, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.MonsterKillAchievements)))
	if err != nil {
		err = msgp.WrapError(err, "MonsterKillAchievements")
		return
	}
	for za0010 := range z.MonsterKillAchievements {
		err = en.WriteInt(z.MonsterKillAchievements[za0010])
		if err != nil {
			err = msgp.WrapError(err, "MonsterKillAchievements", za0010)
			return
		}
	}
	// write "MonsterMetadata"
	err = en.Append(0xaf, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61)
	if err != nil {
		return
	}
	err = en.WriteString(z.MonsterMetadata)
	if err != nil {
		err = msgp.WrapError(err, "MonsterMetadata")
		return
	}
	// write "MonsterOnDeath"
	err = en.Append(0xae, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4f, 0x6e, 0x44, 0x65, 0x61, 0x74, 0x68)
	if err != nil {
		return
	}
	err = en.WriteString(z.MonsterOnDeath)
	if err != nil {
		err = msgp.WrapError(err, "MonsterOnDeath")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "SpawnWeightTagsKeys"
	err = en.Append(0xb3, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SpawnWeightTagsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "SpawnWeightTagsKeys")
		return
	}
	for za0011 := range z.SpawnWeightTagsKeys {
		err = en.WriteInt(z.SpawnWeightTagsKeys[za0011])
		if err != nil {
			err = msgp.WrapError(err, "SpawnWeightTagsKeys", za0011)
			return
		}
	}
	// write "SpawnWeightValues"
	err = en.Append(0xb1, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SpawnWeightValues)))
	if err != nil {
		err = msgp.WrapError(err, "SpawnWeightValues")
		return
	}
	for za0012 := range z.SpawnWeightValues {
		err = en.WriteInt(z.SpawnWeightValues[za0012])
		if err != nil {
			err = msgp.WrapError(err, "SpawnWeightValues", za0012)
			return
		}
	}
	// write "Stat1Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Max")
		return
	}
	// write "Stat1Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Min")
		return
	}
	// write "Stat2Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat2Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat2Max")
		return
	}
	// write "Stat2Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat2Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat2Min")
		return
	}
	// write "Stat3Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x33, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat3Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat3Max")
		return
	}
	// write "Stat3Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x33, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat3Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat3Min")
		return
	}
	// write "Stat4Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x34, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat4Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat4Max")
		return
	}
	// write "Stat4Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x34, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat4Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat4Min")
		return
	}
	// write "Stat5Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x35, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat5Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat5Max")
		return
	}
	// write "Stat5Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x35, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat5Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat5Min")
		return
	}
	// write "Stat6Max"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x36, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat6Max)
	if err != nil {
		err = msgp.WrapError(err, "Stat6Max")
		return
	}
	// write "Stat6Min"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x36, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat6Min)
	if err != nil {
		err = msgp.WrapError(err, "Stat6Min")
		return
	}
	// write "StatsKey1"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	if err != nil {
		return
	}
	if z.StatsKey1 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.StatsKey1)
		if err != nil {
			err = msgp.WrapError(err, "StatsKey1")
			return
		}
	}
	// write "StatsKey2"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x32)
	if err != nil {
		return
	}
	if z.StatsKey2 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.StatsKey2)
		if err != nil {
			err = msgp.WrapError(err, "StatsKey2")
			return
		}
	}
	// write "StatsKey3"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x33)
	if err != nil {
		return
	}
	if z.StatsKey3 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.StatsKey3)
		if err != nil {
			err = msgp.WrapError(err, "StatsKey3")
			return
		}
	}
	// write "StatsKey4"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x34)
	if err != nil {
		return
	}
	if z.StatsKey4 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.StatsKey4)
		if err != nil {
			err = msgp.WrapError(err, "StatsKey4")
			return
		}
	}
	// write "StatsKey5"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x35)
	if err != nil {
		return
	}
	if z.StatsKey5 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.StatsKey5)
		if err != nil {
			err = msgp.WrapError(err, "StatsKey5")
			return
		}
	}
	// write "StatsKey6"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x36)
	if err != nil {
		return
	}
	if z.StatsKey6 == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.StatsKey6)
		if err != nil {
			err = msgp.WrapError(err, "StatsKey6")
			return
		}
	}
	// write "TagsKeys"
	err = en.Append(0xa8, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TagsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "TagsKeys")
		return
	}
	for za0013 := range z.TagsKeys {
		err = en.WriteInt(z.TagsKeys[za0013])
		if err != nil {
			err = msgp.WrapError(err, "TagsKeys", za0013)
			return
		}
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Mod) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 54
	// string "AchievementItemsKey"
	o = append(o, 0xde, 0x0, 0x36, 0xb3, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AchievementItemsKey)))
	for za0001 := range z.AchievementItemsKey {
		o, err = msgp.AppendIntf(o, z.AchievementItemsKey[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AchievementItemsKey", za0001)
			return
		}
	}
	// string "ArchnemesisMinionMod"
	o = append(o, 0xb4, 0x41, 0x72, 0x63, 0x68, 0x6e, 0x65, 0x6d, 0x65, 0x73, 0x69, 0x73, 0x4d, 0x69, 0x6e, 0x69, 0x6f, 0x6e, 0x4d, 0x6f, 0x64)
	if z.ArchnemesisMinionMod == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.ArchnemesisMinionMod)
	}
	// string "BuffTemplate"
	o = append(o, 0xac, 0x42, 0x75, 0x66, 0x66, 0x54, 0x65, 0x6d, 0x70, 0x6c, 0x61, 0x74, 0x65)
	if z.BuffTemplate == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.BuffTemplate)
	}
	// string "ChestModType"
	o = append(o, 0xac, 0x43, 0x68, 0x65, 0x73, 0x74, 0x4d, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ChestModType)))
	for za0002 := range z.ChestModType {
		o = msgp.AppendInt(o, z.ChestModType[za0002])
	}
	// string "CorrectGroup"
	o = append(o, 0xac, 0x43, 0x6f, 0x72, 0x72, 0x65, 0x63, 0x74, 0x47, 0x72, 0x6f, 0x75, 0x70)
	o = msgp.AppendString(o, z.CorrectGroup)
	// string "CraftingItemClassRestrictions"
	o = append(o, 0xbd, 0x43, 0x72, 0x61, 0x66, 0x74, 0x69, 0x6e, 0x67, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x52, 0x65, 0x73, 0x74, 0x72, 0x69, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.CraftingItemClassRestrictions)))
	for za0003 := range z.CraftingItemClassRestrictions {
		o = msgp.AppendInt(o, z.CraftingItemClassRestrictions[za0003])
	}
	// string "Domain"
	o = append(o, 0xa6, 0x44, 0x6f, 0x6d, 0x61, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Domain)
	// string "FullAreaClearAchievementItemsKey"
	o = append(o, 0xd9, 0x20, 0x46, 0x75, 0x6c, 0x6c, 0x41, 0x72, 0x65, 0x61, 0x43, 0x6c, 0x65, 0x61, 0x72, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.FullAreaClearAchievementItemsKey)))
	for za0004 := range z.FullAreaClearAchievementItemsKey {
		o, err = msgp.AppendIntf(o, z.FullAreaClearAchievementItemsKey[za0004])
		if err != nil {
			err = msgp.WrapError(err, "FullAreaClearAchievementItemsKey", za0004)
			return
		}
	}
	// string "GenerationType"
	o = append(o, 0xae, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, z.GenerationType)
	// string "GenerationWeightTagsKeys"
	o = append(o, 0xb8, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GenerationWeightTagsKeys)))
	for za0005 := range z.GenerationWeightTagsKeys {
		o = msgp.AppendInt(o, z.GenerationWeightTagsKeys[za0005])
	}
	// string "GenerationWeightValues"
	o = append(o, 0xb6, 0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GenerationWeightValues)))
	for za0006 := range z.GenerationWeightValues {
		o = msgp.AppendInt(o, z.GenerationWeightValues[za0006])
	}
	// string "GrantedEffectsPerLevelKeys"
	o = append(o, 0xba, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x50, 0x65, 0x72, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GrantedEffectsPerLevelKeys)))
	for za0007 := range z.GrantedEffectsPerLevelKeys {
		o = msgp.AppendInt(o, z.GrantedEffectsPerLevelKeys[za0007])
	}
	// string "Hash16"
	o = append(o, 0xa6, 0x48, 0x61, 0x73, 0x68, 0x31, 0x36)
	o = msgp.AppendInt(o, z.Hash16)
	// string "Hash32"
	o = append(o, 0xa6, 0x48, 0x61, 0x73, 0x68, 0x33, 0x32)
	o = msgp.AppendInt(o, z.Hash32)
	// string "HeistAddStatValue1"
	o = append(o, 0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x41, 0x64, 0x64, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x31)
	o = msgp.AppendInt(o, z.HeistAddStatValue1)
	// string "HeistAddStatValue2"
	o = append(o, 0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x41, 0x64, 0x64, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x32)
	o = msgp.AppendInt(o, z.HeistAddStatValue2)
	// string "HeistStatsKey0"
	o = append(o, 0xae, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x30)
	if z.HeistStatsKey0 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.HeistStatsKey0)
	}
	// string "HeistStatsKey1"
	o = append(o, 0xae, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	if z.HeistStatsKey1 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.HeistStatsKey1)
	}
	// string "HeistSubStatValue1"
	o = append(o, 0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x75, 0x62, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x31)
	o = msgp.AppendInt(o, z.HeistSubStatValue1)
	// string "HeistSubStatValue2"
	o = append(o, 0xb2, 0x48, 0x65, 0x69, 0x73, 0x74, 0x53, 0x75, 0x62, 0x53, 0x74, 0x61, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x32)
	o = msgp.AppendInt(o, z.HeistSubStatValue2)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "ImplicitTagsKeys"
	o = append(o, 0xb0, 0x49, 0x6d, 0x70, 0x6c, 0x69, 0x63, 0x69, 0x74, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ImplicitTagsKeys)))
	for za0008 := range z.ImplicitTagsKeys {
		o = msgp.AppendInt(o, z.ImplicitTagsKeys[za0008])
	}
	// string "InfluenceTypes"
	o = append(o, 0xae, 0x49, 0x6e, 0x66, 0x6c, 0x75, 0x65, 0x6e, 0x63, 0x65, 0x54, 0x79, 0x70, 0x65, 0x73)
	o = msgp.AppendInt(o, z.InfluenceTypes)
	// string "IsEssenceOnlyModifier"
	o = append(o, 0xb5, 0x49, 0x73, 0x45, 0x73, 0x73, 0x65, 0x6e, 0x63, 0x65, 0x4f, 0x6e, 0x6c, 0x79, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x69, 0x65, 0x72)
	o = msgp.AppendBool(o, z.IsEssenceOnlyModifier)
	// string "Level"
	o = append(o, 0xa5, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.Level)
	// string "MaxLevel"
	o = append(o, 0xa8, 0x4d, 0x61, 0x78, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.MaxLevel)
	// string "ModTypeKey"
	o = append(o, 0xaa, 0x4d, 0x6f, 0x64, 0x54, 0x79, 0x70, 0x65, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.ModTypeKey)
	// string "ModifyMapsAchievements"
	o = append(o, 0xb6, 0x4d, 0x6f, 0x64, 0x69, 0x66, 0x79, 0x4d, 0x61, 0x70, 0x73, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ModifyMapsAchievements)))
	for za0009 := range z.ModifyMapsAchievements {
		o = msgp.AppendInt(o, z.ModifyMapsAchievements[za0009])
	}
	// string "MonsterKillAchievements"
	o = append(o, 0xb7, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4b, 0x69, 0x6c, 0x6c, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.MonsterKillAchievements)))
	for za0010 := range z.MonsterKillAchievements {
		o = msgp.AppendInt(o, z.MonsterKillAchievements[za0010])
	}
	// string "MonsterMetadata"
	o = append(o, 0xaf, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4d, 0x65, 0x74, 0x61, 0x64, 0x61, 0x74, 0x61)
	o = msgp.AppendString(o, z.MonsterMetadata)
	// string "MonsterOnDeath"
	o = append(o, 0xae, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x4f, 0x6e, 0x44, 0x65, 0x61, 0x74, 0x68)
	o = msgp.AppendString(o, z.MonsterOnDeath)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "SpawnWeightTagsKeys"
	o = append(o, 0xb3, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SpawnWeightTagsKeys)))
	for za0011 := range z.SpawnWeightTagsKeys {
		o = msgp.AppendInt(o, z.SpawnWeightTagsKeys[za0011])
	}
	// string "SpawnWeightValues"
	o = append(o, 0xb1, 0x53, 0x70, 0x61, 0x77, 0x6e, 0x57, 0x65, 0x69, 0x67, 0x68, 0x74, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SpawnWeightValues)))
	for za0012 := range z.SpawnWeightValues {
		o = msgp.AppendInt(o, z.SpawnWeightValues[za0012])
	}
	// string "Stat1Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat1Max)
	// string "Stat1Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x31, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat1Min)
	// string "Stat2Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat2Max)
	// string "Stat2Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x32, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat2Min)
	// string "Stat3Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x33, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat3Max)
	// string "Stat3Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x33, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat3Min)
	// string "Stat4Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x34, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat4Max)
	// string "Stat4Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x34, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat4Min)
	// string "Stat5Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x35, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat5Max)
	// string "Stat5Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x35, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat5Min)
	// string "Stat6Max"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x36, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.Stat6Max)
	// string "Stat6Min"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x36, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.Stat6Min)
	// string "StatsKey1"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	if z.StatsKey1 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.StatsKey1)
	}
	// string "StatsKey2"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x32)
	if z.StatsKey2 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.StatsKey2)
	}
	// string "StatsKey3"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x33)
	if z.StatsKey3 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.StatsKey3)
	}
	// string "StatsKey4"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x34)
	if z.StatsKey4 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.StatsKey4)
	}
	// string "StatsKey5"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x35)
	if z.StatsKey5 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.StatsKey5)
	}
	// string "StatsKey6"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x36)
	if z.StatsKey6 == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.StatsKey6)
	}
	// string "TagsKeys"
	o = append(o, 0xa8, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TagsKeys)))
	for za0013 := range z.TagsKeys {
		o = msgp.AppendInt(o, z.TagsKeys[za0013])
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Mod) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AchievementItemsKey":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AchievementItemsKey")
				return
			}
			if cap(z.AchievementItemsKey) >= int(zb0002) {
				z.AchievementItemsKey = (z.AchievementItemsKey)[:zb0002]
			} else {
				z.AchievementItemsKey = make([]interface{}, zb0002)
			}
			for za0001 := range z.AchievementItemsKey {
				z.AchievementItemsKey[za0001], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AchievementItemsKey", za0001)
					return
				}
			}
		case "ArchnemesisMinionMod":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.ArchnemesisMinionMod = nil
			} else {
				if z.ArchnemesisMinionMod == nil {
					z.ArchnemesisMinionMod = new(int)
				}
				*z.ArchnemesisMinionMod, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ArchnemesisMinionMod")
					return
				}
			}
		case "BuffTemplate":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BuffTemplate = nil
			} else {
				if z.BuffTemplate == nil {
					z.BuffTemplate = new(int)
				}
				*z.BuffTemplate, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BuffTemplate")
					return
				}
			}
		case "ChestModType":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ChestModType")
				return
			}
			if cap(z.ChestModType) >= int(zb0003) {
				z.ChestModType = (z.ChestModType)[:zb0003]
			} else {
				z.ChestModType = make([]int, zb0003)
			}
			for za0002 := range z.ChestModType {
				z.ChestModType[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ChestModType", za0002)
					return
				}
			}
		case "CorrectGroup":
			z.CorrectGroup, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CorrectGroup")
				return
			}
		case "CraftingItemClassRestrictions":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CraftingItemClassRestrictions")
				return
			}
			if cap(z.CraftingItemClassRestrictions) >= int(zb0004) {
				z.CraftingItemClassRestrictions = (z.CraftingItemClassRestrictions)[:zb0004]
			} else {
				z.CraftingItemClassRestrictions = make([]int, zb0004)
			}
			for za0003 := range z.CraftingItemClassRestrictions {
				z.CraftingItemClassRestrictions[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "CraftingItemClassRestrictions", za0003)
					return
				}
			}
		case "Domain":
			z.Domain, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Domain")
				return
			}
		case "FullAreaClearAchievementItemsKey":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "FullAreaClearAchievementItemsKey")
				return
			}
			if cap(z.FullAreaClearAchievementItemsKey) >= int(zb0005) {
				z.FullAreaClearAchievementItemsKey = (z.FullAreaClearAchievementItemsKey)[:zb0005]
			} else {
				z.FullAreaClearAchievementItemsKey = make([]interface{}, zb0005)
			}
			for za0004 := range z.FullAreaClearAchievementItemsKey {
				z.FullAreaClearAchievementItemsKey[za0004], bts, err = msgp.ReadIntfBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "FullAreaClearAchievementItemsKey", za0004)
					return
				}
			}
		case "GenerationType":
			z.GenerationType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GenerationType")
				return
			}
		case "GenerationWeightTagsKeys":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GenerationWeightTagsKeys")
				return
			}
			if cap(z.GenerationWeightTagsKeys) >= int(zb0006) {
				z.GenerationWeightTagsKeys = (z.GenerationWeightTagsKeys)[:zb0006]
			} else {
				z.GenerationWeightTagsKeys = make([]int, zb0006)
			}
			for za0005 := range z.GenerationWeightTagsKeys {
				z.GenerationWeightTagsKeys[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenerationWeightTagsKeys", za0005)
					return
				}
			}
		case "GenerationWeightValues":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GenerationWeightValues")
				return
			}
			if cap(z.GenerationWeightValues) >= int(zb0007) {
				z.GenerationWeightValues = (z.GenerationWeightValues)[:zb0007]
			} else {
				z.GenerationWeightValues = make([]int, zb0007)
			}
			for za0006 := range z.GenerationWeightValues {
				z.GenerationWeightValues[za0006], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GenerationWeightValues", za0006)
					return
				}
			}
		case "GrantedEffectsPerLevelKeys":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectsPerLevelKeys")
				return
			}
			if cap(z.GrantedEffectsPerLevelKeys) >= int(zb0008) {
				z.GrantedEffectsPerLevelKeys = (z.GrantedEffectsPerLevelKeys)[:zb0008]
			} else {
				z.GrantedEffectsPerLevelKeys = make([]int, zb0008)
			}
			for za0007 := range z.GrantedEffectsPerLevelKeys {
				z.GrantedEffectsPerLevelKeys[za0007], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffectsPerLevelKeys", za0007)
					return
				}
			}
		case "Hash16":
			z.Hash16, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hash16")
				return
			}
		case "Hash32":
			z.Hash32, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hash32")
				return
			}
		case "HeistAddStatValue1":
			z.HeistAddStatValue1, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HeistAddStatValue1")
				return
			}
		case "HeistAddStatValue2":
			z.HeistAddStatValue2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HeistAddStatValue2")
				return
			}
		case "HeistStatsKey0":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HeistStatsKey0 = nil
			} else {
				if z.HeistStatsKey0 == nil {
					z.HeistStatsKey0 = new(int)
				}
				*z.HeistStatsKey0, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HeistStatsKey0")
					return
				}
			}
		case "HeistStatsKey1":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HeistStatsKey1 = nil
			} else {
				if z.HeistStatsKey1 == nil {
					z.HeistStatsKey1 = new(int)
				}
				*z.HeistStatsKey1, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HeistStatsKey1")
					return
				}
			}
		case "HeistSubStatValue1":
			z.HeistSubStatValue1, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HeistSubStatValue1")
				return
			}
		case "HeistSubStatValue2":
			z.HeistSubStatValue2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "HeistSubStatValue2")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "ImplicitTagsKeys":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ImplicitTagsKeys")
				return
			}
			if cap(z.ImplicitTagsKeys) >= int(zb0009) {
				z.ImplicitTagsKeys = (z.ImplicitTagsKeys)[:zb0009]
			} else {
				z.ImplicitTagsKeys = make([]int, zb0009)
			}
			for za0008 := range z.ImplicitTagsKeys {
				z.ImplicitTagsKeys[za0008], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ImplicitTagsKeys", za0008)
					return
				}
			}
		case "InfluenceTypes":
			z.InfluenceTypes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "InfluenceTypes")
				return
			}
		case "IsEssenceOnlyModifier":
			z.IsEssenceOnlyModifier, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsEssenceOnlyModifier")
				return
			}
		case "Level":
			z.Level, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Level")
				return
			}
		case "MaxLevel":
			z.MaxLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxLevel")
				return
			}
		case "ModTypeKey":
			z.ModTypeKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModTypeKey")
				return
			}
		case "ModifyMapsAchievements":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModifyMapsAchievements")
				return
			}
			if cap(z.ModifyMapsAchievements) >= int(zb0010) {
				z.ModifyMapsAchievements = (z.ModifyMapsAchievements)[:zb0010]
			} else {
				z.ModifyMapsAchievements = make([]int, zb0010)
			}
			for za0009 := range z.ModifyMapsAchievements {
				z.ModifyMapsAchievements[za0009], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ModifyMapsAchievements", za0009)
					return
				}
			}
		case "MonsterKillAchievements":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MonsterKillAchievements")
				return
			}
			if cap(z.MonsterKillAchievements) >= int(zb0011) {
				z.MonsterKillAchievements = (z.MonsterKillAchievements)[:zb0011]
			} else {
				z.MonsterKillAchievements = make([]int, zb0011)
			}
			for za0010 := range z.MonsterKillAchievements {
				z.MonsterKillAchievements[za0010], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MonsterKillAchievements", za0010)
					return
				}
			}
		case "MonsterMetadata":
			z.MonsterMetadata, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MonsterMetadata")
				return
			}
		case "MonsterOnDeath":
			z.MonsterOnDeath, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MonsterOnDeath")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "SpawnWeightTagsKeys":
			var zb0012 uint32
			zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeightTagsKeys")
				return
			}
			if cap(z.SpawnWeightTagsKeys) >= int(zb0012) {
				z.SpawnWeightTagsKeys = (z.SpawnWeightTagsKeys)[:zb0012]
			} else {
				z.SpawnWeightTagsKeys = make([]int, zb0012)
			}
			for za0011 := range z.SpawnWeightTagsKeys {
				z.SpawnWeightTagsKeys[za0011], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SpawnWeightTagsKeys", za0011)
					return
				}
			}
		case "SpawnWeightValues":
			var zb0013 uint32
			zb0013, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpawnWeightValues")
				return
			}
			if cap(z.SpawnWeightValues) >= int(zb0013) {
				z.SpawnWeightValues = (z.SpawnWeightValues)[:zb0013]
			} else {
				z.SpawnWeightValues = make([]int, zb0013)
			}
			for za0012 := range z.SpawnWeightValues {
				z.SpawnWeightValues[za0012], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SpawnWeightValues", za0012)
					return
				}
			}
		case "Stat1Max":
			z.Stat1Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Max")
				return
			}
		case "Stat1Min":
			z.Stat1Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Min")
				return
			}
		case "Stat2Max":
			z.Stat2Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat2Max")
				return
			}
		case "Stat2Min":
			z.Stat2Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat2Min")
				return
			}
		case "Stat3Max":
			z.Stat3Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat3Max")
				return
			}
		case "Stat3Min":
			z.Stat3Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat3Min")
				return
			}
		case "Stat4Max":
			z.Stat4Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat4Max")
				return
			}
		case "Stat4Min":
			z.Stat4Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat4Min")
				return
			}
		case "Stat5Max":
			z.Stat5Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat5Max")
				return
			}
		case "Stat5Min":
			z.Stat5Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat5Min")
				return
			}
		case "Stat6Max":
			z.Stat6Max, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat6Max")
				return
			}
		case "Stat6Min":
			z.Stat6Min, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat6Min")
				return
			}
		case "StatsKey1":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StatsKey1 = nil
			} else {
				if z.StatsKey1 == nil {
					z.StatsKey1 = new(int)
				}
				*z.StatsKey1, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKey1")
					return
				}
			}
		case "StatsKey2":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StatsKey2 = nil
			} else {
				if z.StatsKey2 == nil {
					z.StatsKey2 = new(int)
				}
				*z.StatsKey2, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKey2")
					return
				}
			}
		case "StatsKey3":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StatsKey3 = nil
			} else {
				if z.StatsKey3 == nil {
					z.StatsKey3 = new(int)
				}
				*z.StatsKey3, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKey3")
					return
				}
			}
		case "StatsKey4":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StatsKey4 = nil
			} else {
				if z.StatsKey4 == nil {
					z.StatsKey4 = new(int)
				}
				*z.StatsKey4, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKey4")
					return
				}
			}
		case "StatsKey5":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StatsKey5 = nil
			} else {
				if z.StatsKey5 == nil {
					z.StatsKey5 = new(int)
				}
				*z.StatsKey5, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKey5")
					return
				}
			}
		case "StatsKey6":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.StatsKey6 = nil
			} else {
				if z.StatsKey6 == nil {
					z.StatsKey6 = new(int)
				}
				*z.StatsKey6, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "StatsKey6")
					return
				}
			}
		case "TagsKeys":
			var zb0014 uint32
			zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TagsKeys")
				return
			}
			if cap(z.TagsKeys) >= int(zb0014) {
				z.TagsKeys = (z.TagsKeys)[:zb0014]
			} else {
				z.TagsKeys = make([]int, zb0014)
			}
			for za0013 := range z.TagsKeys {
				z.TagsKeys[za0013], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TagsKeys", za0013)
					return
				}
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Mod) Msgsize() (s int) {
	s = 3 + 20 + msgp.ArrayHeaderSize
	for za0001 := range z.AchievementItemsKey {
		s += msgp.GuessSize(z.AchievementItemsKey[za0001])
	}
	s += 21
	if z.ArchnemesisMinionMod == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 13
	if z.BuffTemplate == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 13 + msgp.ArrayHeaderSize + (len(z.ChestModType) * (msgp.IntSize)) + 13 + msgp.StringPrefixSize + len(z.CorrectGroup) + 30 + msgp.ArrayHeaderSize + (len(z.CraftingItemClassRestrictions) * (msgp.IntSize)) + 7 + msgp.IntSize + 34 + msgp.ArrayHeaderSize
	for za0004 := range z.FullAreaClearAchievementItemsKey {
		s += msgp.GuessSize(z.FullAreaClearAchievementItemsKey[za0004])
	}
	s += 15 + msgp.IntSize + 25 + msgp.ArrayHeaderSize + (len(z.GenerationWeightTagsKeys) * (msgp.IntSize)) + 23 + msgp.ArrayHeaderSize + (len(z.GenerationWeightValues) * (msgp.IntSize)) + 27 + msgp.ArrayHeaderSize + (len(z.GrantedEffectsPerLevelKeys) * (msgp.IntSize)) + 7 + msgp.IntSize + 7 + msgp.IntSize + 19 + msgp.IntSize + 19 + msgp.IntSize + 15
	if z.HeistStatsKey0 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15
	if z.HeistStatsKey1 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19 + msgp.IntSize + 19 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.ID) + 17 + msgp.ArrayHeaderSize + (len(z.ImplicitTagsKeys) * (msgp.IntSize)) + 15 + msgp.IntSize + 22 + msgp.BoolSize + 6 + msgp.IntSize + 9 + msgp.IntSize + 11 + msgp.IntSize + 23 + msgp.ArrayHeaderSize + (len(z.ModifyMapsAchievements) * (msgp.IntSize)) + 24 + msgp.ArrayHeaderSize + (len(z.MonsterKillAchievements) * (msgp.IntSize)) + 16 + msgp.StringPrefixSize + len(z.MonsterMetadata) + 15 + msgp.StringPrefixSize + len(z.MonsterOnDeath) + 5 + msgp.StringPrefixSize + len(z.Name) + 20 + msgp.ArrayHeaderSize + (len(z.SpawnWeightTagsKeys) * (msgp.IntSize)) + 18 + msgp.ArrayHeaderSize + (len(z.SpawnWeightValues) * (msgp.IntSize)) + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 10
	if z.StatsKey1 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.StatsKey2 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.StatsKey3 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.StatsKey4 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.StatsKey5 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10
	if z.StatsKey6 == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 9 + msgp.ArrayHeaderSize + (len(z.TagsKeys) * (msgp.IntSize)) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MonsterMapBossDifficulty) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MapLevel":
			z.MapLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MapLevel")
				return
			}
		case "Stat1Value":
			z.Stat1Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Value")
				return
			}
		case "Stat2Value":
			z.Stat2Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat2Value")
				return
			}
		case "Stat3Value":
			z.Stat3Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat3Value")
				return
			}
		case "Stat4Value":
			z.Stat4Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat4Value")
				return
			}
		case "Stat5Value":
			z.Stat5Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat5Value")
				return
			}
		case "StatsKey1":
			z.StatsKey1, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey1")
				return
			}
		case "StatsKey2":
			z.StatsKey2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey2")
				return
			}
		case "StatsKey3":
			z.StatsKey3, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey3")
				return
			}
		case "StatsKey4":
			z.StatsKey4, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey4")
				return
			}
		case "StatsKey5":
			z.StatsKey5, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey5")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MonsterMapBossDifficulty) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 12
	// write "MapLevel"
	err = en.Append(0x8c, 0xa8, 0x4d, 0x61, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MapLevel)
	if err != nil {
		err = msgp.WrapError(err, "MapLevel")
		return
	}
	// write "Stat1Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x31, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Value")
		return
	}
	// write "Stat2Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat2Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat2Value")
		return
	}
	// write "Stat3Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x33, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat3Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat3Value")
		return
	}
	// write "Stat4Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat4Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat4Value")
		return
	}
	// write "Stat5Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x35, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat5Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat5Value")
		return
	}
	// write "StatsKey1"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey1)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey1")
		return
	}
	// write "StatsKey2"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey2)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey2")
		return
	}
	// write "StatsKey3"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey3)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey3")
		return
	}
	// write "StatsKey4"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey4)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey4")
		return
	}
	// write "StatsKey5"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x35)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey5)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey5")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MonsterMapBossDifficulty) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 12
	// string "MapLevel"
	o = append(o, 0x8c, 0xa8, 0x4d, 0x61, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.MapLevel)
	// string "Stat1Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x31, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat1Value)
	// string "Stat2Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat2Value)
	// string "Stat3Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x33, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat3Value)
	// string "Stat4Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat4Value)
	// string "Stat5Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x35, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat5Value)
	// string "StatsKey1"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	o = msgp.AppendInt(o, z.StatsKey1)
	// string "StatsKey2"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x32)
	o = msgp.AppendInt(o, z.StatsKey2)
	// string "StatsKey3"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x33)
	o = msgp.AppendInt(o, z.StatsKey3)
	// string "StatsKey4"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x34)
	o = msgp.AppendInt(o, z.StatsKey4)
	// string "StatsKey5"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x35)
	o = msgp.AppendInt(o, z.StatsKey5)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MonsterMapBossDifficulty) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MapLevel":
			z.MapLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MapLevel")
				return
			}
		case "Stat1Value":
			z.Stat1Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Value")
				return
			}
		case "Stat2Value":
			z.Stat2Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat2Value")
				return
			}
		case "Stat3Value":
			z.Stat3Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat3Value")
				return
			}
		case "Stat4Value":
			z.Stat4Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat4Value")
				return
			}
		case "Stat5Value":
			z.Stat5Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat5Value")
				return
			}
		case "StatsKey1":
			z.StatsKey1, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey1")
				return
			}
		case "StatsKey2":
			z.StatsKey2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey2")
				return
			}
		case "StatsKey3":
			z.StatsKey3, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey3")
				return
			}
		case "StatsKey4":
			z.StatsKey4, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey4")
				return
			}
		case "StatsKey5":
			z.StatsKey5, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey5")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MonsterMapBossDifficulty) Msgsize() (s int) {
	s = 1 + 9 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 10 + msgp.IntSize + 10 + msgp.IntSize + 10 + msgp.IntSize + 10 + msgp.IntSize + 10 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MonsterMapDifficulty) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MapLevel":
			z.MapLevel, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MapLevel")
				return
			}
		case "Stat1Value":
			z.Stat1Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat1Value")
				return
			}
		case "Stat2Value":
			z.Stat2Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat2Value")
				return
			}
		case "Stat3Value":
			z.Stat3Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat3Value")
				return
			}
		case "Stat4Value":
			z.Stat4Value, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Stat4Value")
				return
			}
		case "StatsKey1":
			z.StatsKey1, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey1")
				return
			}
		case "StatsKey2":
			z.StatsKey2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey2")
				return
			}
		case "StatsKey3":
			z.StatsKey3, err = dc.ReadIntf()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey3")
				return
			}
		case "StatsKey4":
			z.StatsKey4, err = dc.ReadIntf()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey4")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MonsterMapDifficulty) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 10
	// write "MapLevel"
	err = en.Append(0x8a, 0xa8, 0x4d, 0x61, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MapLevel)
	if err != nil {
		err = msgp.WrapError(err, "MapLevel")
		return
	}
	// write "Stat1Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x31, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat1Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat1Value")
		return
	}
	// write "Stat2Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat2Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat2Value")
		return
	}
	// write "Stat3Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x33, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat3Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat3Value")
		return
	}
	// write "Stat4Value"
	err = en.Append(0xaa, 0x53, 0x74, 0x61, 0x74, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Stat4Value)
	if err != nil {
		err = msgp.WrapError(err, "Stat4Value")
		return
	}
	// write "StatsKey1"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey1)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey1")
		return
	}
	// write "StatsKey2"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey2)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey2")
		return
	}
	// write "StatsKey3"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x33)
	if err != nil {
		return
	}
	err = en.WriteIntf(z.StatsKey3)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey3")
		return
	}
	// write "StatsKey4"
	err = en.Append(0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x34)
	if err != nil {
		return
	}
	err = en.WriteIntf(z.StatsKey4)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey4")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MonsterMapDifficulty) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 10
	// string "MapLevel"
	o = append(o, 0x8a, 0xa8, 0x4d, 0x61, 0x70, 0x4c, 0x65, 0x76, 0x65, 0x6c)
	o = msgp.AppendInt(o, z.MapLevel)
	// string "Stat1Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x31, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat1Value)
	// string "Stat2Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat2Value)
	// string "Stat3Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x33, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat3Value)
	// string "Stat4Value"
	o = append(o, 0xaa, 0x53, 0x74, 0x61, 0x74, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65)
	o = msgp.AppendInt(o, z.Stat4Value)
	// string "StatsKey1"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x31)
	o = msgp.AppendInt(o, z.StatsKey1)
	// string "StatsKey2"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x32)
	o = msgp.AppendInt(o, z.StatsKey2)
	// string "StatsKey3"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x33)
	o, err = msgp.AppendIntf(o, z.StatsKey3)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey3")
		return
	}
	// string "StatsKey4"
	o = append(o, 0xa9, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x34)
	o, err = msgp.AppendIntf(o, z.StatsKey4)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey4")
		return
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MonsterMapDifficulty) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MapLevel":
			z.MapLevel, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MapLevel")
				return
			}
		case "Stat1Value":
			z.Stat1Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1Value")
				return
			}
		case "Stat2Value":
			z.Stat2Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat2Value")
				return
			}
		case "Stat3Value":
			z.Stat3Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat3Value")
				return
			}
		case "Stat4Value":
			z.Stat4Value, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat4Value")
				return
			}
		case "StatsKey1":
			z.StatsKey1, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey1")
				return
			}
		case "StatsKey2":
			z.StatsKey2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey2")
				return
			}
		case "StatsKey3":
			z.StatsKey3, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey3")
				return
			}
		case "StatsKey4":
			z.StatsKey4, bts, err = msgp.ReadIntfBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey4")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MonsterMapDifficulty) Msgsize() (s int) {
	s = 1 + 9 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 11 + msgp.IntSize + 10 + msgp.IntSize + 10 + msgp.IntSize + 10 + msgp.GuessSize(z.StatsKey3) + 10 + msgp.GuessSize(z.StatsKey4) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MonsterVariety) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ACTFiles":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ACTFiles")
				return
			}
			if cap(z.ACTFiles) >= int(zb0002) {
				z.ACTFiles = (z.ACTFiles)[:zb0002]
			} else {
				z.ACTFiles = make([]string, zb0002)
			}
			for za0001 := range z.ACTFiles {
				z.ACTFiles[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "ACTFiles", za0001)
					return
				}
			}
		case "AISFile":
			z.AISFile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "AISFile")
				return
			}
		case "AOFiles":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AOFiles")
				return
			}
			if cap(z.AOFiles) >= int(zb0003) {
				z.AOFiles = (z.AOFiles)[:zb0003]
			} else {
				z.AOFiles = make([]string, zb0003)
			}
			for za0002 := range z.AOFiles {
				z.AOFiles[za0002], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "AOFiles", za0002)
					return
				}
			}
		case "AttackSpeed":
			z.AttackSpeed, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "AttackSpeed")
				return
			}
		case "BackItemVisualIdentityKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "BackItemVisualIdentityKey")
					return
				}
				z.BackItemVisualIdentityKey = nil
			} else {
				if z.BackItemVisualIdentityKey == nil {
					z.BackItemVisualIdentityKey = new(int)
				}
				*z.BackItemVisualIdentityKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "BackItemVisualIdentityKey")
					return
				}
			}
		case "BaseMonsterTypeIndex":
			z.BaseMonsterTypeIndex, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "BaseMonsterTypeIndex")
				return
			}
		case "CriticalStrikeChance":
			z.CriticalStrikeChance, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "CriticalStrikeChance")
				return
			}
		case "DamageMultiplier":
			z.DamageMultiplier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DamageMultiplier")
				return
			}
		case "EPKFile":
			z.EPKFile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "EPKFile")
				return
			}
		case "EndgameModsKeys":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "EndgameModsKeys")
				return
			}
			if cap(z.EndgameModsKeys) >= int(zb0004) {
				z.EndgameModsKeys = (z.EndgameModsKeys)[:zb0004]
			} else {
				z.EndgameModsKeys = make([]int, zb0004)
			}
			for za0003 := range z.EndgameModsKeys {
				z.EndgameModsKeys[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "EndgameModsKeys", za0003)
					return
				}
			}
		case "ExperienceMultiplier":
			z.ExperienceMultiplier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ExperienceMultiplier")
				return
			}
		case "GrantedEffectsKeys":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectsKeys")
				return
			}
			if cap(z.GrantedEffectsKeys) >= int(zb0005) {
				z.GrantedEffectsKeys = (z.GrantedEffectsKeys)[:zb0005]
			} else {
				z.GrantedEffectsKeys = make([]int, zb0005)
			}
			for za0004 := range z.GrantedEffectsKeys {
				z.GrantedEffectsKeys[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffectsKeys", za0004)
					return
				}
			}
		case "HelmetItemVisualIdentityKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HelmetItemVisualIdentityKey")
					return
				}
				z.HelmetItemVisualIdentityKey = nil
			} else {
				if z.HelmetItemVisualIdentityKey == nil {
					z.HelmetItemVisualIdentityKey = new(int)
				}
				*z.HelmetItemVisualIdentityKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "HelmetItemVisualIdentityKey")
					return
				}
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "KillRareAchievementItemsKeys":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KillRareAchievementItemsKeys")
				return
			}
			if cap(z.KillRareAchievementItemsKeys) >= int(zb0006) {
				z.KillRareAchievementItemsKeys = (z.KillRareAchievementItemsKeys)[:zb0006]
			} else {
				z.KillRareAchievementItemsKeys = make([]int, zb0006)
			}
			for za0005 := range z.KillRareAchievementItemsKeys {
				z.KillRareAchievementItemsKeys[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "KillRareAchievementItemsKeys", za0005)
					return
				}
			}
		case "KillSpecificMonsterCountAchievementItemsKeys":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "KillSpecificMonsterCountAchievementItemsKeys")
				return
			}
			if cap(z.KillSpecificMonsterCountAchievementItemsKeys) >= int(zb0007) {
				z.KillSpecificMonsterCountAchievementItemsKeys = (z.KillSpecificMonsterCountAchievementItemsKeys)[:zb0007]
			} else {
				z.KillSpecificMonsterCountAchievementItemsKeys = make([]int, zb0007)
			}
			for za0006 := range z.KillSpecificMonsterCountAchievementItemsKeys {
				z.KillSpecificMonsterCountAchievementItemsKeys[za0006], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "KillSpecificMonsterCountAchievementItemsKeys", za0006)
					return
				}
			}
		case "KillWhileOnslaughtIsActiveAchievementItemsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "KillWhileOnslaughtIsActiveAchievementItemsKey")
					return
				}
				z.KillWhileOnslaughtIsActiveAchievementItemsKey = nil
			} else {
				if z.KillWhileOnslaughtIsActiveAchievementItemsKey == nil {
					z.KillWhileOnslaughtIsActiveAchievementItemsKey = new(int)
				}
				*z.KillWhileOnslaughtIsActiveAchievementItemsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "KillWhileOnslaughtIsActiveAchievementItemsKey")
					return
				}
			}
		case "KillWhileTalismanIsActiveAchievementItemsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "KillWhileTalismanIsActiveAchievementItemsKey")
					return
				}
				z.KillWhileTalismanIsActiveAchievementItemsKey = nil
			} else {
				if z.KillWhileTalismanIsActiveAchievementItemsKey == nil {
					z.KillWhileTalismanIsActiveAchievementItemsKey = new(int)
				}
				*z.KillWhileTalismanIsActiveAchievementItemsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "KillWhileTalismanIsActiveAchievementItemsKey")
					return
				}
			}
		case "LifeMultiplier":
			z.LifeMultiplier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "LifeMultiplier")
				return
			}
		case "MainHandItemClassesKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MainHandItemClassesKey")
					return
				}
				z.MainHandItemClassesKey = nil
			} else {
				if z.MainHandItemClassesKey == nil {
					z.MainHandItemClassesKey = new(int)
				}
				*z.MainHandItemClassesKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MainHandItemClassesKey")
					return
				}
			}
		case "MaximumAttackDistance":
			z.MaximumAttackDistance, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaximumAttackDistance")
				return
			}
		case "MinimumAttackDistance":
			z.MinimumAttackDistance, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MinimumAttackDistance")
				return
			}
		case "ModelSizeMultiplier":
			z.ModelSizeMultiplier, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ModelSizeMultiplier")
				return
			}
		case "ModsKeys":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ModsKeys")
				return
			}
			if cap(z.ModsKeys) >= int(zb0008) {
				z.ModsKeys = (z.ModsKeys)[:zb0008]
			} else {
				z.ModsKeys = make([]int, zb0008)
			}
			for za0007 := range z.ModsKeys {
				z.ModsKeys[za0007], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ModsKeys", za0007)
					return
				}
			}
		case "ModsKeys2":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ModsKeys2")
				return
			}
			if cap(z.ModsKeys2) >= int(zb0009) {
				z.ModsKeys2 = (z.ModsKeys2)[:zb0009]
			} else {
				z.ModsKeys2 = make([]int, zb0009)
			}
			for za0008 := range z.ModsKeys2 {
				z.ModsKeys2[za0008], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ModsKeys2", za0008)
					return
				}
			}
		case "MonsterArmoursKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MonsterArmoursKey")
					return
				}
				z.MonsterArmoursKey = nil
			} else {
				if z.MonsterArmoursKey == nil {
					z.MonsterArmoursKey = new(int)
				}
				*z.MonsterArmoursKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MonsterArmoursKey")
					return
				}
			}
		case "MonsterConditionalEffectPacksKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MonsterConditionalEffectPacksKey")
					return
				}
				z.MonsterConditionalEffectPacksKey = nil
			} else {
				if z.MonsterConditionalEffectPacksKey == nil {
					z.MonsterConditionalEffectPacksKey = new(int)
				}
				*z.MonsterConditionalEffectPacksKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MonsterConditionalEffectPacksKey")
					return
				}
			}
		case "MonsterSegmentsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MonsterSegmentsKey")
					return
				}
				z.MonsterSegmentsKey = nil
			} else {
				if z.MonsterSegmentsKey == nil {
					z.MonsterSegmentsKey = new(int)
				}
				*z.MonsterSegmentsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MonsterSegmentsKey")
					return
				}
			}
		case "MonsterTypesKey":
			z.MonsterTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MonsterTypesKey")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "ObjectSize":
			z.ObjectSize, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "ObjectSize")
				return
			}
		case "OffHandItemClassesKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OffHandItemClassesKey")
					return
				}
				z.OffHandItemClassesKey = nil
			} else {
				if z.OffHandItemClassesKey == nil {
					z.OffHandItemClassesKey = new(int)
				}
				*z.OffHandItemClassesKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OffHandItemClassesKey")
					return
				}
			}
		case "Part1ModsKeys":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Part1ModsKeys")
				return
			}
			if cap(z.Part1ModsKeys) >= int(zb0010) {
				z.Part1ModsKeys = (z.Part1ModsKeys)[:zb0010]
			} else {
				z.Part1ModsKeys = make([]int, zb0010)
			}
			for za0009 := range z.Part1ModsKeys {
				z.Part1ModsKeys[za0009], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Part1ModsKeys", za0009)
					return
				}
			}
		case "Part2ModsKeys":
			var zb0011 uint32
			zb0011, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Part2ModsKeys")
				return
			}
			if cap(z.Part2ModsKeys) >= int(zb0011) {
				z.Part2ModsKeys = (z.Part2ModsKeys)[:zb0011]
			} else {
				z.Part2ModsKeys = make([]int, zb0011)
			}
			for za0010 := range z.Part2ModsKeys {
				z.Part2ModsKeys[za0010], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Part2ModsKeys", za0010)
					return
				}
			}
		case "SinkAnimationAOFile":
			z.SinkAnimationAOFile, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SinkAnimationAOFile")
				return
			}
		case "SpecialModsKeys":
			var zb0012 uint32
			zb0012, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SpecialModsKeys")
				return
			}
			if cap(z.SpecialModsKeys) >= int(zb0012) {
				z.SpecialModsKeys = (z.SpecialModsKeys)[:zb0012]
			} else {
				z.SpecialModsKeys = make([]int, zb0012)
			}
			for za0011 := range z.SpecialModsKeys {
				z.SpecialModsKeys[za0011], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SpecialModsKeys", za0011)
					return
				}
			}
		case "Stance":
			{
				var zb0013 string
				zb0013, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Stance")
					return
				}
				z.Stance = MonsterVarietyStance(zb0013)
			}
		case "TagsKeys":
			var zb0014 uint32
			zb0014, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "TagsKeys")
				return
			}
			if cap(z.TagsKeys) >= int(zb0014) {
				z.TagsKeys = (z.TagsKeys)[:zb0014]
			} else {
				z.TagsKeys = make([]int, zb0014)
			}
			for za0012 := range z.TagsKeys {
				z.TagsKeys[za0012], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "TagsKeys", za0012)
					return
				}
			}
		case "Weapon1ItemVisualIdentityKeys":
			var zb0015 uint32
			zb0015, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Weapon1ItemVisualIdentityKeys")
				return
			}
			if cap(z.Weapon1ItemVisualIdentityKeys) >= int(zb0015) {
				z.Weapon1ItemVisualIdentityKeys = (z.Weapon1ItemVisualIdentityKeys)[:zb0015]
			} else {
				z.Weapon1ItemVisualIdentityKeys = make([]int, zb0015)
			}
			for za0013 := range z.Weapon1ItemVisualIdentityKeys {
				z.Weapon1ItemVisualIdentityKeys[za0013], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Weapon1ItemVisualIdentityKeys", za0013)
					return
				}
			}
		case "Weapon2ItemVisualIdentityKeys":
			var zb0016 uint32
			zb0016, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Weapon2ItemVisualIdentityKeys")
				return
			}
			if cap(z.Weapon2ItemVisualIdentityKeys) >= int(zb0016) {
				z.Weapon2ItemVisualIdentityKeys = (z.Weapon2ItemVisualIdentityKeys)[:zb0016]
			} else {
				z.Weapon2ItemVisualIdentityKeys = make([]int, zb0016)
			}
			for za0014 := range z.Weapon2ItemVisualIdentityKeys {
				z.Weapon2ItemVisualIdentityKeys[za0014], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Weapon2ItemVisualIdentityKeys", za0014)
					return
				}
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *MonsterVariety) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 41
	// write "ACTFiles"
	err = en.Append(0xde, 0x0, 0x29, 0xa8, 0x41, 0x43, 0x54, 0x46, 0x69, 0x6c, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ACTFiles)))
	if err != nil {
		err = msgp.WrapError(err, "ACTFiles")
		return
	}
	for za0001 := range z.ACTFiles {
		err = en.WriteString(z.ACTFiles[za0001])
		if err != nil {
			err = msgp.WrapError(err, "ACTFiles", za0001)
			return
		}
	}
	// write "AISFile"
	err = en.Append(0xa7, 0x41, 0x49, 0x53, 0x46, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.AISFile)
	if err != nil {
		err = msgp.WrapError(err, "AISFile")
		return
	}
	// write "AOFiles"
	err = en.Append(0xa7, 0x41, 0x4f, 0x46, 0x69, 0x6c, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AOFiles)))
	if err != nil {
		err = msgp.WrapError(err, "AOFiles")
		return
	}
	for za0002 := range z.AOFiles {
		err = en.WriteString(z.AOFiles[za0002])
		if err != nil {
			err = msgp.WrapError(err, "AOFiles", za0002)
			return
		}
	}
	// write "AttackSpeed"
	err = en.Append(0xab, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x53, 0x70, 0x65, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.AttackSpeed)
	if err != nil {
		err = msgp.WrapError(err, "AttackSpeed")
		return
	}
	// write "BackItemVisualIdentityKey"
	err = en.Append(0xb9, 0x42, 0x61, 0x63, 0x6b, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.BackItemVisualIdentityKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.BackItemVisualIdentityKey)
		if err != nil {
			err = msgp.WrapError(err, "BackItemVisualIdentityKey")
			return
		}
	}
	// write "BaseMonsterTypeIndex"
	err = en.Append(0xb4, 0x42, 0x61, 0x73, 0x65, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteString(z.BaseMonsterTypeIndex)
	if err != nil {
		err = msgp.WrapError(err, "BaseMonsterTypeIndex")
		return
	}
	// write "CriticalStrikeChance"
	err = en.Append(0xb4, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x53, 0x74, 0x72, 0x69, 0x6b, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.CriticalStrikeChance)
	if err != nil {
		err = msgp.WrapError(err, "CriticalStrikeChance")
		return
	}
	// write "DamageMultiplier"
	err = en.Append(0xb0, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DamageMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "DamageMultiplier")
		return
	}
	// write "EPKFile"
	err = en.Append(0xa7, 0x45, 0x50, 0x4b, 0x46, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.EPKFile)
	if err != nil {
		err = msgp.WrapError(err, "EPKFile")
		return
	}
	// write "EndgameModsKeys"
	err = en.Append(0xaf, 0x45, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.EndgameModsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "EndgameModsKeys")
		return
	}
	for za0003 := range z.EndgameModsKeys {
		err = en.WriteInt(z.EndgameModsKeys[za0003])
		if err != nil {
			err = msgp.WrapError(err, "EndgameModsKeys", za0003)
			return
		}
	}
	// write "ExperienceMultiplier"
	err = en.Append(0xb4, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ExperienceMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "ExperienceMultiplier")
		return
	}
	// write "GrantedEffectsKeys"
	err = en.Append(0xb2, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.GrantedEffectsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "GrantedEffectsKeys")
		return
	}
	for za0004 := range z.GrantedEffectsKeys {
		err = en.WriteInt(z.GrantedEffectsKeys[za0004])
		if err != nil {
			err = msgp.WrapError(err, "GrantedEffectsKeys", za0004)
			return
		}
	}
	// write "HelmetItemVisualIdentityKey"
	err = en.Append(0xbb, 0x48, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.HelmetItemVisualIdentityKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.HelmetItemVisualIdentityKey)
		if err != nil {
			err = msgp.WrapError(err, "HelmetItemVisualIdentityKey")
			return
		}
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "KillRareAchievementItemsKeys"
	err = en.Append(0xbc, 0x4b, 0x69, 0x6c, 0x6c, 0x52, 0x61, 0x72, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.KillRareAchievementItemsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "KillRareAchievementItemsKeys")
		return
	}
	for za0005 := range z.KillRareAchievementItemsKeys {
		err = en.WriteInt(z.KillRareAchievementItemsKeys[za0005])
		if err != nil {
			err = msgp.WrapError(err, "KillRareAchievementItemsKeys", za0005)
			return
		}
	}
	// write "KillSpecificMonsterCountAchievementItemsKeys"
	err = en.Append(0xd9, 0x2c, 0x4b, 0x69, 0x6c, 0x6c, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.KillSpecificMonsterCountAchievementItemsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "KillSpecificMonsterCountAchievementItemsKeys")
		return
	}
	for za0006 := range z.KillSpecificMonsterCountAchievementItemsKeys {
		err = en.WriteInt(z.KillSpecificMonsterCountAchievementItemsKeys[za0006])
		if err != nil {
			err = msgp.WrapError(err, "KillSpecificMonsterCountAchievementItemsKeys", za0006)
			return
		}
	}
	// write "KillWhileOnslaughtIsActiveAchievementItemsKey"
	err = en.Append(0xd9, 0x2d, 0x4b, 0x69, 0x6c, 0x6c, 0x57, 0x68, 0x69, 0x6c, 0x65, 0x4f, 0x6e, 0x73, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x74, 0x49, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.KillWhileOnslaughtIsActiveAchievementItemsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.KillWhileOnslaughtIsActiveAchievementItemsKey)
		if err != nil {
			err = msgp.WrapError(err, "KillWhileOnslaughtIsActiveAchievementItemsKey")
			return
		}
	}
	// write "KillWhileTalismanIsActiveAchievementItemsKey"
	err = en.Append(0xd9, 0x2c, 0x4b, 0x69, 0x6c, 0x6c, 0x57, 0x68, 0x69, 0x6c, 0x65, 0x54, 0x61, 0x6c, 0x69, 0x73, 0x6d, 0x61, 0x6e, 0x49, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.KillWhileTalismanIsActiveAchievementItemsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.KillWhileTalismanIsActiveAchievementItemsKey)
		if err != nil {
			err = msgp.WrapError(err, "KillWhileTalismanIsActiveAchievementItemsKey")
			return
		}
	}
	// write "LifeMultiplier"
	err = en.Append(0xae, 0x4c, 0x69, 0x66, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.LifeMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "LifeMultiplier")
		return
	}
	// write "MainHandItemClassesKey"
	err = en.Append(0xb6, 0x4d, 0x61, 0x69, 0x6e, 0x48, 0x61, 0x6e, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.MainHandItemClassesKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.MainHandItemClassesKey)
		if err != nil {
			err = msgp.WrapError(err, "MainHandItemClassesKey")
			return
		}
	}
	// write "MaximumAttackDistance"
	err = en.Append(0xb5, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaximumAttackDistance)
	if err != nil {
		err = msgp.WrapError(err, "MaximumAttackDistance")
		return
	}
	// write "MinimumAttackDistance"
	err = en.Append(0xb5, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MinimumAttackDistance)
	if err != nil {
		err = msgp.WrapError(err, "MinimumAttackDistance")
		return
	}
	// write "ModelSizeMultiplier"
	err = en.Append(0xb3, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ModelSizeMultiplier)
	if err != nil {
		err = msgp.WrapError(err, "ModelSizeMultiplier")
		return
	}
	// write "ModsKeys"
	err = en.Append(0xa8, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ModsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "ModsKeys")
		return
	}
	for za0007 := range z.ModsKeys {
		err = en.WriteInt(z.ModsKeys[za0007])
		if err != nil {
			err = msgp.WrapError(err, "ModsKeys", za0007)
			return
		}
	}
	// write "ModsKeys2"
	err = en.Append(0xa9, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73, 0x32)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ModsKeys2)))
	if err != nil {
		err = msgp.WrapError(err, "ModsKeys2")
		return
	}
	for za0008 := range z.ModsKeys2 {
		err = en.WriteInt(z.ModsKeys2[za0008])
		if err != nil {
			err = msgp.WrapError(err, "ModsKeys2", za0008)
			return
		}
	}
	// write "MonsterArmoursKey"
	err = en.Append(0xb1, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.MonsterArmoursKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.MonsterArmoursKey)
		if err != nil {
			err = msgp.WrapError(err, "MonsterArmoursKey")
			return
		}
	}
	// write "MonsterConditionalEffectPacksKey"
	err = en.Append(0xd9, 0x20, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.MonsterConditionalEffectPacksKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.MonsterConditionalEffectPacksKey)
		if err != nil {
			err = msgp.WrapError(err, "MonsterConditionalEffectPacksKey")
			return
		}
	}
	// write "MonsterSegmentsKey"
	err = en.Append(0xb2, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x53, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.MonsterSegmentsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.MonsterSegmentsKey)
		if err != nil {
			err = msgp.WrapError(err, "MonsterSegmentsKey")
			return
		}
	}
	// write "MonsterTypesKey"
	err = en.Append(0xaf, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MonsterTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "MonsterTypesKey")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "ObjectSize"
	err = en.Append(0xaa, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69, 0x7a, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.ObjectSize)
	if err != nil {
		err = msgp.WrapError(err, "ObjectSize")
		return
	}
	// write "OffHandItemClassesKey"
	err = en.Append(0xb5, 0x4f, 0x66, 0x66, 0x48, 0x61, 0x6e, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.OffHandItemClassesKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.OffHandItemClassesKey)
		if err != nil {
			err = msgp.WrapError(err, "OffHandItemClassesKey")
			return
		}
	}
	// write "Part1ModsKeys"
	err = en.Append(0xad, 0x50, 0x61, 0x72, 0x74, 0x31, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Part1ModsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Part1ModsKeys")
		return
	}
	for za0009 := range z.Part1ModsKeys {
		err = en.WriteInt(z.Part1ModsKeys[za0009])
		if err != nil {
			err = msgp.WrapError(err, "Part1ModsKeys", za0009)
			return
		}
	}
	// write "Part2ModsKeys"
	err = en.Append(0xad, 0x50, 0x61, 0x72, 0x74, 0x32, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Part2ModsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Part2ModsKeys")
		return
	}
	for za0010 := range z.Part2ModsKeys {
		err = en.WriteInt(z.Part2ModsKeys[za0010])
		if err != nil {
			err = msgp.WrapError(err, "Part2ModsKeys", za0010)
			return
		}
	}
	// write "SinkAnimationAOFile"
	err = en.Append(0xb3, 0x53, 0x69, 0x6e, 0x6b, 0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x4f, 0x46, 0x69, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.SinkAnimationAOFile)
	if err != nil {
		err = msgp.WrapError(err, "SinkAnimationAOFile")
		return
	}
	// write "SpecialModsKeys"
	err = en.Append(0xaf, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SpecialModsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "SpecialModsKeys")
		return
	}
	for za0011 := range z.SpecialModsKeys {
		err = en.WriteInt(z.SpecialModsKeys[za0011])
		if err != nil {
			err = msgp.WrapError(err, "SpecialModsKeys", za0011)
			return
		}
	}
	// write "Stance"
	err = en.Append(0xa6, 0x53, 0x74, 0x61, 0x6e, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Stance))
	if err != nil {
		err = msgp.WrapError(err, "Stance")
		return
	}
	// write "TagsKeys"
	err = en.Append(0xa8, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.TagsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "TagsKeys")
		return
	}
	for za0012 := range z.TagsKeys {
		err = en.WriteInt(z.TagsKeys[za0012])
		if err != nil {
			err = msgp.WrapError(err, "TagsKeys", za0012)
			return
		}
	}
	// write "Weapon1ItemVisualIdentityKeys"
	err = en.Append(0xbd, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x31, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Weapon1ItemVisualIdentityKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Weapon1ItemVisualIdentityKeys")
		return
	}
	for za0013 := range z.Weapon1ItemVisualIdentityKeys {
		err = en.WriteInt(z.Weapon1ItemVisualIdentityKeys[za0013])
		if err != nil {
			err = msgp.WrapError(err, "Weapon1ItemVisualIdentityKeys", za0013)
			return
		}
	}
	// write "Weapon2ItemVisualIdentityKeys"
	err = en.Append(0xbd, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x32, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Weapon2ItemVisualIdentityKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Weapon2ItemVisualIdentityKeys")
		return
	}
	for za0014 := range z.Weapon2ItemVisualIdentityKeys {
		err = en.WriteInt(z.Weapon2ItemVisualIdentityKeys[za0014])
		if err != nil {
			err = msgp.WrapError(err, "Weapon2ItemVisualIdentityKeys", za0014)
			return
		}
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *MonsterVariety) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 41
	// string "ACTFiles"
	o = append(o, 0xde, 0x0, 0x29, 0xa8, 0x41, 0x43, 0x54, 0x46, 0x69, 0x6c, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ACTFiles)))
	for za0001 := range z.ACTFiles {
		o = msgp.AppendString(o, z.ACTFiles[za0001])
	}
	// string "AISFile"
	o = append(o, 0xa7, 0x41, 0x49, 0x53, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.AISFile)
	// string "AOFiles"
	o = append(o, 0xa7, 0x41, 0x4f, 0x46, 0x69, 0x6c, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AOFiles)))
	for za0002 := range z.AOFiles {
		o = msgp.AppendString(o, z.AOFiles[za0002])
	}
	// string "AttackSpeed"
	o = append(o, 0xab, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x53, 0x70, 0x65, 0x65, 0x64)
	o = msgp.AppendInt(o, z.AttackSpeed)
	// string "BackItemVisualIdentityKey"
	o = append(o, 0xb9, 0x42, 0x61, 0x63, 0x6b, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79)
	if z.BackItemVisualIdentityKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.BackItemVisualIdentityKey)
	}
	// string "BaseMonsterTypeIndex"
	o = append(o, 0xb4, 0x42, 0x61, 0x73, 0x65, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x49, 0x6e, 0x64, 0x65, 0x78)
	o = msgp.AppendString(o, z.BaseMonsterTypeIndex)
	// string "CriticalStrikeChance"
	o = append(o, 0xb4, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c, 0x53, 0x74, 0x72, 0x69, 0x6b, 0x65, 0x43, 0x68, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendInt(o, z.CriticalStrikeChance)
	// string "DamageMultiplier"
	o = append(o, 0xb0, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.DamageMultiplier)
	// string "EPKFile"
	o = append(o, 0xa7, 0x45, 0x50, 0x4b, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.EPKFile)
	// string "EndgameModsKeys"
	o = append(o, 0xaf, 0x45, 0x6e, 0x64, 0x67, 0x61, 0x6d, 0x65, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.EndgameModsKeys)))
	for za0003 := range z.EndgameModsKeys {
		o = msgp.AppendInt(o, z.EndgameModsKeys[za0003])
	}
	// string "ExperienceMultiplier"
	o = append(o, 0xb4, 0x45, 0x78, 0x70, 0x65, 0x72, 0x69, 0x65, 0x6e, 0x63, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.ExperienceMultiplier)
	// string "GrantedEffectsKeys"
	o = append(o, 0xb2, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.GrantedEffectsKeys)))
	for za0004 := range z.GrantedEffectsKeys {
		o = msgp.AppendInt(o, z.GrantedEffectsKeys[za0004])
	}
	// string "HelmetItemVisualIdentityKey"
	o = append(o, 0xbb, 0x48, 0x65, 0x6c, 0x6d, 0x65, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79)
	if z.HelmetItemVisualIdentityKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.HelmetItemVisualIdentityKey)
	}
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "KillRareAchievementItemsKeys"
	o = append(o, 0xbc, 0x4b, 0x69, 0x6c, 0x6c, 0x52, 0x61, 0x72, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.KillRareAchievementItemsKeys)))
	for za0005 := range z.KillRareAchievementItemsKeys {
		o = msgp.AppendInt(o, z.KillRareAchievementItemsKeys[za0005])
	}
	// string "KillSpecificMonsterCountAchievementItemsKeys"
	o = append(o, 0xd9, 0x2c, 0x4b, 0x69, 0x6c, 0x6c, 0x53, 0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x75, 0x6e, 0x74, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.KillSpecificMonsterCountAchievementItemsKeys)))
	for za0006 := range z.KillSpecificMonsterCountAchievementItemsKeys {
		o = msgp.AppendInt(o, z.KillSpecificMonsterCountAchievementItemsKeys[za0006])
	}
	// string "KillWhileOnslaughtIsActiveAchievementItemsKey"
	o = append(o, 0xd9, 0x2d, 0x4b, 0x69, 0x6c, 0x6c, 0x57, 0x68, 0x69, 0x6c, 0x65, 0x4f, 0x6e, 0x73, 0x6c, 0x61, 0x75, 0x67, 0x68, 0x74, 0x49, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if z.KillWhileOnslaughtIsActiveAchievementItemsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.KillWhileOnslaughtIsActiveAchievementItemsKey)
	}
	// string "KillWhileTalismanIsActiveAchievementItemsKey"
	o = append(o, 0xd9, 0x2c, 0x4b, 0x69, 0x6c, 0x6c, 0x57, 0x68, 0x69, 0x6c, 0x65, 0x54, 0x61, 0x6c, 0x69, 0x73, 0x6d, 0x61, 0x6e, 0x49, 0x73, 0x41, 0x63, 0x74, 0x69, 0x76, 0x65, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if z.KillWhileTalismanIsActiveAchievementItemsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.KillWhileTalismanIsActiveAchievementItemsKey)
	}
	// string "LifeMultiplier"
	o = append(o, 0xae, 0x4c, 0x69, 0x66, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.LifeMultiplier)
	// string "MainHandItemClassesKey"
	o = append(o, 0xb6, 0x4d, 0x61, 0x69, 0x6e, 0x48, 0x61, 0x6e, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if z.MainHandItemClassesKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.MainHandItemClassesKey)
	}
	// string "MaximumAttackDistance"
	o = append(o, 0xb5, 0x4d, 0x61, 0x78, 0x69, 0x6d, 0x75, 0x6d, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendInt(o, z.MaximumAttackDistance)
	// string "MinimumAttackDistance"
	o = append(o, 0xb5, 0x4d, 0x69, 0x6e, 0x69, 0x6d, 0x75, 0x6d, 0x41, 0x74, 0x74, 0x61, 0x63, 0x6b, 0x44, 0x69, 0x73, 0x74, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendInt(o, z.MinimumAttackDistance)
	// string "ModelSizeMultiplier"
	o = append(o, 0xb3, 0x4d, 0x6f, 0x64, 0x65, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x69, 0x65, 0x72)
	o = msgp.AppendInt(o, z.ModelSizeMultiplier)
	// string "ModsKeys"
	o = append(o, 0xa8, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ModsKeys)))
	for za0007 := range z.ModsKeys {
		o = msgp.AppendInt(o, z.ModsKeys[za0007])
	}
	// string "ModsKeys2"
	o = append(o, 0xa9, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73, 0x32)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ModsKeys2)))
	for za0008 := range z.ModsKeys2 {
		o = msgp.AppendInt(o, z.ModsKeys2[za0008])
	}
	// string "MonsterArmoursKey"
	o = append(o, 0xb1, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x41, 0x72, 0x6d, 0x6f, 0x75, 0x72, 0x73, 0x4b, 0x65, 0x79)
	if z.MonsterArmoursKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.MonsterArmoursKey)
	}
	// string "MonsterConditionalEffectPacksKey"
	o = append(o, 0xd9, 0x20, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x43, 0x6f, 0x6e, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x50, 0x61, 0x63, 0x6b, 0x73, 0x4b, 0x65, 0x79)
	if z.MonsterConditionalEffectPacksKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.MonsterConditionalEffectPacksKey)
	}
	// string "MonsterSegmentsKey"
	o = append(o, 0xb2, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x53, 0x65, 0x67, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if z.MonsterSegmentsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.MonsterSegmentsKey)
	}
	// string "MonsterTypesKey"
	o = append(o, 0xaf, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.MonsterTypesKey)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "ObjectSize"
	o = append(o, 0xaa, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69, 0x7a, 0x65)
	o = msgp.AppendInt(o, z.ObjectSize)
	// string "OffHandItemClassesKey"
	o = append(o, 0xb5, 0x4f, 0x66, 0x66, 0x48, 0x61, 0x6e, 0x64, 0x49, 0x74, 0x65, 0x6d, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if z.OffHandItemClassesKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.OffHandItemClassesKey)
	}
	// string "Part1ModsKeys"
	o = append(o, 0xad, 0x50, 0x61, 0x72, 0x74, 0x31, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Part1ModsKeys)))
	for za0009 := range z.Part1ModsKeys {
		o = msgp.AppendInt(o, z.Part1ModsKeys[za0009])
	}
	// string "Part2ModsKeys"
	o = append(o, 0xad, 0x50, 0x61, 0x72, 0x74, 0x32, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Part2ModsKeys)))
	for za0010 := range z.Part2ModsKeys {
		o = msgp.AppendInt(o, z.Part2ModsKeys[za0010])
	}
	// string "SinkAnimationAOFile"
	o = append(o, 0xb3, 0x53, 0x69, 0x6e, 0x6b, 0x41, 0x6e, 0x69, 0x6d, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x41, 0x4f, 0x46, 0x69, 0x6c, 0x65)
	o = msgp.AppendString(o, z.SinkAnimationAOFile)
	// string "SpecialModsKeys"
	o = append(o, 0xaf, 0x53, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x4d, 0x6f, 0x64, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SpecialModsKeys)))
	for za0011 := range z.SpecialModsKeys {
		o = msgp.AppendInt(o, z.SpecialModsKeys[za0011])
	}
	// string "Stance"
	o = append(o, 0xa6, 0x53, 0x74, 0x61, 0x6e, 0x63, 0x65)
	o = msgp.AppendString(o, string(z.Stance))
	// string "TagsKeys"
	o = append(o, 0xa8, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.TagsKeys)))
	for za0012 := range z.TagsKeys {
		o = msgp.AppendInt(o, z.TagsKeys[za0012])
	}
	// string "Weapon1ItemVisualIdentityKeys"
	o = append(o, 0xbd, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x31, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Weapon1ItemVisualIdentityKeys)))
	for za0013 := range z.Weapon1ItemVisualIdentityKeys {
		o = msgp.AppendInt(o, z.Weapon1ItemVisualIdentityKeys[za0013])
	}
	// string "Weapon2ItemVisualIdentityKeys"
	o = append(o, 0xbd, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x32, 0x49, 0x74, 0x65, 0x6d, 0x56, 0x69, 0x73, 0x75, 0x61, 0x6c, 0x49, 0x64, 0x65, 0x6e, 0x74, 0x69, 0x74, 0x79, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Weapon2ItemVisualIdentityKeys)))
	for za0014 := range z.Weapon2ItemVisualIdentityKeys {
		o = msgp.AppendInt(o, z.Weapon2ItemVisualIdentityKeys[za0014])
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MonsterVariety) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ACTFiles":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ACTFiles")
				return
			}
			if cap(z.ACTFiles) >= int(zb0002) {
				z.ACTFiles = (z.ACTFiles)[:zb0002]
			} else {
				z.ACTFiles = make([]string, zb0002)
			}
			for za0001 := range z.ACTFiles {
				z.ACTFiles[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ACTFiles", za0001)
					return
				}
			}
		case "AISFile":
			z.AISFile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AISFile")
				return
			}
		case "AOFiles":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AOFiles")
				return
			}
			if cap(z.AOFiles) >= int(zb0003) {
				z.AOFiles = (z.AOFiles)[:zb0003]
			} else {
				z.AOFiles = make([]string, zb0003)
			}
			for za0002 := range z.AOFiles {
				z.AOFiles[za0002], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AOFiles", za0002)
					return
				}
			}
		case "AttackSpeed":
			z.AttackSpeed, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AttackSpeed")
				return
			}
		case "BackItemVisualIdentityKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.BackItemVisualIdentityKey = nil
			} else {
				if z.BackItemVisualIdentityKey == nil {
					z.BackItemVisualIdentityKey = new(int)
				}
				*z.BackItemVisualIdentityKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BackItemVisualIdentityKey")
					return
				}
			}
		case "BaseMonsterTypeIndex":
			z.BaseMonsterTypeIndex, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseMonsterTypeIndex")
				return
			}
		case "CriticalStrikeChance":
			z.CriticalStrikeChance, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CriticalStrikeChance")
				return
			}
		case "DamageMultiplier":
			z.DamageMultiplier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DamageMultiplier")
				return
			}
		case "EPKFile":
			z.EPKFile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EPKFile")
				return
			}
		case "EndgameModsKeys":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "EndgameModsKeys")
				return
			}
			if cap(z.EndgameModsKeys) >= int(zb0004) {
				z.EndgameModsKeys = (z.EndgameModsKeys)[:zb0004]
			} else {
				z.EndgameModsKeys = make([]int, zb0004)
			}
			for za0003 := range z.EndgameModsKeys {
				z.EndgameModsKeys[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "EndgameModsKeys", za0003)
					return
				}
			}
		case "ExperienceMultiplier":
			z.ExperienceMultiplier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ExperienceMultiplier")
				return
			}
		case "GrantedEffectsKeys":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffectsKeys")
				return
			}
			if cap(z.GrantedEffectsKeys) >= int(zb0005) {
				z.GrantedEffectsKeys = (z.GrantedEffectsKeys)[:zb0005]
			} else {
				z.GrantedEffectsKeys = make([]int, zb0005)
			}
			for za0004 := range z.GrantedEffectsKeys {
				z.GrantedEffectsKeys[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffectsKeys", za0004)
					return
				}
			}
		case "HelmetItemVisualIdentityKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HelmetItemVisualIdentityKey = nil
			} else {
				if z.HelmetItemVisualIdentityKey == nil {
					z.HelmetItemVisualIdentityKey = new(int)
				}
				*z.HelmetItemVisualIdentityKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HelmetItemVisualIdentityKey")
					return
				}
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "KillRareAchievementItemsKeys":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KillRareAchievementItemsKeys")
				return
			}
			if cap(z.KillRareAchievementItemsKeys) >= int(zb0006) {
				z.KillRareAchievementItemsKeys = (z.KillRareAchievementItemsKeys)[:zb0006]
			} else {
				z.KillRareAchievementItemsKeys = make([]int, zb0006)
			}
			for za0005 := range z.KillRareAchievementItemsKeys {
				z.KillRareAchievementItemsKeys[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KillRareAchievementItemsKeys", za0005)
					return
				}
			}
		case "KillSpecificMonsterCountAchievementItemsKeys":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "KillSpecificMonsterCountAchievementItemsKeys")
				return
			}
			if cap(z.KillSpecificMonsterCountAchievementItemsKeys) >= int(zb0007) {
				z.KillSpecificMonsterCountAchievementItemsKeys = (z.KillSpecificMonsterCountAchievementItemsKeys)[:zb0007]
			} else {
				z.KillSpecificMonsterCountAchievementItemsKeys = make([]int, zb0007)
			}
			for za0006 := range z.KillSpecificMonsterCountAchievementItemsKeys {
				z.KillSpecificMonsterCountAchievementItemsKeys[za0006], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KillSpecificMonsterCountAchievementItemsKeys", za0006)
					return
				}
			}
		case "KillWhileOnslaughtIsActiveAchievementItemsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.KillWhileOnslaughtIsActiveAchievementItemsKey = nil
			} else {
				if z.KillWhileOnslaughtIsActiveAchievementItemsKey == nil {
					z.KillWhileOnslaughtIsActiveAchievementItemsKey = new(int)
				}
				*z.KillWhileOnslaughtIsActiveAchievementItemsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KillWhileOnslaughtIsActiveAchievementItemsKey")
					return
				}
			}
		case "KillWhileTalismanIsActiveAchievementItemsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.KillWhileTalismanIsActiveAchievementItemsKey = nil
			} else {
				if z.KillWhileTalismanIsActiveAchievementItemsKey == nil {
					z.KillWhileTalismanIsActiveAchievementItemsKey = new(int)
				}
				*z.KillWhileTalismanIsActiveAchievementItemsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "KillWhileTalismanIsActiveAchievementItemsKey")
					return
				}
			}
		case "LifeMultiplier":
			z.LifeMultiplier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "LifeMultiplier")
				return
			}
		case "MainHandItemClassesKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MainHandItemClassesKey = nil
			} else {
				if z.MainHandItemClassesKey == nil {
					z.MainHandItemClassesKey = new(int)
				}
				*z.MainHandItemClassesKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MainHandItemClassesKey")
					return
				}
			}
		case "MaximumAttackDistance":
			z.MaximumAttackDistance, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaximumAttackDistance")
				return
			}
		case "MinimumAttackDistance":
			z.MinimumAttackDistance, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinimumAttackDistance")
				return
			}
		case "ModelSizeMultiplier":
			z.ModelSizeMultiplier, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModelSizeMultiplier")
				return
			}
		case "ModsKeys":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModsKeys")
				return
			}
			if cap(z.ModsKeys) >= int(zb0008) {
				z.ModsKeys = (z.ModsKeys)[:zb0008]
			} else {
				z.ModsKeys = make([]int, zb0008)
			}
			for za0007 := range z.ModsKeys {
				z.ModsKeys[za0007], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ModsKeys", za0007)
					return
				}
			}
		case "ModsKeys2":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ModsKeys2")
				return
			}
			if cap(z.ModsKeys2) >= int(zb0009) {
				z.ModsKeys2 = (z.ModsKeys2)[:zb0009]
			} else {
				z.ModsKeys2 = make([]int, zb0009)
			}
			for za0008 := range z.ModsKeys2 {
				z.ModsKeys2[za0008], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ModsKeys2", za0008)
					return
				}
			}
		case "MonsterArmoursKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MonsterArmoursKey = nil
			} else {
				if z.MonsterArmoursKey == nil {
					z.MonsterArmoursKey = new(int)
				}
				*z.MonsterArmoursKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MonsterArmoursKey")
					return
				}
			}
		case "MonsterConditionalEffectPacksKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MonsterConditionalEffectPacksKey = nil
			} else {
				if z.MonsterConditionalEffectPacksKey == nil {
					z.MonsterConditionalEffectPacksKey = new(int)
				}
				*z.MonsterConditionalEffectPacksKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MonsterConditionalEffectPacksKey")
					return
				}
			}
		case "MonsterSegmentsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MonsterSegmentsKey = nil
			} else {
				if z.MonsterSegmentsKey == nil {
					z.MonsterSegmentsKey = new(int)
				}
				*z.MonsterSegmentsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MonsterSegmentsKey")
					return
				}
			}
		case "MonsterTypesKey":
			z.MonsterTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MonsterTypesKey")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "ObjectSize":
			z.ObjectSize, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ObjectSize")
				return
			}
		case "OffHandItemClassesKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OffHandItemClassesKey = nil
			} else {
				if z.OffHandItemClassesKey == nil {
					z.OffHandItemClassesKey = new(int)
				}
				*z.OffHandItemClassesKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OffHandItemClassesKey")
					return
				}
			}
		case "Part1ModsKeys":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Part1ModsKeys")
				return
			}
			if cap(z.Part1ModsKeys) >= int(zb0010) {
				z.Part1ModsKeys = (z.Part1ModsKeys)[:zb0010]
			} else {
				z.Part1ModsKeys = make([]int, zb0010)
			}
			for za0009 := range z.Part1ModsKeys {
				z.Part1ModsKeys[za0009], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Part1ModsKeys", za0009)
					return
				}
			}
		case "Part2ModsKeys":
			var zb0011 uint32
			zb0011, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Part2ModsKeys")
				return
			}
			if cap(z.Part2ModsKeys) >= int(zb0011) {
				z.Part2ModsKeys = (z.Part2ModsKeys)[:zb0011]
			} else {
				z.Part2ModsKeys = make([]int, zb0011)
			}
			for za0010 := range z.Part2ModsKeys {
				z.Part2ModsKeys[za0010], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Part2ModsKeys", za0010)
					return
				}
			}
		case "SinkAnimationAOFile":
			z.SinkAnimationAOFile, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SinkAnimationAOFile")
				return
			}
		case "SpecialModsKeys":
			var zb0012 uint32
			zb0012, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SpecialModsKeys")
				return
			}
			if cap(z.SpecialModsKeys) >= int(zb0012) {
				z.SpecialModsKeys = (z.SpecialModsKeys)[:zb0012]
			} else {
				z.SpecialModsKeys = make([]int, zb0012)
			}
			for za0011 := range z.SpecialModsKeys {
				z.SpecialModsKeys[za0011], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SpecialModsKeys", za0011)
					return
				}
			}
		case "Stance":
			{
				var zb0013 string
				zb0013, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stance")
					return
				}
				z.Stance = MonsterVarietyStance(zb0013)
			}
		case "TagsKeys":
			var zb0014 uint32
			zb0014, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TagsKeys")
				return
			}
			if cap(z.TagsKeys) >= int(zb0014) {
				z.TagsKeys = (z.TagsKeys)[:zb0014]
			} else {
				z.TagsKeys = make([]int, zb0014)
			}
			for za0012 := range z.TagsKeys {
				z.TagsKeys[za0012], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "TagsKeys", za0012)
					return
				}
			}
		case "Weapon1ItemVisualIdentityKeys":
			var zb0015 uint32
			zb0015, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Weapon1ItemVisualIdentityKeys")
				return
			}
			if cap(z.Weapon1ItemVisualIdentityKeys) >= int(zb0015) {
				z.Weapon1ItemVisualIdentityKeys = (z.Weapon1ItemVisualIdentityKeys)[:zb0015]
			} else {
				z.Weapon1ItemVisualIdentityKeys = make([]int, zb0015)
			}
			for za0013 := range z.Weapon1ItemVisualIdentityKeys {
				z.Weapon1ItemVisualIdentityKeys[za0013], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Weapon1ItemVisualIdentityKeys", za0013)
					return
				}
			}
		case "Weapon2ItemVisualIdentityKeys":
			var zb0016 uint32
			zb0016, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Weapon2ItemVisualIdentityKeys")
				return
			}
			if cap(z.Weapon2ItemVisualIdentityKeys) >= int(zb0016) {
				z.Weapon2ItemVisualIdentityKeys = (z.Weapon2ItemVisualIdentityKeys)[:zb0016]
			} else {
				z.Weapon2ItemVisualIdentityKeys = make([]int, zb0016)
			}
			for za0014 := range z.Weapon2ItemVisualIdentityKeys {
				z.Weapon2ItemVisualIdentityKeys[za0014], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Weapon2ItemVisualIdentityKeys", za0014)
					return
				}
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *MonsterVariety) Msgsize() (s int) {
	s = 3 + 9 + msgp.ArrayHeaderSize
	for za0001 := range z.ACTFiles {
		s += msgp.StringPrefixSize + len(z.ACTFiles[za0001])
	}
	s += 8 + msgp.StringPrefixSize + len(z.AISFile) + 8 + msgp.ArrayHeaderSize
	for za0002 := range z.AOFiles {
		s += msgp.StringPrefixSize + len(z.AOFiles[za0002])
	}
	s += 12 + msgp.IntSize + 26
	if z.BackItemVisualIdentityKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21 + msgp.StringPrefixSize + len(z.BaseMonsterTypeIndex) + 21 + msgp.IntSize + 17 + msgp.IntSize + 8 + msgp.StringPrefixSize + len(z.EPKFile) + 16 + msgp.ArrayHeaderSize + (len(z.EndgameModsKeys) * (msgp.IntSize)) + 21 + msgp.IntSize + 19 + msgp.ArrayHeaderSize + (len(z.GrantedEffectsKeys) * (msgp.IntSize)) + 28
	if z.HelmetItemVisualIdentityKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 3 + msgp.StringPrefixSize + len(z.ID) + 29 + msgp.ArrayHeaderSize + (len(z.KillRareAchievementItemsKeys) * (msgp.IntSize)) + 46 + msgp.ArrayHeaderSize + (len(z.KillSpecificMonsterCountAchievementItemsKeys) * (msgp.IntSize)) + 47
	if z.KillWhileOnslaughtIsActiveAchievementItemsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 46
	if z.KillWhileTalismanIsActiveAchievementItemsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15 + msgp.IntSize + 23
	if z.MainHandItemClassesKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 22 + msgp.IntSize + 22 + msgp.IntSize + 20 + msgp.IntSize + 9 + msgp.ArrayHeaderSize + (len(z.ModsKeys) * (msgp.IntSize)) + 10 + msgp.ArrayHeaderSize + (len(z.ModsKeys2) * (msgp.IntSize)) + 18
	if z.MonsterArmoursKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 34
	if z.MonsterConditionalEffectPacksKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19
	if z.MonsterSegmentsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 16 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Name) + 11 + msgp.IntSize + 22
	if z.OffHandItemClassesKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 14 + msgp.ArrayHeaderSize + (len(z.Part1ModsKeys) * (msgp.IntSize)) + 14 + msgp.ArrayHeaderSize + (len(z.Part2ModsKeys) * (msgp.IntSize)) + 20 + msgp.StringPrefixSize + len(z.SinkAnimationAOFile) + 16 + msgp.ArrayHeaderSize + (len(z.SpecialModsKeys) * (msgp.IntSize)) + 7 + msgp.StringPrefixSize + len(string(z.Stance)) + 9 + msgp.ArrayHeaderSize + (len(z.TagsKeys) * (msgp.IntSize)) + 30 + msgp.ArrayHeaderSize + (len(z.Weapon1ItemVisualIdentityKeys) * (msgp.IntSize)) + 30 + msgp.ArrayHeaderSize + (len(z.Weapon2ItemVisualIdentityKeys) * (msgp.IntSize)) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *MonsterVarietyStance) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MonsterVarietyStance(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z MonsterVarietyStance) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z MonsterVarietyStance) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *MonsterVarietyStance) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = MonsterVarietyStance(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z MonsterVarietyStance) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PantheonPanelLayout) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AchievementItems":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "AchievementItems")
				return
			}
			if cap(z.AchievementItems) >= int(zb0002) {
				z.AchievementItems = (z.AchievementItems)[:zb0002]
			} else {
				z.AchievementItems = make([]int, zb0002)
			}
			for za0001 := range z.AchievementItems {
				z.AchievementItems[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AchievementItems", za0001)
					return
				}
			}
		case "CoverImage":
			z.CoverImage, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "CoverImage")
				return
			}
		case "Effect1StatsKeys":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect1StatsKeys")
				return
			}
			if cap(z.Effect1StatsKeys) >= int(zb0003) {
				z.Effect1StatsKeys = (z.Effect1StatsKeys)[:zb0003]
			} else {
				z.Effect1StatsKeys = make([]int, zb0003)
			}
			for za0002 := range z.Effect1StatsKeys {
				z.Effect1StatsKeys[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect1StatsKeys", za0002)
					return
				}
			}
		case "Effect1Values":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect1Values")
				return
			}
			if cap(z.Effect1Values) >= int(zb0004) {
				z.Effect1Values = (z.Effect1Values)[:zb0004]
			} else {
				z.Effect1Values = make([]int, zb0004)
			}
			for za0003 := range z.Effect1Values {
				z.Effect1Values[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect1Values", za0003)
					return
				}
			}
		case "Effect2StatsKeys":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect2StatsKeys")
				return
			}
			if cap(z.Effect2StatsKeys) >= int(zb0005) {
				z.Effect2StatsKeys = (z.Effect2StatsKeys)[:zb0005]
			} else {
				z.Effect2StatsKeys = make([]int, zb0005)
			}
			for za0004 := range z.Effect2StatsKeys {
				z.Effect2StatsKeys[za0004], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect2StatsKeys", za0004)
					return
				}
			}
		case "Effect2Values":
			var zb0006 uint32
			zb0006, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect2Values")
				return
			}
			if cap(z.Effect2Values) >= int(zb0006) {
				z.Effect2Values = (z.Effect2Values)[:zb0006]
			} else {
				z.Effect2Values = make([]int, zb0006)
			}
			for za0005 := range z.Effect2Values {
				z.Effect2Values[za0005], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect2Values", za0005)
					return
				}
			}
		case "Effect3StatsKeys":
			var zb0007 uint32
			zb0007, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect3StatsKeys")
				return
			}
			if cap(z.Effect3StatsKeys) >= int(zb0007) {
				z.Effect3StatsKeys = (z.Effect3StatsKeys)[:zb0007]
			} else {
				z.Effect3StatsKeys = make([]int, zb0007)
			}
			for za0006 := range z.Effect3StatsKeys {
				z.Effect3StatsKeys[za0006], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect3StatsKeys", za0006)
					return
				}
			}
		case "Effect3Values":
			var zb0008 uint32
			zb0008, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect3Values")
				return
			}
			if cap(z.Effect3Values) >= int(zb0008) {
				z.Effect3Values = (z.Effect3Values)[:zb0008]
			} else {
				z.Effect3Values = make([]int, zb0008)
			}
			for za0007 := range z.Effect3Values {
				z.Effect3Values[za0007], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect3Values", za0007)
					return
				}
			}
		case "Effect4StatsKeys":
			var zb0009 uint32
			zb0009, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect4StatsKeys")
				return
			}
			if cap(z.Effect4StatsKeys) >= int(zb0009) {
				z.Effect4StatsKeys = (z.Effect4StatsKeys)[:zb0009]
			} else {
				z.Effect4StatsKeys = make([]int, zb0009)
			}
			for za0008 := range z.Effect4StatsKeys {
				z.Effect4StatsKeys[za0008], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect4StatsKeys", za0008)
					return
				}
			}
		case "Effect4Values":
			var zb0010 uint32
			zb0010, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Effect4Values")
				return
			}
			if cap(z.Effect4Values) >= int(zb0010) {
				z.Effect4Values = (z.Effect4Values)[:zb0010]
			} else {
				z.Effect4Values = make([]int, zb0010)
			}
			for za0009 := range z.Effect4Values {
				z.Effect4Values[za0009], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Effect4Values", za0009)
					return
				}
			}
		case "GodName1":
			z.GodName1, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "GodName1")
				return
			}
		case "GodName2":
			z.GodName2, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "GodName2")
				return
			}
		case "GodName3":
			z.GodName3, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "GodName3")
				return
			}
		case "GodName4":
			z.GodName4, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "GodName4")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IsDisabled":
			z.IsDisabled, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsDisabled")
				return
			}
		case "IsMajorGod":
			z.IsMajorGod, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsMajorGod")
				return
			}
		case "QuestState1":
			z.QuestState1, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QuestState1")
				return
			}
		case "QuestState2":
			z.QuestState2, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QuestState2")
				return
			}
		case "QuestState3":
			z.QuestState3, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QuestState3")
				return
			}
		case "QuestState4":
			z.QuestState4, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "QuestState4")
				return
			}
		case "SelectionImage":
			z.SelectionImage, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SelectionImage")
				return
			}
		case "X":
			z.X, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "Y":
			z.Y, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PantheonPanelLayout) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 25
	// write "AchievementItems"
	err = en.Append(0xde, 0x0, 0x19, 0xb0, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.AchievementItems)))
	if err != nil {
		err = msgp.WrapError(err, "AchievementItems")
		return
	}
	for za0001 := range z.AchievementItems {
		err = en.WriteInt(z.AchievementItems[za0001])
		if err != nil {
			err = msgp.WrapError(err, "AchievementItems", za0001)
			return
		}
	}
	// write "CoverImage"
	err = en.Append(0xaa, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x49, 0x6d, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.CoverImage)
	if err != nil {
		err = msgp.WrapError(err, "CoverImage")
		return
	}
	// write "Effect1StatsKeys"
	err = en.Append(0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x31, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect1StatsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Effect1StatsKeys")
		return
	}
	for za0002 := range z.Effect1StatsKeys {
		err = en.WriteInt(z.Effect1StatsKeys[za0002])
		if err != nil {
			err = msgp.WrapError(err, "Effect1StatsKeys", za0002)
			return
		}
	}
	// write "Effect1Values"
	err = en.Append(0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x31, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect1Values)))
	if err != nil {
		err = msgp.WrapError(err, "Effect1Values")
		return
	}
	for za0003 := range z.Effect1Values {
		err = en.WriteInt(z.Effect1Values[za0003])
		if err != nil {
			err = msgp.WrapError(err, "Effect1Values", za0003)
			return
		}
	}
	// write "Effect2StatsKeys"
	err = en.Append(0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x32, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect2StatsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Effect2StatsKeys")
		return
	}
	for za0004 := range z.Effect2StatsKeys {
		err = en.WriteInt(z.Effect2StatsKeys[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Effect2StatsKeys", za0004)
			return
		}
	}
	// write "Effect2Values"
	err = en.Append(0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect2Values)))
	if err != nil {
		err = msgp.WrapError(err, "Effect2Values")
		return
	}
	for za0005 := range z.Effect2Values {
		err = en.WriteInt(z.Effect2Values[za0005])
		if err != nil {
			err = msgp.WrapError(err, "Effect2Values", za0005)
			return
		}
	}
	// write "Effect3StatsKeys"
	err = en.Append(0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x33, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect3StatsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Effect3StatsKeys")
		return
	}
	for za0006 := range z.Effect3StatsKeys {
		err = en.WriteInt(z.Effect3StatsKeys[za0006])
		if err != nil {
			err = msgp.WrapError(err, "Effect3StatsKeys", za0006)
			return
		}
	}
	// write "Effect3Values"
	err = en.Append(0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x33, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect3Values)))
	if err != nil {
		err = msgp.WrapError(err, "Effect3Values")
		return
	}
	for za0007 := range z.Effect3Values {
		err = en.WriteInt(z.Effect3Values[za0007])
		if err != nil {
			err = msgp.WrapError(err, "Effect3Values", za0007)
			return
		}
	}
	// write "Effect4StatsKeys"
	err = en.Append(0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x34, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect4StatsKeys)))
	if err != nil {
		err = msgp.WrapError(err, "Effect4StatsKeys")
		return
	}
	for za0008 := range z.Effect4StatsKeys {
		err = en.WriteInt(z.Effect4StatsKeys[za0008])
		if err != nil {
			err = msgp.WrapError(err, "Effect4StatsKeys", za0008)
			return
		}
	}
	// write "Effect4Values"
	err = en.Append(0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Effect4Values)))
	if err != nil {
		err = msgp.WrapError(err, "Effect4Values")
		return
	}
	for za0009 := range z.Effect4Values {
		err = en.WriteInt(z.Effect4Values[za0009])
		if err != nil {
			err = msgp.WrapError(err, "Effect4Values", za0009)
			return
		}
	}
	// write "GodName1"
	err = en.Append(0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x31)
	if err != nil {
		return
	}
	err = en.WriteString(z.GodName1)
	if err != nil {
		err = msgp.WrapError(err, "GodName1")
		return
	}
	// write "GodName2"
	err = en.Append(0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x32)
	if err != nil {
		return
	}
	err = en.WriteString(z.GodName2)
	if err != nil {
		err = msgp.WrapError(err, "GodName2")
		return
	}
	// write "GodName3"
	err = en.Append(0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x33)
	if err != nil {
		return
	}
	err = en.WriteString(z.GodName3)
	if err != nil {
		err = msgp.WrapError(err, "GodName3")
		return
	}
	// write "GodName4"
	err = en.Append(0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x34)
	if err != nil {
		return
	}
	err = en.WriteString(z.GodName4)
	if err != nil {
		err = msgp.WrapError(err, "GodName4")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "IsDisabled"
	err = en.Append(0xaa, 0x49, 0x73, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsDisabled)
	if err != nil {
		err = msgp.WrapError(err, "IsDisabled")
		return
	}
	// write "IsMajorGod"
	err = en.Append(0xaa, 0x49, 0x73, 0x4d, 0x61, 0x6a, 0x6f, 0x72, 0x47, 0x6f, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsMajorGod)
	if err != nil {
		err = msgp.WrapError(err, "IsMajorGod")
		return
	}
	// write "QuestState1"
	err = en.Append(0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QuestState1)
	if err != nil {
		err = msgp.WrapError(err, "QuestState1")
		return
	}
	// write "QuestState2"
	err = en.Append(0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QuestState2)
	if err != nil {
		err = msgp.WrapError(err, "QuestState2")
		return
	}
	// write "QuestState3"
	err = en.Append(0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QuestState3)
	if err != nil {
		err = msgp.WrapError(err, "QuestState3")
		return
	}
	// write "QuestState4"
	err = en.Append(0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt(z.QuestState4)
	if err != nil {
		err = msgp.WrapError(err, "QuestState4")
		return
	}
	// write "SelectionImage"
	err = en.Append(0xae, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6d, 0x61, 0x67, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.SelectionImage)
	if err != nil {
		err = msgp.WrapError(err, "SelectionImage")
		return
	}
	// write "X"
	err = en.Append(0xa1, 0x58)
	if err != nil {
		return
	}
	err = en.WriteInt(z.X)
	if err != nil {
		err = msgp.WrapError(err, "X")
		return
	}
	// write "Y"
	err = en.Append(0xa1, 0x59)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Y)
	if err != nil {
		err = msgp.WrapError(err, "Y")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PantheonPanelLayout) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 25
	// string "AchievementItems"
	o = append(o, 0xde, 0x0, 0x19, 0xb0, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x49, 0x74, 0x65, 0x6d, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.AchievementItems)))
	for za0001 := range z.AchievementItems {
		o = msgp.AppendInt(o, z.AchievementItems[za0001])
	}
	// string "CoverImage"
	o = append(o, 0xaa, 0x43, 0x6f, 0x76, 0x65, 0x72, 0x49, 0x6d, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.CoverImage)
	// string "Effect1StatsKeys"
	o = append(o, 0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x31, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect1StatsKeys)))
	for za0002 := range z.Effect1StatsKeys {
		o = msgp.AppendInt(o, z.Effect1StatsKeys[za0002])
	}
	// string "Effect1Values"
	o = append(o, 0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x31, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect1Values)))
	for za0003 := range z.Effect1Values {
		o = msgp.AppendInt(o, z.Effect1Values[za0003])
	}
	// string "Effect2StatsKeys"
	o = append(o, 0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x32, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect2StatsKeys)))
	for za0004 := range z.Effect2StatsKeys {
		o = msgp.AppendInt(o, z.Effect2StatsKeys[za0004])
	}
	// string "Effect2Values"
	o = append(o, 0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x32, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect2Values)))
	for za0005 := range z.Effect2Values {
		o = msgp.AppendInt(o, z.Effect2Values[za0005])
	}
	// string "Effect3StatsKeys"
	o = append(o, 0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x33, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect3StatsKeys)))
	for za0006 := range z.Effect3StatsKeys {
		o = msgp.AppendInt(o, z.Effect3StatsKeys[za0006])
	}
	// string "Effect3Values"
	o = append(o, 0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x33, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect3Values)))
	for za0007 := range z.Effect3Values {
		o = msgp.AppendInt(o, z.Effect3Values[za0007])
	}
	// string "Effect4StatsKeys"
	o = append(o, 0xb0, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x34, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect4StatsKeys)))
	for za0008 := range z.Effect4StatsKeys {
		o = msgp.AppendInt(o, z.Effect4StatsKeys[za0008])
	}
	// string "Effect4Values"
	o = append(o, 0xad, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x34, 0x56, 0x61, 0x6c, 0x75, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Effect4Values)))
	for za0009 := range z.Effect4Values {
		o = msgp.AppendInt(o, z.Effect4Values[za0009])
	}
	// string "GodName1"
	o = append(o, 0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x31)
	o = msgp.AppendString(o, z.GodName1)
	// string "GodName2"
	o = append(o, 0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x32)
	o = msgp.AppendString(o, z.GodName2)
	// string "GodName3"
	o = append(o, 0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x33)
	o = msgp.AppendString(o, z.GodName3)
	// string "GodName4"
	o = append(o, 0xa8, 0x47, 0x6f, 0x64, 0x4e, 0x61, 0x6d, 0x65, 0x34)
	o = msgp.AppendString(o, z.GodName4)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "IsDisabled"
	o = append(o, 0xaa, 0x49, 0x73, 0x44, 0x69, 0x73, 0x61, 0x62, 0x6c, 0x65, 0x64)
	o = msgp.AppendBool(o, z.IsDisabled)
	// string "IsMajorGod"
	o = append(o, 0xaa, 0x49, 0x73, 0x4d, 0x61, 0x6a, 0x6f, 0x72, 0x47, 0x6f, 0x64)
	o = msgp.AppendBool(o, z.IsMajorGod)
	// string "QuestState1"
	o = append(o, 0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x31)
	o = msgp.AppendInt(o, z.QuestState1)
	// string "QuestState2"
	o = append(o, 0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x32)
	o = msgp.AppendInt(o, z.QuestState2)
	// string "QuestState3"
	o = append(o, 0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x33)
	o = msgp.AppendInt(o, z.QuestState3)
	// string "QuestState4"
	o = append(o, 0xab, 0x51, 0x75, 0x65, 0x73, 0x74, 0x53, 0x74, 0x61, 0x74, 0x65, 0x34)
	o = msgp.AppendInt(o, z.QuestState4)
	// string "SelectionImage"
	o = append(o, 0xae, 0x53, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x69, 0x6f, 0x6e, 0x49, 0x6d, 0x61, 0x67, 0x65)
	o = msgp.AppendString(o, z.SelectionImage)
	// string "X"
	o = append(o, 0xa1, 0x58)
	o = msgp.AppendInt(o, z.X)
	// string "Y"
	o = append(o, 0xa1, 0x59)
	o = msgp.AppendInt(o, z.Y)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PantheonPanelLayout) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "AchievementItems":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AchievementItems")
				return
			}
			if cap(z.AchievementItems) >= int(zb0002) {
				z.AchievementItems = (z.AchievementItems)[:zb0002]
			} else {
				z.AchievementItems = make([]int, zb0002)
			}
			for za0001 := range z.AchievementItems {
				z.AchievementItems[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AchievementItems", za0001)
					return
				}
			}
		case "CoverImage":
			z.CoverImage, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "CoverImage")
				return
			}
		case "Effect1StatsKeys":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect1StatsKeys")
				return
			}
			if cap(z.Effect1StatsKeys) >= int(zb0003) {
				z.Effect1StatsKeys = (z.Effect1StatsKeys)[:zb0003]
			} else {
				z.Effect1StatsKeys = make([]int, zb0003)
			}
			for za0002 := range z.Effect1StatsKeys {
				z.Effect1StatsKeys[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect1StatsKeys", za0002)
					return
				}
			}
		case "Effect1Values":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect1Values")
				return
			}
			if cap(z.Effect1Values) >= int(zb0004) {
				z.Effect1Values = (z.Effect1Values)[:zb0004]
			} else {
				z.Effect1Values = make([]int, zb0004)
			}
			for za0003 := range z.Effect1Values {
				z.Effect1Values[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect1Values", za0003)
					return
				}
			}
		case "Effect2StatsKeys":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect2StatsKeys")
				return
			}
			if cap(z.Effect2StatsKeys) >= int(zb0005) {
				z.Effect2StatsKeys = (z.Effect2StatsKeys)[:zb0005]
			} else {
				z.Effect2StatsKeys = make([]int, zb0005)
			}
			for za0004 := range z.Effect2StatsKeys {
				z.Effect2StatsKeys[za0004], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect2StatsKeys", za0004)
					return
				}
			}
		case "Effect2Values":
			var zb0006 uint32
			zb0006, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect2Values")
				return
			}
			if cap(z.Effect2Values) >= int(zb0006) {
				z.Effect2Values = (z.Effect2Values)[:zb0006]
			} else {
				z.Effect2Values = make([]int, zb0006)
			}
			for za0005 := range z.Effect2Values {
				z.Effect2Values[za0005], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect2Values", za0005)
					return
				}
			}
		case "Effect3StatsKeys":
			var zb0007 uint32
			zb0007, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect3StatsKeys")
				return
			}
			if cap(z.Effect3StatsKeys) >= int(zb0007) {
				z.Effect3StatsKeys = (z.Effect3StatsKeys)[:zb0007]
			} else {
				z.Effect3StatsKeys = make([]int, zb0007)
			}
			for za0006 := range z.Effect3StatsKeys {
				z.Effect3StatsKeys[za0006], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect3StatsKeys", za0006)
					return
				}
			}
		case "Effect3Values":
			var zb0008 uint32
			zb0008, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect3Values")
				return
			}
			if cap(z.Effect3Values) >= int(zb0008) {
				z.Effect3Values = (z.Effect3Values)[:zb0008]
			} else {
				z.Effect3Values = make([]int, zb0008)
			}
			for za0007 := range z.Effect3Values {
				z.Effect3Values[za0007], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect3Values", za0007)
					return
				}
			}
		case "Effect4StatsKeys":
			var zb0009 uint32
			zb0009, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect4StatsKeys")
				return
			}
			if cap(z.Effect4StatsKeys) >= int(zb0009) {
				z.Effect4StatsKeys = (z.Effect4StatsKeys)[:zb0009]
			} else {
				z.Effect4StatsKeys = make([]int, zb0009)
			}
			for za0008 := range z.Effect4StatsKeys {
				z.Effect4StatsKeys[za0008], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect4StatsKeys", za0008)
					return
				}
			}
		case "Effect4Values":
			var zb0010 uint32
			zb0010, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Effect4Values")
				return
			}
			if cap(z.Effect4Values) >= int(zb0010) {
				z.Effect4Values = (z.Effect4Values)[:zb0010]
			} else {
				z.Effect4Values = make([]int, zb0010)
			}
			for za0009 := range z.Effect4Values {
				z.Effect4Values[za0009], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Effect4Values", za0009)
					return
				}
			}
		case "GodName1":
			z.GodName1, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GodName1")
				return
			}
		case "GodName2":
			z.GodName2, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GodName2")
				return
			}
		case "GodName3":
			z.GodName3, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GodName3")
				return
			}
		case "GodName4":
			z.GodName4, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GodName4")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IsDisabled":
			z.IsDisabled, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsDisabled")
				return
			}
		case "IsMajorGod":
			z.IsMajorGod, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsMajorGod")
				return
			}
		case "QuestState1":
			z.QuestState1, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuestState1")
				return
			}
		case "QuestState2":
			z.QuestState2, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuestState2")
				return
			}
		case "QuestState3":
			z.QuestState3, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuestState3")
				return
			}
		case "QuestState4":
			z.QuestState4, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "QuestState4")
				return
			}
		case "SelectionImage":
			z.SelectionImage, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SelectionImage")
				return
			}
		case "X":
			z.X, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "X")
				return
			}
		case "Y":
			z.Y, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Y")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PantheonPanelLayout) Msgsize() (s int) {
	s = 3 + 17 + msgp.ArrayHeaderSize + (len(z.AchievementItems) * (msgp.IntSize)) + 11 + msgp.StringPrefixSize + len(z.CoverImage) + 17 + msgp.ArrayHeaderSize + (len(z.Effect1StatsKeys) * (msgp.IntSize)) + 14 + msgp.ArrayHeaderSize + (len(z.Effect1Values) * (msgp.IntSize)) + 17 + msgp.ArrayHeaderSize + (len(z.Effect2StatsKeys) * (msgp.IntSize)) + 14 + msgp.ArrayHeaderSize + (len(z.Effect2Values) * (msgp.IntSize)) + 17 + msgp.ArrayHeaderSize + (len(z.Effect3StatsKeys) * (msgp.IntSize)) + 14 + msgp.ArrayHeaderSize + (len(z.Effect3Values) * (msgp.IntSize)) + 17 + msgp.ArrayHeaderSize + (len(z.Effect4StatsKeys) * (msgp.IntSize)) + 14 + msgp.ArrayHeaderSize + (len(z.Effect4Values) * (msgp.IntSize)) + 9 + msgp.StringPrefixSize + len(z.GodName1) + 9 + msgp.StringPrefixSize + len(z.GodName2) + 9 + msgp.StringPrefixSize + len(z.GodName3) + 9 + msgp.StringPrefixSize + len(z.GodName4) + 3 + msgp.StringPrefixSize + len(z.ID) + 11 + msgp.BoolSize + 11 + msgp.BoolSize + 12 + msgp.IntSize + 12 + msgp.IntSize + 12 + msgp.IntSize + 12 + msgp.IntSize + 15 + msgp.StringPrefixSize + len(z.SelectionImage) + 2 + msgp.IntSize + 2 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PassiveSkill) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Icon":
			z.Icon, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		case "Stats":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Stats")
				return
			}
			if cap(z.Stats) >= int(zb0002) {
				z.Stats = (z.Stats)[:zb0002]
			} else {
				z.Stats = make([]int64, zb0002)
			}
			for za0001 := range z.Stats {
				z.Stats[za0001], err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Stats", za0001)
					return
				}
			}
		case "Stat1":
			z.Stat1, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Stat1")
				return
			}
		case "Stat2":
			z.Stat2, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Stat2")
				return
			}
		case "Stat3":
			z.Stat3, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Stat3")
				return
			}
		case "Stat4":
			z.Stat4, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Stat4")
				return
			}
		case "Hash":
			z.Hash, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		case "Name":
			z.Name, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "ClassStart":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ClassStart")
				return
			}
			if cap(z.ClassStart) >= int(zb0003) {
				z.ClassStart = (z.ClassStart)[:zb0003]
			} else {
				z.ClassStart = make([]int64, zb0003)
			}
			for za0002 := range z.ClassStart {
				z.ClassStart[za0002], err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "ClassStart", za0002)
					return
				}
			}
		case "Keystone":
			z.Keystone, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Keystone")
				return
			}
		case "Notable":
			z.Notable, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Notable")
				return
			}
		case "Flavour":
			z.Flavour, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Flavour")
				return
			}
		case "Mastery":
			z.Mastery, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Mastery")
				return
			}
		case "Achievement":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Achievement")
					return
				}
				z.Achievement = nil
			} else {
				if z.Achievement == nil {
					z.Achievement = new(int64)
				}
				*z.Achievement, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Achievement")
					return
				}
			}
		case "JewelSocket":
			z.JewelSocket, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "JewelSocket")
				return
			}
		case "Ascendancy":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Ascendancy")
					return
				}
				z.Ascendancy = nil
			} else {
				if z.Ascendancy == nil {
					z.Ascendancy = new(int64)
				}
				*z.Ascendancy, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Ascendancy")
					return
				}
			}
		case "AscendancyStart":
			z.AscendancyStart, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "AscendancyStart")
				return
			}
		case "ReminderTexts":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ReminderTexts")
				return
			}
			if cap(z.ReminderTexts) >= int(zb0004) {
				z.ReminderTexts = (z.ReminderTexts)[:zb0004]
			} else {
				z.ReminderTexts = make([]int64, zb0004)
			}
			for za0003 := range z.ReminderTexts {
				z.ReminderTexts[za0003], err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "ReminderTexts", za0003)
					return
				}
			}
		case "PassivePointsGranted":
			z.PassivePointsGranted, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "PassivePointsGranted")
				return
			}
		case "MultipleChoice":
			z.MultipleChoice, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "MultipleChoice")
				return
			}
		case "MultipleChoiceOption":
			z.MultipleChoiceOption, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "MultipleChoiceOption")
				return
			}
		case "Stat5":
			z.Stat5, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Stat5")
				return
			}
		case "Buffs":
			var zb0005 uint32
			zb0005, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Buffs")
				return
			}
			if cap(z.Buffs) >= int(zb0005) {
				z.Buffs = (z.Buffs)[:zb0005]
			} else {
				z.Buffs = make([]int64, zb0005)
			}
			for za0004 := range z.Buffs {
				z.Buffs[za0004], err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "Buffs", za0004)
					return
				}
			}
		case "GrantedEffect":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffect")
					return
				}
				z.GrantedEffect = nil
			} else {
				if z.GrantedEffect == nil {
					z.GrantedEffect = new(int64)
				}
				*z.GrantedEffect, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffect")
					return
				}
			}
		case "Blighted":
			z.Blighted, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Blighted")
				return
			}
		case "ClusterNode":
			z.ClusterNode, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "ClusterNode")
				return
			}
		case "Proxy":
			z.Proxy, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "Proxy")
				return
			}
		case "Type":
			z.Type, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "MasteryGroup":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MasteryGroup")
					return
				}
				z.MasteryGroup = nil
			} else {
				if z.MasteryGroup == nil {
					z.MasteryGroup = new(int64)
				}
				*z.MasteryGroup, err = dc.ReadInt64()
				if err != nil {
					err = msgp.WrapError(err, "MasteryGroup")
					return
				}
			}
		case "Key":
			z.Key, err = dc.ReadInt64()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PassiveSkill) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 31
	// write "ID"
	err = en.Append(0xde, 0x0, 0x1f, 0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "Icon"
	err = en.Append(0xa4, 0x49, 0x63, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Icon)
	if err != nil {
		err = msgp.WrapError(err, "Icon")
		return
	}
	// write "Stats"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Stats)))
	if err != nil {
		err = msgp.WrapError(err, "Stats")
		return
	}
	for za0001 := range z.Stats {
		err = en.WriteInt64(z.Stats[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Stats", za0001)
			return
		}
	}
	// write "Stat1"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x74, 0x31)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Stat1)
	if err != nil {
		err = msgp.WrapError(err, "Stat1")
		return
	}
	// write "Stat2"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x74, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Stat2)
	if err != nil {
		err = msgp.WrapError(err, "Stat2")
		return
	}
	// write "Stat3"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x74, 0x33)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Stat3)
	if err != nil {
		err = msgp.WrapError(err, "Stat3")
		return
	}
	// write "Stat4"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x74, 0x34)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Stat4)
	if err != nil {
		err = msgp.WrapError(err, "Stat4")
		return
	}
	// write "Hash"
	err = en.Append(0xa4, 0x48, 0x61, 0x73, 0x68)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Hash)
	if err != nil {
		err = msgp.WrapError(err, "Hash")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.Name)
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "ClassStart"
	err = en.Append(0xaa, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x53, 0x74, 0x61, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ClassStart)))
	if err != nil {
		err = msgp.WrapError(err, "ClassStart")
		return
	}
	for za0002 := range z.ClassStart {
		err = en.WriteInt64(z.ClassStart[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ClassStart", za0002)
			return
		}
	}
	// write "Keystone"
	err = en.Append(0xa8, 0x4b, 0x65, 0x79, 0x73, 0x74, 0x6f, 0x6e, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Keystone)
	if err != nil {
		err = msgp.WrapError(err, "Keystone")
		return
	}
	// write "Notable"
	err = en.Append(0xa7, 0x4e, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Notable)
	if err != nil {
		err = msgp.WrapError(err, "Notable")
		return
	}
	// write "Flavour"
	err = en.Append(0xa7, 0x46, 0x6c, 0x61, 0x76, 0x6f, 0x75, 0x72)
	if err != nil {
		return
	}
	err = en.WriteString(z.Flavour)
	if err != nil {
		err = msgp.WrapError(err, "Flavour")
		return
	}
	// write "Mastery"
	err = en.Append(0xa7, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Mastery)
	if err != nil {
		err = msgp.WrapError(err, "Mastery")
		return
	}
	// write "Achievement"
	err = en.Append(0xab, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74)
	if err != nil {
		return
	}
	if z.Achievement == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt64(*z.Achievement)
		if err != nil {
			err = msgp.WrapError(err, "Achievement")
			return
		}
	}
	// write "JewelSocket"
	err = en.Append(0xab, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.JewelSocket)
	if err != nil {
		err = msgp.WrapError(err, "JewelSocket")
		return
	}
	// write "Ascendancy"
	err = en.Append(0xaa, 0x41, 0x73, 0x63, 0x65, 0x6e, 0x64, 0x61, 0x6e, 0x63, 0x79)
	if err != nil {
		return
	}
	if z.Ascendancy == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt64(*z.Ascendancy)
		if err != nil {
			err = msgp.WrapError(err, "Ascendancy")
			return
		}
	}
	// write "AscendancyStart"
	err = en.Append(0xaf, 0x41, 0x73, 0x63, 0x65, 0x6e, 0x64, 0x61, 0x6e, 0x63, 0x79, 0x53, 0x74, 0x61, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteBool(z.AscendancyStart)
	if err != nil {
		err = msgp.WrapError(err, "AscendancyStart")
		return
	}
	// write "ReminderTexts"
	err = en.Append(0xad, 0x52, 0x65, 0x6d, 0x69, 0x6e, 0x64, 0x65, 0x72, 0x54, 0x65, 0x78, 0x74, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ReminderTexts)))
	if err != nil {
		err = msgp.WrapError(err, "ReminderTexts")
		return
	}
	for za0003 := range z.ReminderTexts {
		err = en.WriteInt64(z.ReminderTexts[za0003])
		if err != nil {
			err = msgp.WrapError(err, "ReminderTexts", za0003)
			return
		}
	}
	// write "PassivePointsGranted"
	err = en.Append(0xb4, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.PassivePointsGranted)
	if err != nil {
		err = msgp.WrapError(err, "PassivePointsGranted")
		return
	}
	// write "MultipleChoice"
	err = en.Append(0xae, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.MultipleChoice)
	if err != nil {
		err = msgp.WrapError(err, "MultipleChoice")
		return
	}
	// write "MultipleChoiceOption"
	err = en.Append(0xb4, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteBool(z.MultipleChoiceOption)
	if err != nil {
		err = msgp.WrapError(err, "MultipleChoiceOption")
		return
	}
	// write "Stat5"
	err = en.Append(0xa5, 0x53, 0x74, 0x61, 0x74, 0x35)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Stat5)
	if err != nil {
		err = msgp.WrapError(err, "Stat5")
		return
	}
	// write "Buffs"
	err = en.Append(0xa5, 0x42, 0x75, 0x66, 0x66, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Buffs)))
	if err != nil {
		err = msgp.WrapError(err, "Buffs")
		return
	}
	for za0004 := range z.Buffs {
		err = en.WriteInt64(z.Buffs[za0004])
		if err != nil {
			err = msgp.WrapError(err, "Buffs", za0004)
			return
		}
	}
	// write "GrantedEffect"
	err = en.Append(0xad, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	if z.GrantedEffect == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt64(*z.GrantedEffect)
		if err != nil {
			err = msgp.WrapError(err, "GrantedEffect")
			return
		}
	}
	// write "Blighted"
	err = en.Append(0xa8, 0x42, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Blighted)
	if err != nil {
		err = msgp.WrapError(err, "Blighted")
		return
	}
	// write "ClusterNode"
	err = en.Append(0xab, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.ClusterNode)
	if err != nil {
		err = msgp.WrapError(err, "ClusterNode")
		return
	}
	// write "Proxy"
	err = en.Append(0xa5, 0x50, 0x72, 0x6f, 0x78, 0x79)
	if err != nil {
		return
	}
	err = en.WriteBool(z.Proxy)
	if err != nil {
		err = msgp.WrapError(err, "Proxy")
		return
	}
	// write "Type"
	err = en.Append(0xa4, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Type)
	if err != nil {
		err = msgp.WrapError(err, "Type")
		return
	}
	// write "MasteryGroup"
	err = en.Append(0xac, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x79, 0x47, 0x72, 0x6f, 0x75, 0x70)
	if err != nil {
		return
	}
	if z.MasteryGroup == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt64(*z.MasteryGroup)
		if err != nil {
			err = msgp.WrapError(err, "MasteryGroup")
			return
		}
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt64(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PassiveSkill) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 31
	// string "ID"
	o = append(o, 0xde, 0x0, 0x1f, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "Icon"
	o = append(o, 0xa4, 0x49, 0x63, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Icon)
	// string "Stats"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Stats)))
	for za0001 := range z.Stats {
		o = msgp.AppendInt64(o, z.Stats[za0001])
	}
	// string "Stat1"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x31)
	o = msgp.AppendInt64(o, z.Stat1)
	// string "Stat2"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x32)
	o = msgp.AppendInt64(o, z.Stat2)
	// string "Stat3"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x33)
	o = msgp.AppendInt64(o, z.Stat3)
	// string "Stat4"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x34)
	o = msgp.AppendInt64(o, z.Stat4)
	// string "Hash"
	o = append(o, 0xa4, 0x48, 0x61, 0x73, 0x68)
	o = msgp.AppendInt64(o, z.Hash)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.Name)
	// string "ClassStart"
	o = append(o, 0xaa, 0x43, 0x6c, 0x61, 0x73, 0x73, 0x53, 0x74, 0x61, 0x72, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ClassStart)))
	for za0002 := range z.ClassStart {
		o = msgp.AppendInt64(o, z.ClassStart[za0002])
	}
	// string "Keystone"
	o = append(o, 0xa8, 0x4b, 0x65, 0x79, 0x73, 0x74, 0x6f, 0x6e, 0x65)
	o = msgp.AppendBool(o, z.Keystone)
	// string "Notable"
	o = append(o, 0xa7, 0x4e, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.Notable)
	// string "Flavour"
	o = append(o, 0xa7, 0x46, 0x6c, 0x61, 0x76, 0x6f, 0x75, 0x72)
	o = msgp.AppendString(o, z.Flavour)
	// string "Mastery"
	o = append(o, 0xa7, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x79)
	o = msgp.AppendBool(o, z.Mastery)
	// string "Achievement"
	o = append(o, 0xab, 0x41, 0x63, 0x68, 0x69, 0x65, 0x76, 0x65, 0x6d, 0x65, 0x6e, 0x74)
	if z.Achievement == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.Achievement)
	}
	// string "JewelSocket"
	o = append(o, 0xab, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74)
	o = msgp.AppendBool(o, z.JewelSocket)
	// string "Ascendancy"
	o = append(o, 0xaa, 0x41, 0x73, 0x63, 0x65, 0x6e, 0x64, 0x61, 0x6e, 0x63, 0x79)
	if z.Ascendancy == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.Ascendancy)
	}
	// string "AscendancyStart"
	o = append(o, 0xaf, 0x41, 0x73, 0x63, 0x65, 0x6e, 0x64, 0x61, 0x6e, 0x63, 0x79, 0x53, 0x74, 0x61, 0x72, 0x74)
	o = msgp.AppendBool(o, z.AscendancyStart)
	// string "ReminderTexts"
	o = append(o, 0xad, 0x52, 0x65, 0x6d, 0x69, 0x6e, 0x64, 0x65, 0x72, 0x54, 0x65, 0x78, 0x74, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ReminderTexts)))
	for za0003 := range z.ReminderTexts {
		o = msgp.AppendInt64(o, z.ReminderTexts[za0003])
	}
	// string "PassivePointsGranted"
	o = append(o, 0xb4, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x50, 0x6f, 0x69, 0x6e, 0x74, 0x73, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64)
	o = msgp.AppendInt64(o, z.PassivePointsGranted)
	// string "MultipleChoice"
	o = append(o, 0xae, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65)
	o = msgp.AppendBool(o, z.MultipleChoice)
	// string "MultipleChoiceOption"
	o = append(o, 0xb4, 0x4d, 0x75, 0x6c, 0x74, 0x69, 0x70, 0x6c, 0x65, 0x43, 0x68, 0x6f, 0x69, 0x63, 0x65, 0x4f, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendBool(o, z.MultipleChoiceOption)
	// string "Stat5"
	o = append(o, 0xa5, 0x53, 0x74, 0x61, 0x74, 0x35)
	o = msgp.AppendInt64(o, z.Stat5)
	// string "Buffs"
	o = append(o, 0xa5, 0x42, 0x75, 0x66, 0x66, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Buffs)))
	for za0004 := range z.Buffs {
		o = msgp.AppendInt64(o, z.Buffs[za0004])
	}
	// string "GrantedEffect"
	o = append(o, 0xad, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if z.GrantedEffect == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.GrantedEffect)
	}
	// string "Blighted"
	o = append(o, 0xa8, 0x42, 0x6c, 0x69, 0x67, 0x68, 0x74, 0x65, 0x64)
	o = msgp.AppendBool(o, z.Blighted)
	// string "ClusterNode"
	o = append(o, 0xab, 0x43, 0x6c, 0x75, 0x73, 0x74, 0x65, 0x72, 0x4e, 0x6f, 0x64, 0x65)
	o = msgp.AppendBool(o, z.ClusterNode)
	// string "Proxy"
	o = append(o, 0xa5, 0x50, 0x72, 0x6f, 0x78, 0x79)
	o = msgp.AppendBool(o, z.Proxy)
	// string "Type"
	o = append(o, 0xa4, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt64(o, z.Type)
	// string "MasteryGroup"
	o = append(o, 0xac, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x79, 0x47, 0x72, 0x6f, 0x75, 0x70)
	if z.MasteryGroup == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt64(o, *z.MasteryGroup)
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt64(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PassiveSkill) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Icon":
			z.Icon, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Icon")
				return
			}
		case "Stats":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stats")
				return
			}
			if cap(z.Stats) >= int(zb0002) {
				z.Stats = (z.Stats)[:zb0002]
			} else {
				z.Stats = make([]int64, zb0002)
			}
			for za0001 := range z.Stats {
				z.Stats[za0001], bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Stats", za0001)
					return
				}
			}
		case "Stat1":
			z.Stat1, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat1")
				return
			}
		case "Stat2":
			z.Stat2, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat2")
				return
			}
		case "Stat3":
			z.Stat3, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat3")
				return
			}
		case "Stat4":
			z.Stat4, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat4")
				return
			}
		case "Hash":
			z.Hash, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hash")
				return
			}
		case "Name":
			z.Name, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Name")
				return
			}
		case "ClassStart":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClassStart")
				return
			}
			if cap(z.ClassStart) >= int(zb0003) {
				z.ClassStart = (z.ClassStart)[:zb0003]
			} else {
				z.ClassStart = make([]int64, zb0003)
			}
			for za0002 := range z.ClassStart {
				z.ClassStart[za0002], bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ClassStart", za0002)
					return
				}
			}
		case "Keystone":
			z.Keystone, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Keystone")
				return
			}
		case "Notable":
			z.Notable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Notable")
				return
			}
		case "Flavour":
			z.Flavour, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Flavour")
				return
			}
		case "Mastery":
			z.Mastery, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Mastery")
				return
			}
		case "Achievement":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Achievement = nil
			} else {
				if z.Achievement == nil {
					z.Achievement = new(int64)
				}
				*z.Achievement, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Achievement")
					return
				}
			}
		case "JewelSocket":
			z.JewelSocket, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "JewelSocket")
				return
			}
		case "Ascendancy":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Ascendancy = nil
			} else {
				if z.Ascendancy == nil {
					z.Ascendancy = new(int64)
				}
				*z.Ascendancy, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Ascendancy")
					return
				}
			}
		case "AscendancyStart":
			z.AscendancyStart, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "AscendancyStart")
				return
			}
		case "ReminderTexts":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ReminderTexts")
				return
			}
			if cap(z.ReminderTexts) >= int(zb0004) {
				z.ReminderTexts = (z.ReminderTexts)[:zb0004]
			} else {
				z.ReminderTexts = make([]int64, zb0004)
			}
			for za0003 := range z.ReminderTexts {
				z.ReminderTexts[za0003], bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ReminderTexts", za0003)
					return
				}
			}
		case "PassivePointsGranted":
			z.PassivePointsGranted, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PassivePointsGranted")
				return
			}
		case "MultipleChoice":
			z.MultipleChoice, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MultipleChoice")
				return
			}
		case "MultipleChoiceOption":
			z.MultipleChoiceOption, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MultipleChoiceOption")
				return
			}
		case "Stat5":
			z.Stat5, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Stat5")
				return
			}
		case "Buffs":
			var zb0005 uint32
			zb0005, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Buffs")
				return
			}
			if cap(z.Buffs) >= int(zb0005) {
				z.Buffs = (z.Buffs)[:zb0005]
			} else {
				z.Buffs = make([]int64, zb0005)
			}
			for za0004 := range z.Buffs {
				z.Buffs[za0004], bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Buffs", za0004)
					return
				}
			}
		case "GrantedEffect":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.GrantedEffect = nil
			} else {
				if z.GrantedEffect == nil {
					z.GrantedEffect = new(int64)
				}
				*z.GrantedEffect, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GrantedEffect")
					return
				}
			}
		case "Blighted":
			z.Blighted, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Blighted")
				return
			}
		case "ClusterNode":
			z.ClusterNode, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ClusterNode")
				return
			}
		case "Proxy":
			z.Proxy, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Proxy")
				return
			}
		case "Type":
			z.Type, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Type")
				return
			}
		case "MasteryGroup":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MasteryGroup = nil
			} else {
				if z.MasteryGroup == nil {
					z.MasteryGroup = new(int64)
				}
				*z.MasteryGroup, bts, err = msgp.ReadInt64Bytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MasteryGroup")
					return
				}
			}
		case "Key":
			z.Key, bts, err = msgp.ReadInt64Bytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PassiveSkill) Msgsize() (s int) {
	s = 3 + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(z.Icon) + 6 + msgp.ArrayHeaderSize + (len(z.Stats) * (msgp.Int64Size)) + 6 + msgp.Int64Size + 6 + msgp.Int64Size + 6 + msgp.Int64Size + 6 + msgp.Int64Size + 5 + msgp.Int64Size + 5 + msgp.StringPrefixSize + len(z.Name) + 11 + msgp.ArrayHeaderSize + (len(z.ClassStart) * (msgp.Int64Size)) + 9 + msgp.BoolSize + 8 + msgp.BoolSize + 8 + msgp.StringPrefixSize + len(z.Flavour) + 8 + msgp.BoolSize + 12
	if z.Achievement == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 12 + msgp.BoolSize + 11
	if z.Ascendancy == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 16 + msgp.BoolSize + 14 + msgp.ArrayHeaderSize + (len(z.ReminderTexts) * (msgp.Int64Size)) + 21 + msgp.Int64Size + 15 + msgp.BoolSize + 21 + msgp.BoolSize + 6 + msgp.Int64Size + 6 + msgp.ArrayHeaderSize + (len(z.Buffs) * (msgp.Int64Size)) + 14
	if z.GrantedEffect == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 9 + msgp.BoolSize + 12 + msgp.BoolSize + 6 + msgp.BoolSize + 5 + msgp.Int64Size + 13
	if z.MasteryGroup == nil {
		s += msgp.NilSize
	} else {
		s += msgp.Int64Size
	}
	s += 4 + msgp.Int64Size
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PassiveTreeExpansionJewel) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Art":
			z.Art, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Art")
				return
			}
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "MaxNodes":
			z.MaxNodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MaxNodes")
				return
			}
		case "MinNodes":
			z.MinNodes, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MinNodes")
				return
			}
		case "NotableIndices":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "NotableIndices")
				return
			}
			if cap(z.NotableIndices) >= int(zb0002) {
				z.NotableIndices = (z.NotableIndices)[:zb0002]
			} else {
				z.NotableIndices = make([]int, zb0002)
			}
			for za0001 := range z.NotableIndices {
				z.NotableIndices[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "NotableIndices", za0001)
					return
				}
			}
		case "PassiveTreeExpansionJewelSizesKey":
			z.PassiveTreeExpansionJewelSizesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PassiveTreeExpansionJewelSizesKey")
				return
			}
		case "SmallIndices":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SmallIndices")
				return
			}
			if cap(z.SmallIndices) >= int(zb0003) {
				z.SmallIndices = (z.SmallIndices)[:zb0003]
			} else {
				z.SmallIndices = make([]int, zb0003)
			}
			for za0002 := range z.SmallIndices {
				z.SmallIndices[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SmallIndices", za0002)
					return
				}
			}
		case "SocketIndices":
			var zb0004 uint32
			zb0004, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "SocketIndices")
				return
			}
			if cap(z.SocketIndices) >= int(zb0004) {
				z.SocketIndices = (z.SocketIndices)[:zb0004]
			} else {
				z.SocketIndices = make([]int, zb0004)
			}
			for za0003 := range z.SocketIndices {
				z.SocketIndices[za0003], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SocketIndices", za0003)
					return
				}
			}
		case "SoundEffectsKey":
			z.SoundEffectsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SoundEffectsKey")
				return
			}
		case "TotalIndices":
			z.TotalIndices, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotalIndices")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PassiveTreeExpansionJewel) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 11
	// write "Art"
	err = en.Append(0x8b, 0xa3, 0x41, 0x72, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Art)
	if err != nil {
		err = msgp.WrapError(err, "Art")
		return
	}
	// write "BaseItemTypesKey"
	err = en.Append(0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "MaxNodes"
	err = en.Append(0xa8, 0x4d, 0x61, 0x78, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MaxNodes)
	if err != nil {
		err = msgp.WrapError(err, "MaxNodes")
		return
	}
	// write "MinNodes"
	err = en.Append(0xa8, 0x4d, 0x69, 0x6e, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MinNodes)
	if err != nil {
		err = msgp.WrapError(err, "MinNodes")
		return
	}
	// write "NotableIndices"
	err = en.Append(0xae, 0x4e, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.NotableIndices)))
	if err != nil {
		err = msgp.WrapError(err, "NotableIndices")
		return
	}
	for za0001 := range z.NotableIndices {
		err = en.WriteInt(z.NotableIndices[za0001])
		if err != nil {
			err = msgp.WrapError(err, "NotableIndices", za0001)
			return
		}
	}
	// write "PassiveTreeExpansionJewelSizesKey"
	err = en.Append(0xd9, 0x21, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x72, 0x65, 0x65, 0x45, 0x78, 0x70, 0x61, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PassiveTreeExpansionJewelSizesKey)
	if err != nil {
		err = msgp.WrapError(err, "PassiveTreeExpansionJewelSizesKey")
		return
	}
	// write "SmallIndices"
	err = en.Append(0xac, 0x53, 0x6d, 0x61, 0x6c, 0x6c, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SmallIndices)))
	if err != nil {
		err = msgp.WrapError(err, "SmallIndices")
		return
	}
	for za0002 := range z.SmallIndices {
		err = en.WriteInt(z.SmallIndices[za0002])
		if err != nil {
			err = msgp.WrapError(err, "SmallIndices", za0002)
			return
		}
	}
	// write "SocketIndices"
	err = en.Append(0xad, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.SocketIndices)))
	if err != nil {
		err = msgp.WrapError(err, "SocketIndices")
		return
	}
	for za0003 := range z.SocketIndices {
		err = en.WriteInt(z.SocketIndices[za0003])
		if err != nil {
			err = msgp.WrapError(err, "SocketIndices", za0003)
			return
		}
	}
	// write "SoundEffectsKey"
	err = en.Append(0xaf, 0x53, 0x6f, 0x75, 0x6e, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SoundEffectsKey)
	if err != nil {
		err = msgp.WrapError(err, "SoundEffectsKey")
		return
	}
	// write "TotalIndices"
	err = en.Append(0xac, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TotalIndices)
	if err != nil {
		err = msgp.WrapError(err, "TotalIndices")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PassiveTreeExpansionJewel) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 11
	// string "Art"
	o = append(o, 0x8b, 0xa3, 0x41, 0x72, 0x74)
	o = msgp.AppendString(o, z.Art)
	// string "BaseItemTypesKey"
	o = append(o, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.BaseItemTypesKey)
	// string "MaxNodes"
	o = append(o, 0xa8, 0x4d, 0x61, 0x78, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendInt(o, z.MaxNodes)
	// string "MinNodes"
	o = append(o, 0xa8, 0x4d, 0x69, 0x6e, 0x4e, 0x6f, 0x64, 0x65, 0x73)
	o = msgp.AppendInt(o, z.MinNodes)
	// string "NotableIndices"
	o = append(o, 0xae, 0x4e, 0x6f, 0x74, 0x61, 0x62, 0x6c, 0x65, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.NotableIndices)))
	for za0001 := range z.NotableIndices {
		o = msgp.AppendInt(o, z.NotableIndices[za0001])
	}
	// string "PassiveTreeExpansionJewelSizesKey"
	o = append(o, 0xd9, 0x21, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x72, 0x65, 0x65, 0x45, 0x78, 0x70, 0x61, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.PassiveTreeExpansionJewelSizesKey)
	// string "SmallIndices"
	o = append(o, 0xac, 0x53, 0x6d, 0x61, 0x6c, 0x6c, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SmallIndices)))
	for za0002 := range z.SmallIndices {
		o = msgp.AppendInt(o, z.SmallIndices[za0002])
	}
	// string "SocketIndices"
	o = append(o, 0xad, 0x53, 0x6f, 0x63, 0x6b, 0x65, 0x74, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.SocketIndices)))
	for za0003 := range z.SocketIndices {
		o = msgp.AppendInt(o, z.SocketIndices[za0003])
	}
	// string "SoundEffectsKey"
	o = append(o, 0xaf, 0x53, 0x6f, 0x75, 0x6e, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.SoundEffectsKey)
	// string "TotalIndices"
	o = append(o, 0xac, 0x54, 0x6f, 0x74, 0x61, 0x6c, 0x49, 0x6e, 0x64, 0x69, 0x63, 0x65, 0x73)
	o = msgp.AppendInt(o, z.TotalIndices)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PassiveTreeExpansionJewel) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Art":
			z.Art, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Art")
				return
			}
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "MaxNodes":
			z.MaxNodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MaxNodes")
				return
			}
		case "MinNodes":
			z.MinNodes, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MinNodes")
				return
			}
		case "NotableIndices":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "NotableIndices")
				return
			}
			if cap(z.NotableIndices) >= int(zb0002) {
				z.NotableIndices = (z.NotableIndices)[:zb0002]
			} else {
				z.NotableIndices = make([]int, zb0002)
			}
			for za0001 := range z.NotableIndices {
				z.NotableIndices[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "NotableIndices", za0001)
					return
				}
			}
		case "PassiveTreeExpansionJewelSizesKey":
			z.PassiveTreeExpansionJewelSizesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PassiveTreeExpansionJewelSizesKey")
				return
			}
		case "SmallIndices":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SmallIndices")
				return
			}
			if cap(z.SmallIndices) >= int(zb0003) {
				z.SmallIndices = (z.SmallIndices)[:zb0003]
			} else {
				z.SmallIndices = make([]int, zb0003)
			}
			for za0002 := range z.SmallIndices {
				z.SmallIndices[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SmallIndices", za0002)
					return
				}
			}
		case "SocketIndices":
			var zb0004 uint32
			zb0004, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SocketIndices")
				return
			}
			if cap(z.SocketIndices) >= int(zb0004) {
				z.SocketIndices = (z.SocketIndices)[:zb0004]
			} else {
				z.SocketIndices = make([]int, zb0004)
			}
			for za0003 := range z.SocketIndices {
				z.SocketIndices[za0003], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SocketIndices", za0003)
					return
				}
			}
		case "SoundEffectsKey":
			z.SoundEffectsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SoundEffectsKey")
				return
			}
		case "TotalIndices":
			z.TotalIndices, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotalIndices")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PassiveTreeExpansionJewel) Msgsize() (s int) {
	s = 1 + 4 + msgp.StringPrefixSize + len(z.Art) + 17 + msgp.IntSize + 9 + msgp.IntSize + 9 + msgp.IntSize + 15 + msgp.ArrayHeaderSize + (len(z.NotableIndices) * (msgp.IntSize)) + 35 + msgp.IntSize + 13 + msgp.ArrayHeaderSize + (len(z.SmallIndices) * (msgp.IntSize)) + 14 + msgp.ArrayHeaderSize + (len(z.SocketIndices) * (msgp.IntSize)) + 16 + msgp.IntSize + 13 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PassiveTreeExpansionSkill) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MasteryPassiveSkillsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MasteryPassiveSkillsKey")
					return
				}
				z.MasteryPassiveSkillsKey = nil
			} else {
				if z.MasteryPassiveSkillsKey == nil {
					z.MasteryPassiveSkillsKey = new(int)
				}
				*z.MasteryPassiveSkillsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MasteryPassiveSkillsKey")
					return
				}
			}
		case "PassiveSkillsKey":
			z.PassiveSkillsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PassiveSkillsKey")
				return
			}
		case "PassiveTreeExpansionJewelSizesKey":
			z.PassiveTreeExpansionJewelSizesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PassiveTreeExpansionJewelSizesKey")
				return
			}
		case "TagsKey":
			z.TagsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TagsKey")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *PassiveTreeExpansionSkill) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 5
	// write "MasteryPassiveSkillsKey"
	err = en.Append(0x85, 0xb7, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x79, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.MasteryPassiveSkillsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.MasteryPassiveSkillsKey)
		if err != nil {
			err = msgp.WrapError(err, "MasteryPassiveSkillsKey")
			return
		}
	}
	// write "PassiveSkillsKey"
	err = en.Append(0xb0, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PassiveSkillsKey)
	if err != nil {
		err = msgp.WrapError(err, "PassiveSkillsKey")
		return
	}
	// write "PassiveTreeExpansionJewelSizesKey"
	err = en.Append(0xd9, 0x21, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x72, 0x65, 0x65, 0x45, 0x78, 0x70, 0x61, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PassiveTreeExpansionJewelSizesKey)
	if err != nil {
		err = msgp.WrapError(err, "PassiveTreeExpansionJewelSizesKey")
		return
	}
	// write "TagsKey"
	err = en.Append(0xa7, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TagsKey)
	if err != nil {
		err = msgp.WrapError(err, "TagsKey")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *PassiveTreeExpansionSkill) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 5
	// string "MasteryPassiveSkillsKey"
	o = append(o, 0x85, 0xb7, 0x4d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x79, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x4b, 0x65, 0x79)
	if z.MasteryPassiveSkillsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.MasteryPassiveSkillsKey)
	}
	// string "PassiveSkillsKey"
	o = append(o, 0xb0, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.PassiveSkillsKey)
	// string "PassiveTreeExpansionJewelSizesKey"
	o = append(o, 0xd9, 0x21, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x54, 0x72, 0x65, 0x65, 0x45, 0x78, 0x70, 0x61, 0x6e, 0x73, 0x69, 0x6f, 0x6e, 0x4a, 0x65, 0x77, 0x65, 0x6c, 0x53, 0x69, 0x7a, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.PassiveTreeExpansionJewelSizesKey)
	// string "TagsKey"
	o = append(o, 0xa7, 0x54, 0x61, 0x67, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.TagsKey)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PassiveTreeExpansionSkill) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MasteryPassiveSkillsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MasteryPassiveSkillsKey = nil
			} else {
				if z.MasteryPassiveSkillsKey == nil {
					z.MasteryPassiveSkillsKey = new(int)
				}
				*z.MasteryPassiveSkillsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MasteryPassiveSkillsKey")
					return
				}
			}
		case "PassiveSkillsKey":
			z.PassiveSkillsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PassiveSkillsKey")
				return
			}
		case "PassiveTreeExpansionJewelSizesKey":
			z.PassiveTreeExpansionJewelSizesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PassiveTreeExpansionJewelSizesKey")
				return
			}
		case "TagsKey":
			z.TagsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TagsKey")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *PassiveTreeExpansionSkill) Msgsize() (s int) {
	s = 1 + 24
	if z.MasteryPassiveSkillsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 17 + msgp.IntSize + 35 + msgp.IntSize + 8 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *PassiveTreeExpansionSpecialSkill) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "PassiveSkillsKey":
			z.PassiveSkillsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "PassiveSkillsKey")
				return
			}
		case "StatsKey":
			z.StatsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "StatsKey")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z PassiveTreeExpansionSpecialSkill) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "PassiveSkillsKey"
	err = en.Append(0x83, 0xb0, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.PassiveSkillsKey)
	if err != nil {
		err = msgp.WrapError(err, "PassiveSkillsKey")
		return
	}
	// write "StatsKey"
	err = en.Append(0xa8, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.StatsKey)
	if err != nil {
		err = msgp.WrapError(err, "StatsKey")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z PassiveTreeExpansionSpecialSkill) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "PassiveSkillsKey"
	o = append(o, 0x83, 0xb0, 0x50, 0x61, 0x73, 0x73, 0x69, 0x76, 0x65, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.PassiveSkillsKey)
	// string "StatsKey"
	o = append(o, 0xa8, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.StatsKey)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *PassiveTreeExpansionSpecialSkill) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "PassiveSkillsKey":
			z.PassiveSkillsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "PassiveSkillsKey")
				return
			}
		case "StatsKey":
			z.StatsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "StatsKey")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z PassiveTreeExpansionSpecialSkill) Msgsize() (s int) {
	s = 1 + 17 + msgp.IntSize + 9 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *ShieldType) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "Block":
			z.Block, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Block")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z ShieldType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 3
	// write "BaseItemTypesKey"
	err = en.Append(0x83, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "Block"
	err = en.Append(0xa5, 0x42, 0x6c, 0x6f, 0x63, 0x6b)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Block)
	if err != nil {
		err = msgp.WrapError(err, "Block")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z ShieldType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 3
	// string "BaseItemTypesKey"
	o = append(o, 0x83, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.BaseItemTypesKey)
	// string "Block"
	o = append(o, 0xa5, 0x42, 0x6c, 0x6f, 0x63, 0x6b)
	o = msgp.AppendInt(o, z.Block)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *ShieldType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "Block":
			z.Block, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Block")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z ShieldType) Msgsize() (s int) {
	s = 1 + 17 + msgp.IntSize + 6 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SkillGem) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemType":
			z.BaseItemType, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemType")
				return
			}
		case "GrantedEffect":
			z.GrantedEffect, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffect")
				return
			}
		case "Str":
			z.Str, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Str")
				return
			}
		case "Dex":
			z.Dex, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Dex")
				return
			}
		case "Int":
			z.Int, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Int")
				return
			}
		case "Tags":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "Tags")
				return
			}
			if cap(z.Tags) >= int(zb0002) {
				z.Tags = (z.Tags)[:zb0002]
			} else {
				z.Tags = make([]int, zb0002)
			}
			for za0001 := range z.Tags {
				z.Tags[za0001], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Tags", za0001)
					return
				}
			}
		case "VaalGem":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "VaalGem")
					return
				}
				z.VaalGem = nil
			} else {
				if z.VaalGem == nil {
					z.VaalGem = new(int)
				}
				*z.VaalGem, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "VaalGem")
					return
				}
			}
		case "IsVaalGem":
			z.IsVaalGem, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsVaalGem")
				return
			}
		case "Description":
			z.Description, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "HungryLoopMod":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "HungryLoopMod")
					return
				}
				z.HungryLoopMod = nil
			} else {
				if z.HungryLoopMod == nil {
					z.HungryLoopMod = new(int)
				}
				*z.HungryLoopMod, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "HungryLoopMod")
					return
				}
			}
		case "SecondaryGrantedEffect":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "SecondaryGrantedEffect")
					return
				}
				z.SecondaryGrantedEffect = nil
			} else {
				if z.SecondaryGrantedEffect == nil {
					z.SecondaryGrantedEffect = new(int)
				}
				*z.SecondaryGrantedEffect, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "SecondaryGrantedEffect")
					return
				}
			}
		case "GlobalGemLevelStat":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "GlobalGemLevelStat")
					return
				}
				z.GlobalGemLevelStat = nil
			} else {
				if z.GlobalGemLevelStat == nil {
					z.GlobalGemLevelStat = new(int)
				}
				*z.GlobalGemLevelStat, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "GlobalGemLevelStat")
					return
				}
			}
		case "SecondarySupportName":
			z.SecondarySupportName, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "SecondarySupportName")
				return
			}
		case "AwakenedVariant":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "AwakenedVariant")
					return
				}
				z.AwakenedVariant = nil
			} else {
				if z.AwakenedVariant == nil {
					z.AwakenedVariant = new(int)
				}
				*z.AwakenedVariant, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "AwakenedVariant")
					return
				}
			}
		case "RegularVariant":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "RegularVariant")
					return
				}
				z.RegularVariant = nil
			} else {
				if z.RegularVariant == nil {
					z.RegularVariant = new(int)
				}
				*z.RegularVariant, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "RegularVariant")
					return
				}
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SkillGem) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 16
	// write "BaseItemType"
	err = en.Append(0xde, 0x0, 0x10, 0xac, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemType)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemType")
		return
	}
	// write "GrantedEffect"
	err = en.Append(0xad, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.GrantedEffect)
	if err != nil {
		err = msgp.WrapError(err, "GrantedEffect")
		return
	}
	// write "Str"
	err = en.Append(0xa3, 0x53, 0x74, 0x72)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Str)
	if err != nil {
		err = msgp.WrapError(err, "Str")
		return
	}
	// write "Dex"
	err = en.Append(0xa3, 0x44, 0x65, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Dex)
	if err != nil {
		err = msgp.WrapError(err, "Dex")
		return
	}
	// write "Int"
	err = en.Append(0xa3, 0x49, 0x6e, 0x74)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Int)
	if err != nil {
		err = msgp.WrapError(err, "Int")
		return
	}
	// write "Tags"
	err = en.Append(0xa4, 0x54, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.Tags)))
	if err != nil {
		err = msgp.WrapError(err, "Tags")
		return
	}
	for za0001 := range z.Tags {
		err = en.WriteInt(z.Tags[za0001])
		if err != nil {
			err = msgp.WrapError(err, "Tags", za0001)
			return
		}
	}
	// write "VaalGem"
	err = en.Append(0xa7, 0x56, 0x61, 0x61, 0x6c, 0x47, 0x65, 0x6d)
	if err != nil {
		return
	}
	if z.VaalGem == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.VaalGem)
		if err != nil {
			err = msgp.WrapError(err, "VaalGem")
			return
		}
	}
	// write "IsVaalGem"
	err = en.Append(0xa9, 0x49, 0x73, 0x56, 0x61, 0x61, 0x6c, 0x47, 0x65, 0x6d)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsVaalGem)
	if err != nil {
		err = msgp.WrapError(err, "IsVaalGem")
		return
	}
	// write "Description"
	err = en.Append(0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteString(z.Description)
	if err != nil {
		err = msgp.WrapError(err, "Description")
		return
	}
	// write "HungryLoopMod"
	err = en.Append(0xad, 0x48, 0x75, 0x6e, 0x67, 0x72, 0x79, 0x4c, 0x6f, 0x6f, 0x70, 0x4d, 0x6f, 0x64)
	if err != nil {
		return
	}
	if z.HungryLoopMod == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.HungryLoopMod)
		if err != nil {
			err = msgp.WrapError(err, "HungryLoopMod")
			return
		}
	}
	// write "SecondaryGrantedEffect"
	err = en.Append(0xb6, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x61, 0x72, 0x79, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if err != nil {
		return
	}
	if z.SecondaryGrantedEffect == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.SecondaryGrantedEffect)
		if err != nil {
			err = msgp.WrapError(err, "SecondaryGrantedEffect")
			return
		}
	}
	// write "GlobalGemLevelStat"
	err = en.Append(0xb2, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x47, 0x65, 0x6d, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74)
	if err != nil {
		return
	}
	if z.GlobalGemLevelStat == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.GlobalGemLevelStat)
		if err != nil {
			err = msgp.WrapError(err, "GlobalGemLevelStat")
			return
		}
	}
	// write "SecondarySupportName"
	err = en.Append(0xb4, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x61, 0x72, 0x79, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(z.SecondarySupportName)
	if err != nil {
		err = msgp.WrapError(err, "SecondarySupportName")
		return
	}
	// write "AwakenedVariant"
	err = en.Append(0xaf, 0x41, 0x77, 0x61, 0x6b, 0x65, 0x6e, 0x65, 0x64, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74)
	if err != nil {
		return
	}
	if z.AwakenedVariant == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.AwakenedVariant)
		if err != nil {
			err = msgp.WrapError(err, "AwakenedVariant")
			return
		}
	}
	// write "RegularVariant"
	err = en.Append(0xae, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74)
	if err != nil {
		return
	}
	if z.RegularVariant == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.RegularVariant)
		if err != nil {
			err = msgp.WrapError(err, "RegularVariant")
			return
		}
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SkillGem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 16
	// string "BaseItemType"
	o = append(o, 0xde, 0x0, 0x10, 0xac, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65)
	o = msgp.AppendInt(o, z.BaseItemType)
	// string "GrantedEffect"
	o = append(o, 0xad, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	o = msgp.AppendInt(o, z.GrantedEffect)
	// string "Str"
	o = append(o, 0xa3, 0x53, 0x74, 0x72)
	o = msgp.AppendInt(o, z.Str)
	// string "Dex"
	o = append(o, 0xa3, 0x44, 0x65, 0x78)
	o = msgp.AppendInt(o, z.Dex)
	// string "Int"
	o = append(o, 0xa3, 0x49, 0x6e, 0x74)
	o = msgp.AppendInt(o, z.Int)
	// string "Tags"
	o = append(o, 0xa4, 0x54, 0x61, 0x67, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.Tags)))
	for za0001 := range z.Tags {
		o = msgp.AppendInt(o, z.Tags[za0001])
	}
	// string "VaalGem"
	o = append(o, 0xa7, 0x56, 0x61, 0x61, 0x6c, 0x47, 0x65, 0x6d)
	if z.VaalGem == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.VaalGem)
	}
	// string "IsVaalGem"
	o = append(o, 0xa9, 0x49, 0x73, 0x56, 0x61, 0x61, 0x6c, 0x47, 0x65, 0x6d)
	o = msgp.AppendBool(o, z.IsVaalGem)
	// string "Description"
	o = append(o, 0xab, 0x44, 0x65, 0x73, 0x63, 0x72, 0x69, 0x70, 0x74, 0x69, 0x6f, 0x6e)
	o = msgp.AppendString(o, z.Description)
	// string "HungryLoopMod"
	o = append(o, 0xad, 0x48, 0x75, 0x6e, 0x67, 0x72, 0x79, 0x4c, 0x6f, 0x6f, 0x70, 0x4d, 0x6f, 0x64)
	if z.HungryLoopMod == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.HungryLoopMod)
	}
	// string "SecondaryGrantedEffect"
	o = append(o, 0xb6, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x61, 0x72, 0x79, 0x47, 0x72, 0x61, 0x6e, 0x74, 0x65, 0x64, 0x45, 0x66, 0x66, 0x65, 0x63, 0x74)
	if z.SecondaryGrantedEffect == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.SecondaryGrantedEffect)
	}
	// string "GlobalGemLevelStat"
	o = append(o, 0xb2, 0x47, 0x6c, 0x6f, 0x62, 0x61, 0x6c, 0x47, 0x65, 0x6d, 0x4c, 0x65, 0x76, 0x65, 0x6c, 0x53, 0x74, 0x61, 0x74)
	if z.GlobalGemLevelStat == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.GlobalGemLevelStat)
	}
	// string "SecondarySupportName"
	o = append(o, 0xb4, 0x53, 0x65, 0x63, 0x6f, 0x6e, 0x64, 0x61, 0x72, 0x79, 0x53, 0x75, 0x70, 0x70, 0x6f, 0x72, 0x74, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, z.SecondarySupportName)
	// string "AwakenedVariant"
	o = append(o, 0xaf, 0x41, 0x77, 0x61, 0x6b, 0x65, 0x6e, 0x65, 0x64, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74)
	if z.AwakenedVariant == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.AwakenedVariant)
	}
	// string "RegularVariant"
	o = append(o, 0xae, 0x52, 0x65, 0x67, 0x75, 0x6c, 0x61, 0x72, 0x56, 0x61, 0x72, 0x69, 0x61, 0x6e, 0x74)
	if z.RegularVariant == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.RegularVariant)
	}
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SkillGem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemType":
			z.BaseItemType, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemType")
				return
			}
		case "GrantedEffect":
			z.GrantedEffect, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "GrantedEffect")
				return
			}
		case "Str":
			z.Str, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Str")
				return
			}
		case "Dex":
			z.Dex, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Dex")
				return
			}
		case "Int":
			z.Int, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Int")
				return
			}
		case "Tags":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Tags")
				return
			}
			if cap(z.Tags) >= int(zb0002) {
				z.Tags = (z.Tags)[:zb0002]
			} else {
				z.Tags = make([]int, zb0002)
			}
			for za0001 := range z.Tags {
				z.Tags[za0001], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Tags", za0001)
					return
				}
			}
		case "VaalGem":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.VaalGem = nil
			} else {
				if z.VaalGem == nil {
					z.VaalGem = new(int)
				}
				*z.VaalGem, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "VaalGem")
					return
				}
			}
		case "IsVaalGem":
			z.IsVaalGem, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsVaalGem")
				return
			}
		case "Description":
			z.Description, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Description")
				return
			}
		case "HungryLoopMod":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.HungryLoopMod = nil
			} else {
				if z.HungryLoopMod == nil {
					z.HungryLoopMod = new(int)
				}
				*z.HungryLoopMod, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "HungryLoopMod")
					return
				}
			}
		case "SecondaryGrantedEffect":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.SecondaryGrantedEffect = nil
			} else {
				if z.SecondaryGrantedEffect == nil {
					z.SecondaryGrantedEffect = new(int)
				}
				*z.SecondaryGrantedEffect, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "SecondaryGrantedEffect")
					return
				}
			}
		case "GlobalGemLevelStat":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.GlobalGemLevelStat = nil
			} else {
				if z.GlobalGemLevelStat == nil {
					z.GlobalGemLevelStat = new(int)
				}
				*z.GlobalGemLevelStat, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "GlobalGemLevelStat")
					return
				}
			}
		case "SecondarySupportName":
			z.SecondarySupportName, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SecondarySupportName")
				return
			}
		case "AwakenedVariant":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.AwakenedVariant = nil
			} else {
				if z.AwakenedVariant == nil {
					z.AwakenedVariant = new(int)
				}
				*z.AwakenedVariant, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "AwakenedVariant")
					return
				}
			}
		case "RegularVariant":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.RegularVariant = nil
			} else {
				if z.RegularVariant == nil {
					z.RegularVariant = new(int)
				}
				*z.RegularVariant, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "RegularVariant")
					return
				}
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SkillGem) Msgsize() (s int) {
	s = 3 + 13 + msgp.IntSize + 14 + msgp.IntSize + 4 + msgp.IntSize + 4 + msgp.IntSize + 4 + msgp.IntSize + 5 + msgp.ArrayHeaderSize + (len(z.Tags) * (msgp.IntSize)) + 8
	if z.VaalGem == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10 + msgp.BoolSize + 12 + msgp.StringPrefixSize + len(z.Description) + 14
	if z.HungryLoopMod == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 23
	if z.SecondaryGrantedEffect == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 19
	if z.GlobalGemLevelStat == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21 + msgp.StringPrefixSize + len(z.SecondarySupportName) + 16
	if z.AwakenedVariant == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 15
	if z.RegularVariant == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SkillTotem) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z SkillTotem) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 1
	// write "Key"
	err = en.Append(0x81, 0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z SkillTotem) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 1
	// string "Key"
	o = append(o, 0x81, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SkillTotem) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z SkillTotem) Msgsize() (s int) {
	s = 1 + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *SkillTotemVariation) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MonsterVarietiesKey":
			z.MonsterVarietiesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "MonsterVarietiesKey")
				return
			}
		case "SkillTotemsKey":
			z.SkillTotemsKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "SkillTotemsKey")
				return
			}
		case "TotemSkinID":
			z.TotemSkinID, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "TotemSkinID")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *SkillTotemVariation) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "MonsterVarietiesKey"
	err = en.Append(0x84, 0xb3, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x56, 0x61, 0x72, 0x69, 0x65, 0x74, 0x69, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.MonsterVarietiesKey)
	if err != nil {
		err = msgp.WrapError(err, "MonsterVarietiesKey")
		return
	}
	// write "SkillTotemsKey"
	err = en.Append(0xae, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.SkillTotemsKey)
	if err != nil {
		err = msgp.WrapError(err, "SkillTotemsKey")
		return
	}
	// write "TotemSkinID"
	err = en.Append(0xab, 0x54, 0x6f, 0x74, 0x65, 0x6d, 0x53, 0x6b, 0x69, 0x6e, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteInt(z.TotemSkinID)
	if err != nil {
		err = msgp.WrapError(err, "TotemSkinID")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *SkillTotemVariation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "MonsterVarietiesKey"
	o = append(o, 0x84, 0xb3, 0x4d, 0x6f, 0x6e, 0x73, 0x74, 0x65, 0x72, 0x56, 0x61, 0x72, 0x69, 0x65, 0x74, 0x69, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.MonsterVarietiesKey)
	// string "SkillTotemsKey"
	o = append(o, 0xae, 0x53, 0x6b, 0x69, 0x6c, 0x6c, 0x54, 0x6f, 0x74, 0x65, 0x6d, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.SkillTotemsKey)
	// string "TotemSkinID"
	o = append(o, 0xab, 0x54, 0x6f, 0x74, 0x65, 0x6d, 0x53, 0x6b, 0x69, 0x6e, 0x49, 0x44)
	o = msgp.AppendInt(o, z.TotemSkinID)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *SkillTotemVariation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "MonsterVarietiesKey":
			z.MonsterVarietiesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "MonsterVarietiesKey")
				return
			}
		case "SkillTotemsKey":
			z.SkillTotemsKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "SkillTotemsKey")
				return
			}
		case "TotemSkinID":
			z.TotemSkinID, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "TotemSkinID")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *SkillTotemVariation) Msgsize() (s int) {
	s = 1 + 20 + msgp.IntSize + 15 + msgp.IntSize + 12 + msgp.IntSize + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Stat) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BelongsStatsKey":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "BelongsStatsKey")
				return
			}
			if cap(z.BelongsStatsKey) >= int(zb0002) {
				z.BelongsStatsKey = (z.BelongsStatsKey)[:zb0002]
			} else {
				z.BelongsStatsKey = make([]string, zb0002)
			}
			for za0001 := range z.BelongsStatsKey {
				z.BelongsStatsKey[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "BelongsStatsKey", za0001)
					return
				}
			}
		case "Category":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "Category")
					return
				}
				z.Category = nil
			} else {
				if z.Category == nil {
					z.Category = new(int)
				}
				*z.Category, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "Category")
					return
				}
			}
		case "ContextFlags":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "ContextFlags")
				return
			}
			if cap(z.ContextFlags) >= int(zb0003) {
				z.ContextFlags = (z.ContextFlags)[:zb0003]
			} else {
				z.ContextFlags = make([]int, zb0003)
			}
			for za0002 := range z.ContextFlags {
				z.ContextFlags[za0002], err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "ContextFlags", za0002)
					return
				}
			}
		case "Hash32":
			z.Hash32, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Hash32")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IsLocal":
			z.IsLocal, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsLocal")
				return
			}
		case "IsScalable":
			z.IsScalable, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsScalable")
				return
			}
		case "IsVirtual":
			z.IsVirtual, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsVirtual")
				return
			}
		case "IsWeaponLocal":
			z.IsWeaponLocal, err = dc.ReadBool()
			if err != nil {
				err = msgp.WrapError(err, "IsWeaponLocal")
				return
			}
		case "MainHandAliasStatsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "MainHandAliasStatsKey")
					return
				}
				z.MainHandAliasStatsKey = nil
			} else {
				if z.MainHandAliasStatsKey == nil {
					z.MainHandAliasStatsKey = new(int)
				}
				*z.MainHandAliasStatsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "MainHandAliasStatsKey")
					return
				}
			}
		case "OffHandAliasStatsKey":
			if dc.IsNil() {
				err = dc.ReadNil()
				if err != nil {
					err = msgp.WrapError(err, "OffHandAliasStatsKey")
					return
				}
				z.OffHandAliasStatsKey = nil
			} else {
				if z.OffHandAliasStatsKey == nil {
					z.OffHandAliasStatsKey = new(int)
				}
				*z.OffHandAliasStatsKey, err = dc.ReadInt()
				if err != nil {
					err = msgp.WrapError(err, "OffHandAliasStatsKey")
					return
				}
			}
		case "Semantics":
			z.Semantics, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Semantics")
				return
			}
		case "Text":
			z.Text, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "Text")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Stat) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 14
	// write "BelongsStatsKey"
	err = en.Append(0x8e, 0xaf, 0x42, 0x65, 0x6c, 0x6f, 0x6e, 0x67, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.BelongsStatsKey)))
	if err != nil {
		err = msgp.WrapError(err, "BelongsStatsKey")
		return
	}
	for za0001 := range z.BelongsStatsKey {
		err = en.WriteString(z.BelongsStatsKey[za0001])
		if err != nil {
			err = msgp.WrapError(err, "BelongsStatsKey", za0001)
			return
		}
	}
	// write "Category"
	err = en.Append(0xa8, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	if err != nil {
		return
	}
	if z.Category == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.Category)
		if err != nil {
			err = msgp.WrapError(err, "Category")
			return
		}
	}
	// write "ContextFlags"
	err = en.Append(0xac, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x46, 0x6c, 0x61, 0x67, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.ContextFlags)))
	if err != nil {
		err = msgp.WrapError(err, "ContextFlags")
		return
	}
	for za0002 := range z.ContextFlags {
		err = en.WriteInt(z.ContextFlags[za0002])
		if err != nil {
			err = msgp.WrapError(err, "ContextFlags", za0002)
			return
		}
	}
	// write "Hash32"
	err = en.Append(0xa6, 0x48, 0x61, 0x73, 0x68, 0x33, 0x32)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Hash32)
	if err != nil {
		err = msgp.WrapError(err, "Hash32")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "IsLocal"
	err = en.Append(0xa7, 0x49, 0x73, 0x4c, 0x6f, 0x63, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsLocal)
	if err != nil {
		err = msgp.WrapError(err, "IsLocal")
		return
	}
	// write "IsScalable"
	err = en.Append(0xaa, 0x49, 0x73, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x62, 0x6c, 0x65)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsScalable)
	if err != nil {
		err = msgp.WrapError(err, "IsScalable")
		return
	}
	// write "IsVirtual"
	err = en.Append(0xa9, 0x49, 0x73, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsVirtual)
	if err != nil {
		err = msgp.WrapError(err, "IsVirtual")
		return
	}
	// write "IsWeaponLocal"
	err = en.Append(0xad, 0x49, 0x73, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4c, 0x6f, 0x63, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteBool(z.IsWeaponLocal)
	if err != nil {
		err = msgp.WrapError(err, "IsWeaponLocal")
		return
	}
	// write "MainHandAliasStatsKey"
	err = en.Append(0xb5, 0x4d, 0x61, 0x69, 0x6e, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x6c, 0x69, 0x61, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.MainHandAliasStatsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.MainHandAliasStatsKey)
		if err != nil {
			err = msgp.WrapError(err, "MainHandAliasStatsKey")
			return
		}
	}
	// write "OffHandAliasStatsKey"
	err = en.Append(0xb4, 0x4f, 0x66, 0x66, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x6c, 0x69, 0x61, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	if z.OffHandAliasStatsKey == nil {
		err = en.WriteNil()
		if err != nil {
			return
		}
	} else {
		err = en.WriteInt(*z.OffHandAliasStatsKey)
		if err != nil {
			err = msgp.WrapError(err, "OffHandAliasStatsKey")
			return
		}
	}
	// write "Semantics"
	err = en.Append(0xa9, 0x53, 0x65, 0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x73)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Semantics)
	if err != nil {
		err = msgp.WrapError(err, "Semantics")
		return
	}
	// write "Text"
	err = en.Append(0xa4, 0x54, 0x65, 0x78, 0x74)
	if err != nil {
		return
	}
	err = en.WriteString(z.Text)
	if err != nil {
		err = msgp.WrapError(err, "Text")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Stat) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 14
	// string "BelongsStatsKey"
	o = append(o, 0x8e, 0xaf, 0x42, 0x65, 0x6c, 0x6f, 0x6e, 0x67, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendArrayHeader(o, uint32(len(z.BelongsStatsKey)))
	for za0001 := range z.BelongsStatsKey {
		o = msgp.AppendString(o, z.BelongsStatsKey[za0001])
	}
	// string "Category"
	o = append(o, 0xa8, 0x43, 0x61, 0x74, 0x65, 0x67, 0x6f, 0x72, 0x79)
	if z.Category == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.Category)
	}
	// string "ContextFlags"
	o = append(o, 0xac, 0x43, 0x6f, 0x6e, 0x74, 0x65, 0x78, 0x74, 0x46, 0x6c, 0x61, 0x67, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.ContextFlags)))
	for za0002 := range z.ContextFlags {
		o = msgp.AppendInt(o, z.ContextFlags[za0002])
	}
	// string "Hash32"
	o = append(o, 0xa6, 0x48, 0x61, 0x73, 0x68, 0x33, 0x32)
	o = msgp.AppendInt(o, z.Hash32)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "IsLocal"
	o = append(o, 0xa7, 0x49, 0x73, 0x4c, 0x6f, 0x63, 0x61, 0x6c)
	o = msgp.AppendBool(o, z.IsLocal)
	// string "IsScalable"
	o = append(o, 0xaa, 0x49, 0x73, 0x53, 0x63, 0x61, 0x6c, 0x61, 0x62, 0x6c, 0x65)
	o = msgp.AppendBool(o, z.IsScalable)
	// string "IsVirtual"
	o = append(o, 0xa9, 0x49, 0x73, 0x56, 0x69, 0x72, 0x74, 0x75, 0x61, 0x6c)
	o = msgp.AppendBool(o, z.IsVirtual)
	// string "IsWeaponLocal"
	o = append(o, 0xad, 0x49, 0x73, 0x57, 0x65, 0x61, 0x70, 0x6f, 0x6e, 0x4c, 0x6f, 0x63, 0x61, 0x6c)
	o = msgp.AppendBool(o, z.IsWeaponLocal)
	// string "MainHandAliasStatsKey"
	o = append(o, 0xb5, 0x4d, 0x61, 0x69, 0x6e, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x6c, 0x69, 0x61, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if z.MainHandAliasStatsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.MainHandAliasStatsKey)
	}
	// string "OffHandAliasStatsKey"
	o = append(o, 0xb4, 0x4f, 0x66, 0x66, 0x48, 0x61, 0x6e, 0x64, 0x41, 0x6c, 0x69, 0x61, 0x73, 0x53, 0x74, 0x61, 0x74, 0x73, 0x4b, 0x65, 0x79)
	if z.OffHandAliasStatsKey == nil {
		o = msgp.AppendNil(o)
	} else {
		o = msgp.AppendInt(o, *z.OffHandAliasStatsKey)
	}
	// string "Semantics"
	o = append(o, 0xa9, 0x53, 0x65, 0x6d, 0x61, 0x6e, 0x74, 0x69, 0x63, 0x73)
	o = msgp.AppendInt(o, z.Semantics)
	// string "Text"
	o = append(o, 0xa4, 0x54, 0x65, 0x78, 0x74)
	o = msgp.AppendString(o, z.Text)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Stat) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BelongsStatsKey":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BelongsStatsKey")
				return
			}
			if cap(z.BelongsStatsKey) >= int(zb0002) {
				z.BelongsStatsKey = (z.BelongsStatsKey)[:zb0002]
			} else {
				z.BelongsStatsKey = make([]string, zb0002)
			}
			for za0001 := range z.BelongsStatsKey {
				z.BelongsStatsKey[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "BelongsStatsKey", za0001)
					return
				}
			}
		case "Category":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.Category = nil
			} else {
				if z.Category == nil {
					z.Category = new(int)
				}
				*z.Category, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Category")
					return
				}
			}
		case "ContextFlags":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ContextFlags")
				return
			}
			if cap(z.ContextFlags) >= int(zb0003) {
				z.ContextFlags = (z.ContextFlags)[:zb0003]
			} else {
				z.ContextFlags = make([]int, zb0003)
			}
			for za0002 := range z.ContextFlags {
				z.ContextFlags[za0002], bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "ContextFlags", za0002)
					return
				}
			}
		case "Hash32":
			z.Hash32, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Hash32")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "IsLocal":
			z.IsLocal, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsLocal")
				return
			}
		case "IsScalable":
			z.IsScalable, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsScalable")
				return
			}
		case "IsVirtual":
			z.IsVirtual, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsVirtual")
				return
			}
		case "IsWeaponLocal":
			z.IsWeaponLocal, bts, err = msgp.ReadBoolBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IsWeaponLocal")
				return
			}
		case "MainHandAliasStatsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.MainHandAliasStatsKey = nil
			} else {
				if z.MainHandAliasStatsKey == nil {
					z.MainHandAliasStatsKey = new(int)
				}
				*z.MainHandAliasStatsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "MainHandAliasStatsKey")
					return
				}
			}
		case "OffHandAliasStatsKey":
			if msgp.IsNil(bts) {
				bts, err = msgp.ReadNilBytes(bts)
				if err != nil {
					return
				}
				z.OffHandAliasStatsKey = nil
			} else {
				if z.OffHandAliasStatsKey == nil {
					z.OffHandAliasStatsKey = new(int)
				}
				*z.OffHandAliasStatsKey, bts, err = msgp.ReadIntBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "OffHandAliasStatsKey")
					return
				}
			}
		case "Semantics":
			z.Semantics, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Semantics")
				return
			}
		case "Text":
			z.Text, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Text")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Stat) Msgsize() (s int) {
	s = 1 + 16 + msgp.ArrayHeaderSize
	for za0001 := range z.BelongsStatsKey {
		s += msgp.StringPrefixSize + len(z.BelongsStatsKey[za0001])
	}
	s += 9
	if z.Category == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 13 + msgp.ArrayHeaderSize + (len(z.ContextFlags) * (msgp.IntSize)) + 7 + msgp.IntSize + 3 + msgp.StringPrefixSize + len(z.ID) + 8 + msgp.BoolSize + 11 + msgp.BoolSize + 10 + msgp.BoolSize + 14 + msgp.BoolSize + 22
	if z.MainHandAliasStatsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 21
	if z.OffHandAliasStatsKey == nil {
		s += msgp.NilSize
	} else {
		s += msgp.IntSize
	}
	s += 10 + msgp.IntSize + 5 + msgp.StringPrefixSize + len(z.Text) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *StatTranslation) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "IDs":
			var zb0002 uint32
			zb0002, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "IDs")
				return
			}
			if cap(z.IDs) >= int(zb0002) {
				z.IDs = (z.IDs)[:zb0002]
			} else {
				z.IDs = make([]string, zb0002)
			}
			for za0001 := range z.IDs {
				z.IDs[za0001], err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "IDs", za0001)
					return
				}
			}
		case "List":
			var zb0003 uint32
			zb0003, err = dc.ReadArrayHeader()
			if err != nil {
				err = msgp.WrapError(err, "List")
				return
			}
			if cap(z.List) >= int(zb0003) {
				z.List = (z.List)[:zb0003]
			} else {
				z.List = make([]LangTranslation, zb0003)
			}
			for za0002 := range z.List {
				err = z.List[za0002].DecodeMsg(dc)
				if err != nil {
					err = msgp.WrapError(err, "List", za0002)
					return
				}
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *StatTranslation) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 2
	// write "IDs"
	err = en.Append(0x82, 0xa3, 0x49, 0x44, 0x73)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.IDs)))
	if err != nil {
		err = msgp.WrapError(err, "IDs")
		return
	}
	for za0001 := range z.IDs {
		err = en.WriteString(z.IDs[za0001])
		if err != nil {
			err = msgp.WrapError(err, "IDs", za0001)
			return
		}
	}
	// write "List"
	err = en.Append(0xa4, 0x4c, 0x69, 0x73, 0x74)
	if err != nil {
		return
	}
	err = en.WriteArrayHeader(uint32(len(z.List)))
	if err != nil {
		err = msgp.WrapError(err, "List")
		return
	}
	for za0002 := range z.List {
		err = z.List[za0002].EncodeMsg(en)
		if err != nil {
			err = msgp.WrapError(err, "List", za0002)
			return
		}
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *StatTranslation) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 2
	// string "IDs"
	o = append(o, 0x82, 0xa3, 0x49, 0x44, 0x73)
	o = msgp.AppendArrayHeader(o, uint32(len(z.IDs)))
	for za0001 := range z.IDs {
		o = msgp.AppendString(o, z.IDs[za0001])
	}
	// string "List"
	o = append(o, 0xa4, 0x4c, 0x69, 0x73, 0x74)
	o = msgp.AppendArrayHeader(o, uint32(len(z.List)))
	for za0002 := range z.List {
		o, err = z.List[za0002].MarshalMsg(o)
		if err != nil {
			err = msgp.WrapError(err, "List", za0002)
			return
		}
	}
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *StatTranslation) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "IDs":
			var zb0002 uint32
			zb0002, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "IDs")
				return
			}
			if cap(z.IDs) >= int(zb0002) {
				z.IDs = (z.IDs)[:zb0002]
			} else {
				z.IDs = make([]string, zb0002)
			}
			for za0001 := range z.IDs {
				z.IDs[za0001], bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "IDs", za0001)
					return
				}
			}
		case "List":
			var zb0003 uint32
			zb0003, bts, err = msgp.ReadArrayHeaderBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "List")
				return
			}
			if cap(z.List) >= int(zb0003) {
				z.List = (z.List)[:zb0003]
			} else {
				z.List = make([]LangTranslation, zb0003)
			}
			for za0002 := range z.List {
				bts, err = z.List[za0002].UnmarshalMsg(bts)
				if err != nil {
					err = msgp.WrapError(err, "List", za0002)
					return
				}
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *StatTranslation) Msgsize() (s int) {
	s = 1 + 4 + msgp.ArrayHeaderSize
	for za0001 := range z.IDs {
		s += msgp.StringPrefixSize + len(z.IDs[za0001])
	}
	s += 5 + msgp.ArrayHeaderSize
	for za0002 := range z.List {
		s += z.List[za0002].Msgsize()
	}
	return
}

// DecodeMsg implements msgp.Decodable
func (z *Tag) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DisplayString":
			z.DisplayString, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "DisplayString")
				return
			}
		case "ID":
			z.ID, err = dc.ReadString()
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Name":
			{
				var zb0002 string
				zb0002, err = dc.ReadString()
				if err != nil {
					err = msgp.WrapError(err, "Name")
					return
				}
				z.Name = TagName(zb0002)
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *Tag) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 4
	// write "DisplayString"
	err = en.Append(0x84, 0xad, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	if err != nil {
		return
	}
	err = en.WriteString(z.DisplayString)
	if err != nil {
		err = msgp.WrapError(err, "DisplayString")
		return
	}
	// write "ID"
	err = en.Append(0xa2, 0x49, 0x44)
	if err != nil {
		return
	}
	err = en.WriteString(z.ID)
	if err != nil {
		err = msgp.WrapError(err, "ID")
		return
	}
	// write "Name"
	err = en.Append(0xa4, 0x4e, 0x61, 0x6d, 0x65)
	if err != nil {
		return
	}
	err = en.WriteString(string(z.Name))
	if err != nil {
		err = msgp.WrapError(err, "Name")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *Tag) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 4
	// string "DisplayString"
	o = append(o, 0x84, 0xad, 0x44, 0x69, 0x73, 0x70, 0x6c, 0x61, 0x79, 0x53, 0x74, 0x72, 0x69, 0x6e, 0x67)
	o = msgp.AppendString(o, z.DisplayString)
	// string "ID"
	o = append(o, 0xa2, 0x49, 0x44)
	o = msgp.AppendString(o, z.ID)
	// string "Name"
	o = append(o, 0xa4, 0x4e, 0x61, 0x6d, 0x65)
	o = msgp.AppendString(o, string(z.Name))
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *Tag) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "DisplayString":
			z.DisplayString, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DisplayString")
				return
			}
		case "ID":
			z.ID, bts, err = msgp.ReadStringBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "ID")
				return
			}
		case "Name":
			{
				var zb0002 string
				zb0002, bts, err = msgp.ReadStringBytes(bts)
				if err != nil {
					err = msgp.WrapError(err, "Name")
					return
				}
				z.Name = TagName(zb0002)
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *Tag) Msgsize() (s int) {
	s = 1 + 14 + msgp.StringPrefixSize + len(z.DisplayString) + 3 + msgp.StringPrefixSize + len(z.ID) + 5 + msgp.StringPrefixSize + len(string(z.Name)) + 4 + msgp.IntSize
	return
}

// DecodeMsg implements msgp.Decodable
func (z *TagName) DecodeMsg(dc *msgp.Reader) (err error) {
	{
		var zb0001 string
		zb0001, err = dc.ReadString()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = TagName(zb0001)
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z TagName) EncodeMsg(en *msgp.Writer) (err error) {
	err = en.WriteString(string(z))
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z TagName) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	o = msgp.AppendString(o, string(z))
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *TagName) UnmarshalMsg(bts []byte) (o []byte, err error) {
	{
		var zb0001 string
		zb0001, bts, err = msgp.ReadStringBytes(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		(*z) = TagName(zb0001)
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z TagName) Msgsize() (s int) {
	s = msgp.StringPrefixSize + len(string(z))
	return
}

// DecodeMsg implements msgp.Decodable
func (z *WeaponType) DecodeMsg(dc *msgp.Reader) (err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, err = dc.ReadMapHeader()
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, err = dc.ReadMapKeyPtr()
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "Critical":
			z.Critical, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Critical")
				return
			}
		case "DamageMax":
			z.DamageMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DamageMax")
				return
			}
		case "DamageMin":
			z.DamageMin, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "DamageMin")
				return
			}
		case "Null6":
			z.Null6, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Null6")
				return
			}
		case "RangeMax":
			z.RangeMax, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "RangeMax")
				return
			}
		case "Speed":
			z.Speed, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Speed")
				return
			}
		case "Key":
			z.Key, err = dc.ReadInt()
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			err = dc.Skip()
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	return
}

// EncodeMsg implements msgp.Encodable
func (z *WeaponType) EncodeMsg(en *msgp.Writer) (err error) {
	// map header, size 8
	// write "BaseItemTypesKey"
	err = en.Append(0x88, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.BaseItemTypesKey)
	if err != nil {
		err = msgp.WrapError(err, "BaseItemTypesKey")
		return
	}
	// write "Critical"
	err = en.Append(0xa8, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Critical)
	if err != nil {
		err = msgp.WrapError(err, "Critical")
		return
	}
	// write "DamageMax"
	err = en.Append(0xa9, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DamageMax)
	if err != nil {
		err = msgp.WrapError(err, "DamageMax")
		return
	}
	// write "DamageMin"
	err = en.Append(0xa9, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x69, 0x6e)
	if err != nil {
		return
	}
	err = en.WriteInt(z.DamageMin)
	if err != nil {
		err = msgp.WrapError(err, "DamageMin")
		return
	}
	// write "Null6"
	err = en.Append(0xa5, 0x4e, 0x75, 0x6c, 0x6c, 0x36)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Null6)
	if err != nil {
		err = msgp.WrapError(err, "Null6")
		return
	}
	// write "RangeMax"
	err = en.Append(0xa8, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x4d, 0x61, 0x78)
	if err != nil {
		return
	}
	err = en.WriteInt(z.RangeMax)
	if err != nil {
		err = msgp.WrapError(err, "RangeMax")
		return
	}
	// write "Speed"
	err = en.Append(0xa5, 0x53, 0x70, 0x65, 0x65, 0x64)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Speed)
	if err != nil {
		err = msgp.WrapError(err, "Speed")
		return
	}
	// write "Key"
	err = en.Append(0xa3, 0x4b, 0x65, 0x79)
	if err != nil {
		return
	}
	err = en.WriteInt(z.Key)
	if err != nil {
		err = msgp.WrapError(err, "Key")
		return
	}
	return
}

// MarshalMsg implements msgp.Marshaler
func (z *WeaponType) MarshalMsg(b []byte) (o []byte, err error) {
	o = msgp.Require(b, z.Msgsize())
	// map header, size 8
	// string "BaseItemTypesKey"
	o = append(o, 0x88, 0xb0, 0x42, 0x61, 0x73, 0x65, 0x49, 0x74, 0x65, 0x6d, 0x54, 0x79, 0x70, 0x65, 0x73, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.BaseItemTypesKey)
	// string "Critical"
	o = append(o, 0xa8, 0x43, 0x72, 0x69, 0x74, 0x69, 0x63, 0x61, 0x6c)
	o = msgp.AppendInt(o, z.Critical)
	// string "DamageMax"
	o = append(o, 0xa9, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.DamageMax)
	// string "DamageMin"
	o = append(o, 0xa9, 0x44, 0x61, 0x6d, 0x61, 0x67, 0x65, 0x4d, 0x69, 0x6e)
	o = msgp.AppendInt(o, z.DamageMin)
	// string "Null6"
	o = append(o, 0xa5, 0x4e, 0x75, 0x6c, 0x6c, 0x36)
	o = msgp.AppendInt(o, z.Null6)
	// string "RangeMax"
	o = append(o, 0xa8, 0x52, 0x61, 0x6e, 0x67, 0x65, 0x4d, 0x61, 0x78)
	o = msgp.AppendInt(o, z.RangeMax)
	// string "Speed"
	o = append(o, 0xa5, 0x53, 0x70, 0x65, 0x65, 0x64)
	o = msgp.AppendInt(o, z.Speed)
	// string "Key"
	o = append(o, 0xa3, 0x4b, 0x65, 0x79)
	o = msgp.AppendInt(o, z.Key)
	return
}

// UnmarshalMsg implements msgp.Unmarshaler
func (z *WeaponType) UnmarshalMsg(bts []byte) (o []byte, err error) {
	var field []byte
	_ = field
	var zb0001 uint32
	zb0001, bts, err = msgp.ReadMapHeaderBytes(bts)
	if err != nil {
		err = msgp.WrapError(err)
		return
	}
	for zb0001 > 0 {
		zb0001--
		field, bts, err = msgp.ReadMapKeyZC(bts)
		if err != nil {
			err = msgp.WrapError(err)
			return
		}
		switch msgp.UnsafeString(field) {
		case "BaseItemTypesKey":
			z.BaseItemTypesKey, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "BaseItemTypesKey")
				return
			}
		case "Critical":
			z.Critical, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Critical")
				return
			}
		case "DamageMax":
			z.DamageMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DamageMax")
				return
			}
		case "DamageMin":
			z.DamageMin, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "DamageMin")
				return
			}
		case "Null6":
			z.Null6, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Null6")
				return
			}
		case "RangeMax":
			z.RangeMax, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "RangeMax")
				return
			}
		case "Speed":
			z.Speed, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Speed")
				return
			}
		case "Key":
			z.Key, bts, err = msgp.ReadIntBytes(bts)
			if err != nil {
				err = msgp.WrapError(err, "Key")
				return
			}
		default:
			bts, err = msgp.Skip(bts)
			if err != nil {
				err = msgp.WrapError(err)
				return
			}
		}
	}
	o = bts
	return
}

// Msgsize returns an upper bound estimate of the number of bytes occupied by the serialized message
func (z *WeaponType) Msgsize() (s int) {
	s = 1 + 17 + msgp.IntSize + 9 + msgp.IntSize + 10 + msgp.IntSize + 10 + msgp.IntSize + 6 + msgp.IntSize + 9 + msgp.IntSize + 6 + msgp.IntSize + 4 + msgp.IntSize
	return
}
